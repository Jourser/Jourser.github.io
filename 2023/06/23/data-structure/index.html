<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构笔记, 白米粥のBlog">
    <meta name="description" content="数据结构线性表、栈、队列线性表顺序表顺序表的存储结构 (数据[ ],当前长度)#define MAXSIZE 20             &amp;#x2F;&amp;#x2F;存储空间初始分配量
typedef int ElemType;       ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数据结构笔记 | 白米粥のBlog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">白米粥のBlog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">白米粥のBlog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据结构笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                <span class="chip bg-color">数据结构</span>
                            </a>
                        
                            <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">笔记</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-06-23
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    11.9k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表、栈、队列"><a href="#线性表、栈、队列" class="headerlink" title="线性表、栈、队列"></a>线性表、栈、队列</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><h5 id="顺序表的存储结构-数据-当前长度"><a href="#顺序表的存储结构-数据-当前长度" class="headerlink" title="顺序表的存储结构 (数据[ ],当前长度)"></a>顺序表的存储结构 (数据[ ],当前长度)</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 20             &#x2F;&#x2F;存储空间初始分配量
typedef int ElemType;          &#x2F;&#x2F;ElemType的类型根据实际情况而定（此行可忽略）
typedef struct&#123;
    ElemType data[MAXSIZE];    &#x2F;&#x2F;数组存储数据元素，最大值为MAXSIZE
    int length;                &#x2F;&#x2F;线性表当前长度
&#125;SqList;                       &#x2F;&#x2F;顺序表类型定义
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;插入操作
Status ListInsert(SqList* L, int i, ElemType e)&#123;
    if (L.length &gt;&#x3D; MAXSIZE)          &#x2F;&#x2F;顺序表已满
        return false; 
    if (i&lt;1 || i&gt;L.length+1)
        return false;                 &#x2F;&#x2F;当i不在范围内
    for (int j &#x3D; L.length - 1;j &gt;&#x3D; i - 1;j--)     
        L.data[j + 1] &#x3D; L.data[j];    &#x2F;&#x2F;将插入位置及之后的元素后移一位*&#x2F;
    L.data[i - 1] &#x3D; e;                &#x2F;&#x2F;将新元素插入
    L.length++;                       &#x2F;&#x2F;表长加1
    return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最好的情况：插入到表尾，移动0次，时间复杂度O(1)<br>最坏的情况：插入到表头，移动n次，时间复杂度O(n)<br>平均情况：n&#x2F;2次<br>时间复杂度：O(n)</p>
<h5 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;删除操作
Status ListDelete(SqList* L, int i, ElemType* e)&#123;
    if (L.length &#x3D;&#x3D; 0)
        return false;                 &#x2F;&#x2F;线性表为空
    if (i&lt;1 || i&gt;L.length)
        return false;                 &#x2F;&#x2F;删除位置不正确
    e &#x3D; L.data[i - 1];
    for (int j &#x3D; i ;j &lt; L.length;j++)
        L.data[j - 1] &#x3D; L.data[j];    &#x2F;&#x2F;将删除位置后继元素前移
    L.length--;                       &#x2F;&#x2F;线性表减1
    return OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最好的情况：删除顺序表中最后一个元素，移动0次，时间复杂度O(1)<br>最坏的请况：删除顺序表中第一个元素，移动n-1次，时间复杂度O(n)<br>平均情况：移动（n-1）&#x2F;2<br>时间复杂度：O(n)</p>
<h5 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;顺序表按数据值查找，返回位序
Status LocateElem(SqList L, ElemType e)&#123;
    int i;
    for (i &#x3D; 0;i &lt; L.length;i++)
        if (L.data[i] &#x3D;&#x3D; e)
            return i + 1;         &#x2F;&#x2F;查找成功
    return 0;                     &#x2F;&#x2F;查找失败
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最好的情况：查找1次，时间复杂度O(1)<br>最坏的情况：查找n次，时间复杂度O(n)<br>平均情况：（1+n）&#x2F;2次<br>时间复杂度为：O(n)</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><h5 id="单链表的存储结构-数据-，向后指针-从头结点出发向后"><a href="#单链表的存储结构-数据-，向后指针-从头结点出发向后" class="headerlink" title="单链表的存储结构 (数据[ ]，向后指针)从头结点出发向后"></a>单链表的存储结构 (数据[ ]，向后指针)<font color="#dd0000">从头结点出发向后</font><br></h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct LNode&#123;       &#x2F;&#x2F;定义单链表结点类型
    ElemType data;          &#x2F;&#x2F;数据域
    struct LNode *next;     &#x2F;&#x2F;指针域
&#125;LNode, *LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><em><strong>问题：<u>头结点和头指针的区别？</u></strong></em><br>答：不管带不带头结点，头指针始终指向链表的<font color="#dd0000">第一个结点</font>，而头结点是<font color="#dd0000">带头结点链表</font>中的第一个结点，结点内通常不存储信息。</p>
<h5 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h5><p><strong>头插</strong><br>头指针L <code>s-&gt;next=L-&gt;next;L-&gt;next=s</code><br>头插法建立单链表，读入数据的顺序与生成的链表中元素的顺序是<font color="#dd0000">相反</font>的</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkList CreatList1(LinkList &amp;L)&#123; 
    LNode *s; &#x2F;&#x2F;辅助指针
    int x; 
    L&#x3D;(LinkList)malloc(sizeof(LNode)); &#x2F;&#x2F;创建头结点
    L-&gt;next&#x3D;NULL; &#x2F;&#x2F;初始为空链表
    scanf(”%d”,&amp;x); &#x2F;&#x2F;输入结点的值
    while(x!&#x3D;9999)&#123; &#x2F;&#x2F;输入9999表示结束
        s&#x3D;(LNode*)malloc(sizeof(LNode)); &#x2F;&#x2F;创建新结点
        s-&gt;data&#x3D;x;
        s-&gt;next&#x3D;L-&gt;next;
        L-&gt;next&#x3D;s; &#x2F;&#x2F;将新结点插入表中，L为头指针
    scanf(”%d”,&amp;x); &#x2F;&#x2F;读入下一个结点值
&#125;
    return L;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>尾插</strong><br>尾指针 r-&gt;next&#x3D;s; r&#x3D;s<br>尾插法建立单链表，读入数据的顺序与生成的链表中元素的顺序是<font color="#dd0000">相同</font>的</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkList CreatList2(LinkList &amp;L)&#123; 
    int x; 
    L&#x3D;(LinkList)malloc(sizeof(LNode));
    LNode *s, *r&#x3D;L; &#x2F;&#x2F;r为表尾指针 指向表尾
    scanf(”%d”,&amp;x); &#x2F;&#x2F;输入结点的值
    while(x!&#x3D;9999)&#123; &#x2F;&#x2F;输入9999表示结束
        s&#x3D;(LNode *)malloc(sizeof(LNode)); 
        s-&gt;data&#x3D;x;
        r-&gt;next&#x3D;s; 
        r&#x3D;s; &#x2F;&#x2F;r指向新的表尾结点
        scanf(”%d”,&amp;x);
    &#125;
    r-&gt;next&#x3D;NULL; &#x2F;&#x2F;尾结点指针置空
    return L;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">p&#x3D;GetElem(L,i-1);&#x2F;&#x2F;取指向插入位置的前驱结点的指针
s-&gt;next&#x3D;p-&gt;next;&#x2F;&#x2F;令新结点*s的指针域指向*p的后继结点
p-&gt;next&#x3D;s;&#x2F;&#x2F;.令结点*p的指针域指向新插入的结点*s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">p&#x3D;GetElem(L,i-1);&#x2F;&#x2F;查找输出位置的前驱结点
q&#x3D;p-&gt;next;&#x2F;&#x2F;令q指向删除结点
p-&gt;next&#x3D;q-&gt;next;&#x2F;&#x2F;将*q结点从链中“断开”
free(q);&#x2F;&#x2F;释放结点的存储空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h5><p><strong>按序号查找</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">LNode * GetElem(LinkList L,int i)&#123;
    int j&#x3D;1; &#x2F;&#x2F;计数，初始为1
    LNode *p&#x3D;L-&gt;next; &#x2F;&#x2F;第一个结点指针赋给p
    if(i&#x3D;&#x3D;0) return L; &#x2F;&#x2F;若i等于0，则返回头结点
    if(i&lt;1) return NULL; &#x2F;&#x2F;若i无效，则返回NULL
    while(p&amp;&amp;j&lt;i)&#123; &#x2F;&#x2F;从第1个结点开始找，查找第i个结点
        p&#x3D;p-&gt;next;
        j++;
    &#125;
    return p; &#x2F;&#x2F;返回第i个结点的指针，如果i大于表长，直接返回p即可
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>按值查找</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">LNode *LocateElem(LinkList L,ElemType e)&#123;
    LNode *p&#x3D;L-&gt;next;
    while(p!&#x3D;NULL&amp;&amp;p-&gt;data!&#x3D;e)&#x2F;&#x2F;从第1个结点开始查找data域为e的结点
        p&#x3D;p-&gt;next;
    return p; &#x2F;&#x2F;找到后返回该结点指针，否则返回NULL
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><h5 id="双链表的存储结构-数据-，向后指针，向前指针"><a href="#双链表的存储结构-数据-，向后指针，向前指针" class="headerlink" title="双链表的存储结构 (数据[ ]，向后指针，向前指针)"></a>双链表的存储结构 (数据[ ]，向后指针，向前指针)</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct DNode&#123; &#x2F;&#x2F;定义单链表结点类型
    ElemType data; &#x2F;&#x2F;数据域
    struct DNode *prior,*next; &#x2F;&#x2F;前驱和后继指针
&#125;DNode, *DLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">s-&gt;next&#x3D;p-&gt;next;
p-&gt;next-&gt;prior&#x3D;s;
s-&gt;prior&#x3D;p;
p-&gt;next&#x3D;s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">p-&gt;next&#x3D;q-&gt;next;
q-&gt;next-&gt;prior&#x3D;p;
free(q);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><h5 id="顺序栈的存储结构"><a href="#顺序栈的存储结构" class="headerlink" title="顺序栈的存储结构"></a>顺序栈的存储结构</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MaxSize 50 &#x2F;&#x2F;定义栈中元素的最大个数
typedef struct&#123;
    Elemtype data[MaxSize]; &#x2F;&#x2F;存放栈中元素
    int top; &#x2F;&#x2F;栈顶指针
&#125; SqStack; &#x2F;&#x2F;顺序栈的简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>栈：LIFO 先进先出<br>n个元素进栈，一共有$\frac{1}{n+1}$$C^n_ {2n}$出栈方式<br>进栈：<code>push(e);t++;</code> 出栈：<code>t--;pop()</code><br><code>top</code>指向栈顶下一个空位置，允许插入删除<br><code>bottom</code>指向栈底，固定，不允许插入输出<br>空栈的判定条件：<code>top==-1</code><br>满栈的判定条件：<code>top==MaxSize-1</code><br>栈中数据元素个数为：<code>top+1</code></p>
<h5 id="对顶栈-共享栈"><a href="#对顶栈-共享栈" class="headerlink" title="对顶栈&#x2F;共享栈"></a>对顶栈&#x2F;共享栈</h5><p><img src="/2023/06/23/data-structure/1.png"><br>0号栈栈顶：top0<br>1号栈栈顶：top1<br>进栈：0号进栈<code>top0++</code>;1号进栈<code>top1--</code><br>出栈：与进栈相反<br>空栈的判定条件：<code>top0+1==top1</code><br>满栈的判定条件：<code>top0==-1；top1==MaxSize</code></p>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><h5 id="链栈的存储结构"><a href="#链栈的存储结构" class="headerlink" title="链栈的存储结构"></a>链栈的存储结构</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct SNode&#123;
    Elemtype data; &#x2F;&#x2F;存放栈中元素
    struct SNode *next ; &#x2F;&#x2F;栈顶指针
&#125; SNode，*SLink &#x2F;&#x2F;链栈的结点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="链栈的进栈"><a href="#链栈的进栈" class="headerlink" title="链栈的进栈"></a>链栈的进栈</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool Push(LinkStack *S, ElemType x)&#123;
    SLink p&#x3D;(SLink)malloc(sizeof(SNode)); &#x2F;&#x2F;给新元素分配空间
    p-&gt;data&#x3D;x; &#x2F;&#x2F;新元素的值
    p-&gt;next&#x3D;S-&gt;top; &#x2F;&#x2F;p的后继指向栈顶元素
    S-&gt;top&#x3D;p; &#x2F;&#x2F;栈顶指针指向新的元素
    S-&gt;count++; &#x2F;&#x2F;栈中元素个数加1
    return true; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例代码为不带头结点<br>带头结点：p-&gt;next&#x3D;S-&gt;top-&gt;next; S-&gt;top-&gt;next&#x3D;p;<br>不带头结点：p-&gt;next&#x3D;S-&gt;top; S-&gt;top&#x3D;p; </p>
<h5 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool Pop(LinkStack *S, ElemType&amp;x)&#123;
    if(S-&gt;top&#x3D;&#x3D;NULL) return false;
    x&#x3D;S-&gt;top-&gt;data; &#x2F;&#x2F;栈顶元素值
    Slink p&#x3D;S-&gt;top; &#x2F;&#x2F;辅助指针
    S-&gt;top&#x3D;S-&gt;top-&gt;next; &#x2F;&#x2F;栈顶指针后移
    free(p); &#x2F;&#x2F;释放被删除数据的存储空间
    S-&gt;count--; &#x2F;&#x2F;栈中元素个数减一
    return true; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例代码为不带头结点<br>不带头结点：p&#x3D;S-&gt;top; S-&gt;top&#x3D;S-&gt;top-&gt;next; free(p);<br>带头结点：p&#x3D;S-&gt;top-&gt;next; S-&gt;top-&gt;next&#x3D;p-&gt;next; </p>
<h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><h5 id="1-函数与递归-先调用后执行-用栈来保留先调用的函数，出栈再执行"><a href="#1-函数与递归-先调用后执行-用栈来保留先调用的函数，出栈再执行" class="headerlink" title="1.函数与递归(先调用后执行 用栈来保留先调用的函数，出栈再执行)"></a>1.函数与递归(先调用后执行 用栈来保留先调用的函数，出栈再执行)</h5><h5 id="2-表达式求值-前缀-中缀-后缀"><a href="#2-表达式求值-前缀-中缀-后缀" class="headerlink" title="2.表达式求值(前缀 中缀 后缀)"></a>2.表达式求值(前缀 中缀 后缀)</h5><p>例：<br>中缀表达式：A+B*(C-D)-E&#x2F;F<br>后缀表达式：ABCD-*+EF&#x2F;-<br>对应二叉树：数字在两边，符号在中间<br><img src="/2023/06/23/data-structure/2.png"><br>前序——&gt;前缀<br>中序——&gt;中缀<br>后序——&gt;后缀<br>计算机普遍利用后缀表达式计算，计算规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。<br><strong>中缀转后缀</strong><br>有两个栈，一个为数字栈，一个为符号栈<br>规则：<br>1.操作数直接入数字栈<br>2.遇到<code>(</code>入数字栈，直到遇到<code>)</code>将里面全部弹出<br>3.弹出栈中优先级高或者等于当前运算符中的所有运算符，直到遇到<code>(</code>。<br>在符号栈中，符号的优先级是不断上升的<br>比如以<code>(</code>为分界点,<code>*</code>和<code>/</code>一直在<code>+</code>和<code>-</code>上面，且不会有连续的同优先级出现。<br>如<code>+(-*</code>正确，<code>+(*-</code>错误</p>
<h5 id="3-进制转换"><a href="#3-进制转换" class="headerlink" title="3.进制转换"></a>3.进制转换</h5><h5 id="4-括号匹配"><a href="#4-括号匹配" class="headerlink" title="4.括号匹配"></a>4.括号匹配</h5><p>括号匹配算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列：FIFO 先进先出<br>双端队列：<br>1.输入受限，两端都可以出，只有一端可以入<br>2.输出受限，两端都可以入，只有一端可以出<br>队列的应用：1.排队；2.打印机；3.层次遍历；4.BFS；5.基数排序</p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p><code>front</code>指队首；<code>rear</code>指队尾的下一个元素<br>队列空：<code>front==rear</code><br>队列满：<code>(rear+1)%MaxSize==front</code><br>入队：<code>rear=(rear+1)%MaxSize</code><br>出队：<code>front=(front+1)%MaxSize</code><br>长度：<code>(rear+MaxSize-front)%MaxSize</code></p>
<h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p>一般为带尾指针的单循环链表<br>插入：尾插，尾改头不改<br>删除：头插，头改尾不改；<font color="#dd0000">删除到最后，头尾都要改</font>。<br>入队：rear++；放入<br>&emsp;与单链表插入操作一致</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void EnQueue(LinkQueue &amp;Q，ElemType x)&#123;
    s&#x3D;(LinkNode *)malloc(sizeof(LinkNode));
    s-&gt;data&#x3D;x; 
    s-&gt;next&#x3D;NULL; 
    Q.rear-&gt;next&#x3D;s;
    Q.rear&#x3D;s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>出队：放出；front++<br>&emsp;头结点的后继结点出队</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">==</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">//空队</span>
    p<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>
    x<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">==</span>p<span class="token punctuation">)</span> Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span> <span class="token comment">//若原队列中只有一个结点，删除后变空</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的度：树中结点的最大度数<br>结点的度：子结点的个数<br>路径：两个结点之间的结点序列</p>
<p>1.结点数为所有结点度数+1<br>2.m度树，叶子结点个数$n_{0}&#x3D;n_{2}+2n_{3}+…(m-1)n_{m}+1$<br>$n_{2}$为度为2的结点个数</p>
<h3 id="二叉树和完全二叉树"><a href="#二叉树和完全二叉树" class="headerlink" title="二叉树和完全二叉树"></a><font color="#dd0000">二叉树和完全二叉树</font></h3><h4 id="二叉树的链式存储结构："><a href="#二叉树的链式存储结构：" class="headerlink" title="二叉树的链式存储结构："></a>二叉树的链式存储结构：</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment">//指向该结点的左、右孩子指针</span>
<span class="token punctuation">&#125;</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span> <span class="token comment">//二叉树结点结构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="特殊性质："><a href="#特殊性质：" class="headerlink" title="特殊性质："></a>特殊性质：</h4><p>1.非空二叉树&emsp;叶子结点数$n_{0}$为度为2的结点数+1，即$\mathbf{n_{0}&#x3D;n_{2}+1}$<br>2.<strong>k</strong>层树至少有$\mathbf{2^{k-1}}$个结点<br>3.高度为<strong>h</strong>至多有个$\mathbf{2^{h-1}}$结点<br>4.具有<strong>n</strong>个节点的二叉树，最小高度$\lfloor\mathbf{log_2{n}+1}\rfloor$向下取整</p>
<h4 id="完全二叉树的独有性质"><a href="#完全二叉树的独有性质" class="headerlink" title="完全二叉树的独有性质"></a>完全二叉树的独有性质</h4><p>完全二叉树：除了最后一行，其余层全满<br>全满<strong>k</strong>层，一共$\mathbf{2^{k}-1}$个结点<br>1.<strong>n</strong>个结点深度：$\lfloor\mathbf{log_2{n}+1}\rfloor$向下取整或$\lceil\mathbf{log_2{(n+1)}}\rceil$向下取整<br>2.右子树最大I层，左子树最大I+1或I层<br>3.双亲结点 $\lfloor\mathbf{i&#x2F;2}\rfloor$<br>4.度为1的个数只有0或1<br>5.叶子结点出现在k层或者k-1层，k为深度<br>6.当该层编好后出现一结点为叶子结点或只有左子树，则之后都是叶子结点，如下图为某一层的最后结点<br><img src="/2023/06/23/data-structure/3.png"> 384之后都是叶子结点，所以叶子结点数：768-384&#x3D;384</p>
<h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>先序：根左右<br>中序：左根右<br>后序：左右根<br>层次：按照层次遍历<br>中+层$\Rightarrow$层<br>中+后$\Rightarrow$后<br>中+先$\Rightarrow$先<br>先确定根，中序确定左右</p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>方便查找前驱、后继和遍历(前驱后继根据中序)<br>1.有左孩子，指向左孩子；无，则指向前驱<br>2.有右孩子，指向右孩子；无，则指向后继<br><em><strong>问题：<u>如何区分指针是指向左孩子还是前驱，或者指向右孩子还是后继？</u></strong></em><br>答：在二叉链表的结构基础上增加两个标志位<code>ltag</code>和<code>rtag</code><br>$ ltag&#x3D;<br>0，左孩子；<br>1，前驱<br>$<br>$ rtag&#x3D;<br>0，右孩子；<br>1，后继<br>$</p>
<h4 id="树、森林和二叉树转换"><a href="#树、森林和二叉树转换" class="headerlink" title="树、森林和二叉树转换"></a>树、森林和二叉树转换</h4><p>一般树转化为二叉树规则：<strong>左孩子不变，右孩子变为右兄弟</strong>，如下图所示：<br><img src="/2023/06/23/data-structure/4.png"><br>根右边一定为空，所以<strong>根据根的右子树情况，可判断森林中树的个数</strong><br>森林转化为二叉树规则：先将每棵树转化为二叉树，再将每棵树的根相连<br>$树\Rightarrow二叉树$：$先序\Rightarrow先序；$$后序\Rightarrow中序；$$中序\Rightarrow中序$</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>WPL带权路径最小<br>权重大的在上面，权重小的在下面<br>不够需要补0，&emsp;补几个，利用$n_0&#x3D;(m-1)n_m+1$，$n_m$为整数，所以$n_m&#x3D;\frac{n_0-1}{m-1}$最后得$n_0$<br>左0右1<br>只有0度和2度的结点<br><strong>前缀编码判定方法</strong>：<br>1.任何一个编码不能是一个编码的前缀<br>2.画树，找度为1的点，$n_1&#x3D;1$不能是前缀编码</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>度之和&#x3D;边*2<br>完全图边数：$\frac{n(n-1)}{2}$<br>顶点集<code>V</code> &emsp;边集<code>E</code><br>非连通：最多$\mathbf{C^2_ {n-1}}$条边<br>连通：最少$\mathbf{C^2_ {n-1}+1}$条边<br>强联通(顶点v到w或w到v都有路径)：最少$\mathbf{n}$条边<br>简单路径：顶点不重复 &emsp;简单回路：首尾相同其余不重复</p>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/2023/06/23/data-structure/5.png"><br>如图所得邻接矩阵：<br><br><img src="/2023/06/23/data-structure/31.png"></p>
<p>若是有向图，则是指向为1，例：<br><img src="/2023/06/23/data-structure/6.png"><br>如图所得邻接矩阵：<br><br><img src="/2023/06/23/data-structure/32.png"></p>
<p><font color="#dd0000">邻接矩阵唯一，遍历结果也唯一</font><br>空间复杂度：$O(n^2)$ &emsp; 遍历时间复杂度：$O(n^2)$</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p><strong><font color="#dd0000">适用于稀疏图(|E|远小于|V|^2)</font></strong></p>
<h5 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h5><p><img src="/2023/06/23/data-structure/7.png"></p>
<h5 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h5><p><img src="/2023/06/23/data-structure/8.png"><br><font color="#dd0000">邻接表不唯一，遍历结果不唯一。但若是已经给定邻接表，遍历结果唯一。</font><br>遍历时间复杂度：$O(n+e)$</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h4><p><strong>空间复杂度</strong>：<br>BFS需要借助一个<strong>队列</strong>，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要$\mathbf{O(|V|)}$的空间复杂度。<br><strong>时间复杂度</strong>：<br>1)邻接表：每个顶点入队一次，时间复杂度为$\mathbf{O(|V|)}$,对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为$\mathbf{O(|E|)}$。所以总的时间复杂度为$\mathbf{O(|V|+|E|)}$<br>2)邻接矩阵：每个顶点入队一次，时间复杂度为$\mathbf{O(|V|)}$,对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为$\mathbf{O(|V|)}$,所以总的时间复杂度为$\mathbf{O(|V|^2)}$</p>
<h4 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h4><p><strong>空间复杂度</strong>：<br>由于DFS是一个递归算法，递归是需要一个<strong>工作栈</strong>来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为$\mathbf{O(|V|)}$<br><strong>时间复杂度（与BFS相同）</strong>：<br>1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为$\mathbf{O(|E|)}$,访问顶点时间为$\mathbf{O(|V|)}$,所以总的时间复杂度为$\mathbf{O(|V|+|E|)}$<br>2)邻接矩阵：查找每个顶点的邻接点时间复杂度为$\mathbf{O(|V|)}$,对每个顶点都进行查找，所以总的时间复杂度为$\mathbf{O(|V|^2)}$</p>
<h3 id="图的应用——最小生成树的构造算法和性质"><a href="#图的应用——最小生成树的构造算法和性质" class="headerlink" title="图的应用——最小生成树的构造算法和性质"></a>图的应用——最小生成树的构造算法和性质</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>n个顶点，n-1条边<br>规则：<br>①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。<br>②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。<br>③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。<br>④反复执行②③直到所有所有顶点都加入到生成树中。<br><font color="#dd0000">PS:只有当图中每条边的权重均不相等时，Prim和Kruskal算法生成的MST一定唯一。而若是Kruskal能完成唯一判断，则基本上就是唯一的。</font><br>需要维护两个数组：<code>lowcost[n]</code>和<code>adjvex[n]</code>（n是图中的顶点数）<br><code>lowcost[n]</code>记录边长<br><code>adjvex[n]</code>记录该条边从那个顶点出发</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Void <span class="token function">MiniSpanTree_Prim</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> min<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>
    <span class="token keyword">int</span> adjvex<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//保存邻接顶点下标的数组</span>
    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录当前生成树到剩余顶点的最小权值</span>
    lowcost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//将0号顶点(以0号顶点作为第一个顶点)加入生成树</span>
    adjvex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//由于刚开始生成树只有一个顶点 不存在边 干脆都设为0</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//除下标为0以外的所有顶点</span>
        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将与下标为0的顶点有边的权值存入Lowcost数组</span>
            djvex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//这些顶点的adjvex数组全部初始化为0</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//算法核心</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//只需要循环N-1次，N为顶点数</span>
        min<span class="token operator">=</span><span class="token number">65535</span><span class="token punctuation">;</span> <span class="token comment">//tip：因为要找最小值，不妨先设取一个最大的值来比较</span>
        j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//找出lowcost最小的 最小权值给min，下标给k</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//从1号顶点开始找</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span> <span class="token comment">//不在生成树中的顶点而且权值更小的</span>
                 min<span class="token operator">=</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//更新更小的值</span>
                k<span class="token operator">=</span>j<span class="token punctuation">;</span>  <span class="token comment">//找到了新的点下标给k</span>
            <span class="token punctuation">&#125;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//再看下一个顶点</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span><span class="token operator">%</span>d<span class="token operator">-></span><span class="token operator">%</span>d<span class="token punctuation">)</span>”<span class="token punctuation">,</span>adjvex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印权值最小的边</span>
        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//将这个顶点加入生成树</span>
        <span class="token comment">//生成树加入了新的顶点 从下标为1的顶点开始更新lowcost数组值</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//如果新加入树的顶点k使得权值变小</span>
            lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//更新更小的权值</span>
            adjvex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>
        <span class="token comment">//修改这条边邻接的顶点也就是表示这条边是从选出的顶点k指过来的方便打印     </span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度为<strong>O(n^2)</strong><br>而且时间复杂度只和n有关，所以适合<strong>稠密图</strong></p>
<h4 id="Kruskal-克鲁斯卡尔-算法"><a href="#Kruskal-克鲁斯卡尔-算法" class="headerlink" title="Kruskal(克鲁斯卡尔)算法"></a>Kruskal(克鲁斯卡尔)算法</h4><p>找最小边，不能形成回路</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>  <span class="token comment">//边的两个顶点</span>
    <span class="token keyword">int</span> weight<span class="token punctuation">;</span> <span class="token comment">//边的权值</span>
<span class="token punctuation">&#125;</span>Edge<span class="token punctuation">;</span>  <span class="token comment">//边结构体</span>
<span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">=</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//循环向上寻找下标为x顶点的根</span>
    <span class="token keyword">return</span>  x<span class="token punctuation">;</span>  <span class="token comment">//while循环结束时找到了根的下标</span>
<span class="token punctuation">&#125;</span>
Edge edges<span class="token punctuation">[</span>MaxEdge<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//边数组</span>
<span class="token keyword">int</span> parent<span class="token punctuation">[</span>MaxVex<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//父亲顶点数组(并查集)</span>
Void <span class="token function">MiniSpanTree_Kruskal</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span>  i <span class="token punctuation">,</span> n <span class="token punctuation">,</span> m<span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//按权值由小到大对边排列</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//初始化：各个顶点单独形成一个集合</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>arcnum <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//扫描每条边</span>
        n<span class="token operator">=</span><span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//n是这条边的第一个顶点的根顶点所在下标</span>
        m<span class="token operator">=</span><span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//m是这条边第二个顶点的根顶点所在下标</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">!=</span>m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//根顶点不相同 这条边不会构成环</span>
             parent<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span>m<span class="token punctuation">;</span>  <span class="token comment">//并操作</span>
            <span class="token comment">//作为生成树的一条边打印出来</span>
            <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span><span class="token operator">%</span>d<span class="token operator">-></span><span class="token operator">%</span>d<span class="token punctuation">)</span> ”<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度：$O(|E|log|E|)$<br>主要时间耗费在排序上。排序和图中边的数量有关系，所以适合<strong>稀疏图</strong>。</p>
<h3 id="图的应用——AOV网和AOE网、拓扑排序、关键路径"><a href="#图的应用——AOV网和AOE网、拓扑排序、关键路径" class="headerlink" title="图的应用——AOV网和AOE网、拓扑排序、关键路径"></a>图的应用——AOV网和AOE网、拓扑排序、关键路径</h3><h4 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h4><p>有向网 &emsp;&lt;$V_i$,$V_j$&gt;,$V_i$完成必须先于$V_j$（无环），顶点表示活动，能被拓扑排序的便是AOE网</p>
<h4 id="拓扑排序（考得更多）"><a href="#拓扑排序（考得更多）" class="headerlink" title="拓扑排序（考得更多）"></a><font color="#dd0000">拓扑排序</font>（考得更多）</h4><p>不唯一<br>每个顶点最多一次；<br>A在B前面，则没有B到A的路径<br>从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。<br>由于拓扑排序需要删除边和顶点，所以使用邻接表存储图比较方便。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">TopologicalSort</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化栈，存储入度为0的顶点</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将所有入度为0的顶点进栈</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//计数，记录当前已经输出的顶点数</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//栈不空，则存在入度为0的顶点</span>
        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//栈顶元素出栈</span>
        <span class="token function">pritnf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>d”<span class="token punctuation">,</span>G<span class="token punctuation">.</span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>ArcNode <span class="token operator">*</span>p<span class="token operator">=</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span> p<span class="token punctuation">;</span> p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            v<span class="token operator">=</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span> <span class="token comment">//取这条弧指向的顶点</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">--</span>indegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//入度减1为0，则入栈</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">)</span><span class="token keyword">return</span>  false<span class="token punctuation">;</span>    <span class="token comment">//排序失败，有向图中有回路</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span>  true<span class="token punctuation">;</span> 	<span class="token comment">//拓扑排序成功</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度：O(n+e)</p>
<h4 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h4><p>带权的有向无环，用顶点表示事件，<strong>用边表示活动</strong></p>
<h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><p>1.顶点事件发生，各条边活动才能开始；<br>2.各边活动结束，顶点事件才能发生<br>最大路径长度的路径：关键路径<br>关键路径上的活动：关键活动<br>工程最短时间：关键路径长度</p>
<p>1.加快关键活动缩短工期<br>2.关键路径不唯一，要缩短所有关键路径的公共部分或者都缩短</p>
<p>最早事件开始时间：正推法 &emsp;从头到该事件的<strong>最长</strong>路径  <strong>值最大</strong><br>最晚事件开始时间：倒推法 &emsp;从最大路径往前到该事件的<strong>最小</strong>路径  <strong>值最小</strong><br><font color="#dd0000">关键路径的最早发生时间和最晚发生时间是一样的！</font></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra-迪杰斯特拉-算法-选择题中最难题"><a href="#Dijkstra-迪杰斯特拉-算法-选择题中最难题" class="headerlink" title="Dijkstra(迪杰斯特拉)算法 选择题中最难题"></a>Dijkstra(迪杰斯特拉)算法 选择题中最难题</h4><p><code>dist[]</code>：记录了从源点v0到其他各顶点当前的最短路径长度<br><code>path[]</code>：<code>path[i]</code>表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。<br><img src="/2023/06/23/data-structure/9.png"><br><strong>时间复杂度</strong>：迪杰斯特拉算法的核心部分在于一个双重循环，这个双重循环的内循环又是两个并列的单重for循环组成(找距离最小顶点和更新距离),任意取其中一个循环中的操作为基本操作，都可以得出迪杰斯特拉算法的时间复杂度为$\mathbf{O(n^2)}$ 其中n为图中的顶点数。</p>
<h4 id="Floyd-弗洛伊德-算法"><a href="#Floyd-弗洛伊德-算法" class="headerlink" title="Floyd(弗洛伊德)算法"></a>Floyd(弗洛伊德)算法</h4><p>求图中任意一对顶点间的最短路径的算法<br>递推产生一个n阶方阵序列$A^{(−1)}$，$A^{(0)}$，…，$A^{(k)}$，…，$A^{(n−1)}$<br>其中$A^{(k)}[i][j]$表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。<br>$A^{(k)}[i][j]&#x3D;Min{A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j]}$<br><strong>时间复杂度</strong>：弗洛伊德算法的核心为一个三重循环，所以时间复杂度为$\mathbf{O(n^3)}$ 其中n是图中的顶点数。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>仅适用于顺序存储，有序顺序表<br>时间复杂度：$\mathbf{O(log_2n)}$<br>1.默认使用$\lfloor\mathbf{\frac{low+high}{2}}\rfloor&#x3D;mid$向下取整<br>2.平均查找长度ASL取决于其树型结构。而树型结构只取决于元素个数<br>$ASL\approx$$log_2(n+1)-1$<br><img src="/2023/06/23/data-structure/10.png"><br>ASL成功&#x3D;（1+2+2+3+3+3+3+4)&#x2F;8&#x3D;21&#x2F;8<br>ASL失败&#x3D;（3+3+3+3+3+3+3+4+4)&#x2F;9&#x3D;29&#x2F;9</p>
<h3 id="BST二叉排序树的查找、插入和删除"><a href="#BST二叉排序树的查找、插入和删除" class="headerlink" title="BST二叉排序树的查找、插入和删除"></a>BST二叉排序树的查找、插入和删除</h3><p>BST二叉排序树:左小右大<br><img src="/2023/06/23/data-structure/11.png"></p>
<h4 id="查找-非递归"><a href="#查找-非递归" class="headerlink" title="查找(非递归)"></a>查找(非递归)</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">BiTNode <span class="token operator">*</span> <span class="token function">BST_Search</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>t<span class="token punctuation">,</span>ElemType key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    BiTNode <span class="token operator">*</span>p<span class="token operator">=</span>t<span class="token punctuation">;</span>  <span class="token comment">//工作指针 初值指向二叉排序树根结点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> key<span class="token operator">!=</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">/</span>p不为空且没有找到key
        <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span>  
            p<span class="token operator">=</span>p<span class="token operator">-></span>lchild<span class="token punctuation">;</span><span class="token comment">//如果key值比p指向结点值小，则查找左子树</span>
        <span class="token keyword">else</span>  
            p<span class="token operator">=</span>p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>  <span class="token comment">//如果key值比p指向结点值大，则查找右子树</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token comment">//查找成功返回指向值为key值的结点的指针 查找失败返回NULL </span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最好效率：$\mathbf{O(log_2n)}$<br>最坏效率：$\mathbf{O(n)}$</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>1.删叶子，直接删<br>2.删除的是仅有左子树或者右子树的结点，让其子树取代，“子承父业”<br>3.删除的是左右子树都有的结点。中序遍历，删除结点的直接前驱或者直接后继结点来取代。</p>
<h3 id="AVL平衡二叉树树的性质和调整"><a href="#AVL平衡二叉树树的性质和调整" class="headerlink" title="AVL平衡二叉树树的性质和调整"></a>AVL平衡二叉树树的性质和调整</h3><p>左右子树的高度差不超过1，为平衡二叉树<br>高度差为<strong>平衡因子</strong>，平衡二叉树的结点平衡因子只有0，-1和1<br>平衡二叉树可以为空树</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入后二叉树不平衡了<br>从插入路径上找到与插入结点最近的<strong>平衡因子绝对值大于1</strong>的结点，将其作为根的<strong>子树</strong>（组成三个点，按照以下情况调整）</p>
<h5 id="LL调整"><a href="#LL调整" class="headerlink" title="LL调整"></a>LL调整</h5><p><img src="/2023/06/23/data-structure/12.png"></p>
<h5 id="RR调整"><a href="#RR调整" class="headerlink" title="RR调整"></a>RR调整</h5><p><img src="/2023/06/23/data-structure/13.png"></p>
<h5 id="LR调整"><a href="#LR调整" class="headerlink" title="LR调整"></a>LR调整</h5><p><img src="/2023/06/23/data-structure/14.png"></p>
<h5 id="RL调整"><a href="#RL调整" class="headerlink" title="RL调整"></a>RL调整</h5><p><img src="/2023/06/23/data-structure/15.png"></p>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>插入看自己，删除看兄弟<br>1.用<strong>二叉排序树删除</strong>的方法删（叶子直接删；只有一颗子树，用子树代替；两颗子树都有，中序遍历用前驱或者后继代替）<br>2.从删除的位置向上找到第一个<strong>不平衡点</strong>，从该点向下高度最高的点，一条线有三个。(以x，y，z为例，z为第一个不平衡点，y是z的最高孩子结点，x是y的最高孩子结点)<br>3.之后同上的插入方法，根据x，y，z的情况旋转<br>深度为h的最少结点数为$N_n$<br>$N_0&#x3D;0$，$N_1&#x3D;1$，$N_2&#x3D;2$，$N_n&#x3D;N_{(n-1)}+N_{(n-2)}$+1</p>
<h3 id="B树和B-树的性质"><a href="#B树和B-树的性质" class="headerlink" title="B树和B+树的性质"></a><font color="#dd0000">B树和B+树的性质</font></h3><h4 id="m阶B树特点"><a href="#m阶B树特点" class="headerlink" title="m阶B树特点"></a>m阶B树特点</h4><p>1）树中每个结点至多有<strong>m</strong>棵子树。（即至多含有<strong>m-1个关键字</strong>) (“两棵子树指针夹着一个关键字”)<br>2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)<br>3）除根结点外的所有非叶结点至少有⌈m&#x2F;2⌉(向上取整)棵子树。（即至少含有⌈m&#x2F;2⌉-1个关键字）<br>如图所示是一个5阶B树：<br><img src="/2023/06/23/data-structure/16.png"></p>
<h5 id="B树结点子树个数"><a href="#B树结点子树个数" class="headerlink" title="B树结点子树个数"></a>B树结点子树个数</h5><p><strong>根结点</strong>:子树个数$\mathbf{[2,m]}$ &emsp; 关键字数$\mathbf{[1,m-1]}$<br><strong>其他结点</strong>:子树个数$\mathbf{[⌈m&#x2F;2⌉,m]}$ &emsp; 关键字数$\mathbf{[⌈m&#x2F;2⌉-1,m-1]}$<br><strong>该类题求解方法：</strong><br>1.关键字最少$\Leftrightarrow$子树少$\Leftrightarrow$结点少；<br>2.关键字个数：<br>&emsp;最少结点：每个结点的关键字最多，m-1<br>&emsp;最多结点：每个结点的关键字最少，⌈m&#x2F;2⌉-1</p>
<h4 id="m阶B-树特点"><a href="#m阶B-树特点" class="headerlink" title="m阶B+树特点"></a>m阶B+树特点</h4><p>结点的子树个数与关键字个数相同<br>支持顺序查找和随机查找，B树只支持随机<br><img src="/2023/06/23/data-structure/17.png"><br>m阶的B+树与m阶的B树的<strong>主要差异</strong>在于：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即<font color="#dd0000">每个关键字对应一棵子树</font>；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m&#x2F;2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m&#x2F;2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。<br>3）在B+树中，<font color="#dd0000">叶结点包含信息，所有非叶结点仅起到索引作用</font>，非叶结点中的每个索引项只含有对应子树的<font color="#dd0000">最大关键字</font>和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，<font color="#dd0000">叶结点包含了全部关键字</font>，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。<br>主要应用：<br>编译器中的词法分析：二叉树<br>数据库索引：B+<br>路由表查找：折半</p>
<h4 id="B树插入与删除"><a href="#B树插入与删除" class="headerlink" title="B树插入与删除"></a>B树插入与删除</h4><h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>可能插入后B树的高度+1，因为根结点也进行分裂<br>步骤：<br>1.找到插入的叶子结点<br>2.若该结点插入后，关键字仍小于等于m-1，则直接插入。反之，则将需要<strong>分裂</strong>。分裂的方法：取这个关键字数组中的中间关键字(⌈m&#x2F;2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。需要从该结点的父结点持续向上进行，若不符合要求，就依次分裂直到根结点。<br><img src="/2023/06/23/data-structure/18.png"></p>
<h5 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h5><h5 id="1）删除的关键字不在终端结点上（最底层非叶子结点）"><a href="#1）删除的关键字不在终端结点上（最底层非叶子结点）" class="headerlink" title="1）删除的关键字不在终端结点上（最底层非叶子结点）"></a>1）删除的关键字不在终端结点上（最底层非叶子结点）</h5><p>用直接前驱(最右下)和直接后继(最左下)来代替，然后便转换为了“在终端结点”的问题<br><img src="/2023/06/23/data-structure/19.png"></p>
<h5 id="2）删除的关键字在终端结点上（最底层非叶子结点）"><a href="#2）删除的关键字在终端结点上（最底层非叶子结点）" class="headerlink" title="2）删除的关键字在终端结点上（最底层非叶子结点）"></a>2）删除的关键字在终端结点上（最底层非叶子结点）</h5><p>1.结点内关键字数量<strong>大于</strong>⌈m&#x2F;2⌉-1(不能等于)，删除后仍大于等于⌈m&#x2F;2⌉-1这时删除这个关键字不会破坏B树的定义要求。所以直接删除。<br>2.结点内关键字数量<strong>等于</strong>⌈m&#x2F;2⌉-1，并且其左右兄弟结点中存在关键字数量<strong>大于</strong>⌈m&#x2F;2⌉-1 的结点，则去兄弟阶段中借关键字。<br><img src="/2023/06/23/data-structure/20.png"><br>3.结点内关键字数量<strong>等于</strong>⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中都是关键字数量<strong>等于</strong>⌈m&#x2F;2⌉-1 的结点，则需要进行结点合并。<br><img src="/2023/06/23/data-structure/21.png"></p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>主要是<strong>除留余数法</strong>m，H(key)&#x3D;key % p</p>
<h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><p>1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。<strong>易“堆积”</strong>，降低查找效率<br>2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为$d\pm1^2$，$d\pm2^2$……$d\pm{k^2}$<br>$m$是列表长度，则$k\leq{m&#x2F;2}$,$m$必须是一个$4k+3$的质数<br>平方探测法是一种较好的处理冲突的方法，可以<strong>避免</strong>出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</p>
<h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以<strong>把所有的同义词存储在一个线性链表中</strong>，这个线性链表由其散列地址唯一标识。拉链法适用于<strong>经常进行插入和删除的情况</strong>。<br><img src="/2023/06/23/data-structure/22.png"><br>ASL成功$&#x3D;\frac{1\times6+2\times4+3\times1+4\times1}{12}$ &emsp;分母12为总数据个数<br>ASL失败$&#x3D;\frac{0+4+0+2+0+0+2+1+0+0+2+1+0}{13}$ &emsp;分母13为散列表长度</p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>装填因子：散列表的装填因子一般记为α，定义为一个表的装满程度。<br>计算方法为α&#x3D;表中记录数𝑛&#x2F;散列表长度𝑚<br>散列表的平均查找长度依赖于散列表的填装因子α，而不直接依赖于n或m。<br>α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小。<br><font color="#dd0000">散列函数、冲突处理方法、装填因子以上三者都是影响平均查找长度的因素</font></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。<br>可以用链表，则移动次数减少，但比较次数增多<br>特点：<strong>前半部分是有序的</strong> 第n趟排序，则至少有n+1个有序</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void InsertSort(ElemType A[],int n)&#123;
    int i,j;
    for(i&#x3D;2;i&lt;&#x3D;n;i++)	
        if(A[i].key&lt;A[i-1].key)&#123;	
            A[0]&#x3D;A[i];&#x2F;&#x2F;复制为哨兵，A[0]不存放元素
            for(j&#x3D;i-1;A[0].key&lt;A[j].key;--j)
                A[j+1]&#x3D;A[j];&#x2F;&#x2F;所有比待插入元素值大的都往后移一位，腾出空位
            A[j+1]&#x3D;A[0];&#x2F;&#x2F;复制到插入位置 
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>空间复杂度</strong>：在下标为0处存储哨兵，是常数个辅助空间大小，所以空间复杂度为$O(1)$<br><strong>时间复杂度</strong>：最好$O(n)$，最坏$O(n^2)$，实际<font color="#dd0000">$\mathbf{O(n^2)}$</font>，**<font color="#dd0000">稳定</font>**</p>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>只能顺序表<br>通过折半查找到插入的位置</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">//i记录的是待插入的元素下标，也就是说i-1之前的元素都是有序的	</span>
        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//保存待插入的值			</span>
        low<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>high<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	 <span class="token comment">//折半查找	</span>
            mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>	
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> high<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 
            <span class="token keyword">else</span> low<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>	
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//找到了待插入的位置 接下来从后往前依次后移元素腾出位置</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span>A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>		
        A<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//因为此时high指向的是待插入位置的前一位		</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>减少了比较次数————$O(nlog_2n)$<br>但时间复杂度仍是<font color="#dd0000">$\mathbf{O(n^2)}$</font>，**<font color="#dd0000">稳定</font>**</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>仅适用于顺序表<br>希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。<br>①先以增量5来分割序列，也就是下标为0,5,10,15…的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。<br>②缩小增量(d1&#x3D;n&#x2F;2，di+1&#x3D; ⌊di&#x2F;2⌋，比如10个数据序列，第一次增量d1&#x3D;10&#x2F;2&#x3D;5,第二次增量d2&#x3D; ⌊d1&#x2F;2⌋&#x3D; ⌊5&#x2F;2⌋&#x3D;2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。<br>③接下来的第三轮，第四轮…都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。<br><img src="/2023/06/23/data-structure/23.png"><br>步长为d，则分组就有d个分组<br><strong>希尔排序的优势：</strong><br>希尔排序的每一轮都会使整个序列变得越来越有序，最后一轮当增量为1的时候，整个序列几乎都是有序的，所以进行直接插入排序会提高排序的效率。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span> <span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>dk<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>dk<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>dk<span class="token operator">=</span>dk<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//初始增量为总长度的一半,之后依次除2且向下取整,且最后一次要为1</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>dk<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span>dk<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//A[i].key是待插入的关键字，i-dk之前的都是有序的，如果待插入的比有序序列最后一个小则需要进行排序(进入if语句块)，如果大则不需要(跳出if语句块)</span>
                A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//待插入关键字暂存在A[0]</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>dk<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> j<span class="token operator">-=</span>dk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">//待插入关键字之前以dk为增量的关键字只要比待插入关键字大的都往后移动dk位</span>
                    A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>		
                    A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
                    <span class="token comment">//找到了待插入的位置，就将待插入关键字插入这个位置			</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>空间复杂度</strong>：希尔排序的空间复杂度为$O(1)$<br><strong>时间复杂度</strong>：希尔排序的时间复杂度约为<font color="#dd0000">$\mathbf{O(n^{1.3})}$</font>    在最坏情况下希尔排序的时间复杂度为$O(n^2)$<br>**<font color="#dd0000">不稳定</font>**：由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        flag<span class="token operator">=</span>false<span class="token punctuation">;</span><span class="token comment">//tips:当整个序列都有序的时候，标志位是不发生修改的，从而表示已经排好了	</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//一趟冒泡过程</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果前面的元素比后面的大，则需要做交换</span>
                ElemType temp<span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>
                A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>
                A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">=</span>temp<span class="token punctuation">;</span>	
                flag<span class="token operator">=</span>true<span class="token punctuation">;</span> <span class="token comment">//发生了数据交换 修改标志位</span>
            <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span>false<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment">//本趟遍历后没有发生交换，说明表已经有序</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>空间复杂度</strong>：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)<br><strong>时间复杂度</strong>：最好$\mathbf{O(n)}$，最坏$\mathbf{O(n^2)}$，实际<font color="#dd0000">$\mathbf{O(n^2)}$</font>，**<font color="#dd0000">稳定</font>**</p>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>顺序表<br>每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//划分函数</span>
<span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//low是当前待排序的序列起始下标，high是末尾下标</span>
    ElemType pivot<span class="token operator">=</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//第一个元素作为枢轴</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">>=</span>pivot<span class="token punctuation">)</span> <span class="token operator">--</span>high<span class="token punctuation">;</span><span class="token comment">//先从末尾往前找到第一个比枢轴小的元素</span>
        A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//用high的元素替换low的元素</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> <span class="token operator">++</span>low<span class="token punctuation">;</span> <span class="token comment">//再从开头往后找到第一个比枢轴大的元素</span>
        A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//用low的元素替换high的元素</span>
    <span class="token punctuation">&#125;</span>
    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>pivot<span class="token punctuation">;</span><span class="token comment">//枢轴元素存放到最终位置</span>
    <span class="token keyword">return</span>  low<span class="token punctuation">;</span><span class="token comment">//返回存放枢轴的最终位置</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//快排函数</span>
<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//low和high值要合法			</span>
        <span class="token keyword">int</span> pivotpos<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>	
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>pivotpos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分治递归左半部分	</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>pivotpos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分治递归右半部分</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>时间复杂度</strong>：最好$O(nlog_2n)$ ,最坏$O(n^2)$，实际<font color="#dd0000">$\mathbf{O(nlog_2n)}$</font>，**<font color="#dd0000">不稳定</font>**<br>性能最优<br><strong>特点</strong>：每趟排序排完后，pivot元素一定在最终位置上。所以n趟排序，至少有n个元素在最终位置上<br><img src="/2023/06/23/data-structure/24.png"><br><strong>特殊应用</strong>：<br>找第k大的数<br>1.排序<br>2.不排序。用快排思想找pivot，若pivot在第k个位置就算是找到了。时间复杂度O(n)</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>第i趟，对n-i次关键字进行比较，找到最大&#x2F;最小与第i个元素进行替换<br><strong>跟元素的初始状态无关</strong><br><strong>时间复杂度</strong>：<font color="#dd0000">$\mathbf{O(n^2)}$</font></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color="#dd0000">堆排序</font></h3><p>堆：完全二叉树<br><img src="/2023/06/23/data-structure/25.png"><br>大根堆(用于升序)：根大于子树<br>小根堆：根小于子树<br>以大根堆为例：从下往上，将左右子树中大于根中最大的代替根<br>从第i个元素开始，i&#x3D;n&#x2F;2向下取整<br>大根堆代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//由数组下标高处往低处,从第一个可能需要调整的非叶</span>
    <span class="token comment">//结点开始检查，直到根结点(注意根结点下标不是0是从1开始存储)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token comment">//A是存储堆的数组,k是需要检查的结点下标,len是堆中结点个数</span>
    A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//A[0]暂存这个需要检查的结点值</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//从这个结点的左孩子开始往下比较，若发生交换对交换过的结点继续和其孩子比较</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//若右孩子大一些就只要考虑和右孩子比较</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//若该结点的值大于它较大孩子结点值则不需要交换</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//若这个结点的值小于它较大孩子结点值则将孩子结点值赋值给该结点</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>	
            k<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//i赋值给k也就是从i开始继续往下检查 直到所有结点检查结束	</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//检查到最后k的值就是最后一轮交换过的结点位置下标将该结点换过去		</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>空间复杂度</strong>：堆排序只需要在交换结点的时候需要额外存储空间来辅佐，所以空间复杂度为$O(1)$<br>时间复杂度：<br>堆排序的总时间可以分为<strong>①建堆部分</strong>+<strong>②n-1次向下调整堆</strong><br><strong>①建堆部分</strong>:时间复杂度为$O(n)$<br><strong>②调堆部分</strong>:一次调堆从上至下最坏情况走得路径是从根结点到叶子结点，完全二叉树的高度为$⌈log_2(n+1)⌉$，所以时间复杂度为$O(log_2n)$那么n-1个顶点时间复杂度为$O(nlog_2n)$<br>堆排序的时间复杂度为$O(n)$+$(nlog_2n)$&#x3D;<font color="#dd0000">$\mathbf{O(nlog_2n)}$</font>，**<font color="#dd0000">不稳定</font>**<br>堆建立好后，输出堆顶，用末尾元素代替，然后按照前面的方法进行调整</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始建堆</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>len<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//n-1趟的交换和建堆过程</span>
        <span class="token function">Swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出堆顶元素(和堆底元素交换)</span>
        <span class="token function">AdjustDown</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把剩余的i-1个元素整理成堆</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用于选前n个最大值(用小根堆)<br>堆删除首个元素重新建堆会把尾数换到首位</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>用于外存排序，尤其是数据体积很大，内存放不下<br>二路归并排序<br>n个数先分为⌈n&#x2F;2⌉(向上取整)个组，每组2或1个<br>下方为二路归并排序事例<br><img src="/2023/06/23/data-structure/26.png"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ElemType <span class="token operator">*</span>B<span class="token operator">=</span><span class="token punctuation">(</span>ElemType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//辅助数组</span>
<span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token comment">//表A的两段A[low…mid]和A[mid+1…high]各自有序，将它们合并成一个有序表</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>low<span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将A中所有元素复制到B中</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  
        <span class="token comment">//k是归并之后数组的下标计数器</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//比较B的左右两段中的元素</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将较小值复制到A中</span>
        <span class="token keyword">else</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//若第一个表未检测完,则将剩下部分复制过来</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//若第二个表未检测完,则将剩下部分复制过来</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//从中间划分两个子序列</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对左侧子序列进行递归排序</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对右侧子序列进行递归排序</span>
        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//归并</span>
    <span class="token punctuation">&#125;</span>       
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>空间复杂度</strong>：因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为$O(n)$<br><strong>时间复杂度</strong>：每趟排序的时间复杂度都是$O(n)$所以整个归并排序的时间复杂度为<font color="#dd0000">$\mathbf{O(nlog_2n)}$</font>，**<font color="#dd0000">稳定</font>**</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>链式   不比较、不移动<br><strong>基数排序</strong>(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于<strong>关键字各位的大小进行排序</strong>的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为<strong>最高位优先（MSD）</strong>排序和<strong>最低位优先（LSD）</strong>排序。<br>假如以如下10个数据为例：<br><img src="/2023/06/23/data-structure/27.png"><br><strong>第一趟比“个位”</strong>：<br><img src="/2023/06/23/data-structure/28.png"><br><strong>第二趟比“十位”</strong>：<br><img src="/2023/06/23/data-structure/29.png"><br><strong>第三趟比“百位”</strong>：<br><img src="/2023/06/23/data-structure/30.png"><br>关键字数量为$\mathbf{n}$,关键字的位数为$\mathbf{d}$,比如748 d&#x3D;3，$\mathbf{r}$为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即$\mathbf{r&#x3D;10}$<br><strong>空间复杂度</strong>：需要开辟关键字基的个数个队列，所以空间复杂度为$O(r)$<br><strong>时间复杂度</strong>：需要进行关键字位数d次”分配”和”收集”，一次”分配”需要将n个关键字放进各个队列中，一次”收集”需要将r个桶都收集一遍。所以一次”分配”和一次”收集”时间复杂度为$O(n+r)$。d次就需要<font color="#dd0000">$\mathbf{O(d(n+r))}$</font>的时间复杂度。</p>
<h3 id="排序的比较分析"><a href="#排序的比较分析" class="headerlink" title="排序的比较分析"></a><font color="#dd0000">排序的比较分析</font></h3><font size="2">

<table>
<thead>
<tr>
<th align="center">算法种类</th>
<th align="center">最好</th>
<th align="center">平均</th>
<th align="center">最坏</th>
<th align="center">空间复杂度</th>
<th align="center">是否稳定</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直插</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">$√$</td>
</tr>
<tr>
<td align="center">冒泡</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">$√$</td>
</tr>
<tr>
<td align="center">选择</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">$×$</td>
</tr>
<tr>
<td align="center">希尔</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n^3)$</td>
<td align="center">$O(n^{1.3})$</td>
<td align="center">$O(1)$</td>
<td align="center">$×$</td>
</tr>
<tr>
<td align="center">快排</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(log_2n)$</td>
<td align="center">$×$</td>
</tr>
<tr>
<td align="center">堆排</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">$×$</td>
</tr>
<tr>
<td align="center">二路归并</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(nlog_2n)$</td>
<td align="center">$O(n)$</td>
<td align="center">$√$</td>
</tr>
<tr>
<td align="center">基数</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(d(n+r))$</td>
<td align="center">$O(r)$</td>
<td align="center">$√$</td>
</tr>
<tr>
<td align="center"></td></tr></tbody></table></font>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>


<p><strong>不稳定</strong>：快希选堆<br><strong>时间复杂度</strong>：$O(nlog_2n)$ 快堆归<br><strong>空间复杂度</strong>：$O(log_2n)$ 快；$O(n)$ 归；$O(r)$ 基数<br>注意：$O(n^{1.3})是希尔$$d&#x3D;n&#x2F;2$的步长<br>特殊分类：<br><strong>只能用顺序表</strong>：归并、堆、快排(希尔、折半插入)<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;其余的链式和顺序都可以<br>**时间复杂度与元素初始状态<font color="#dd0000">无关</font>**：基数、选择、归并<br>**比较次数与元素初始状态<font color="#dd0000">无关</font>**：基数、选择<br>**排序趟数与元素初始状态<font color="#dd0000">有关</font>**：快排、冒泡<br>**排序趟数与元素初始状态<font color="#dd0000">无关</font>**：直插、折半、希尔、选择、堆、归并、基数<br><strong>至少确定一个位置</strong>：交换：冒泡、快排；选择：简单选择、堆</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jourser</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Jourser.github.io/2023/06/23/data-structure/">https://Jourser.github.io/2023/06/23/data-structure/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Jourser</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                    <span class="chip bg-color">数据结构</span>
                                </a>
                            
                                <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">笔记</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/06/24/computer-network/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="计算机网络笔记">
                        
                        <span class="card-title">计算机网络笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%90%8E%E7%AB%AF/" class="post-category">
                                    后端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">笔记</span>
                    </a>
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/03/13/vue-problem/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="使用Vue可能遇到的问题（更新中）">
                        
                        <span class="card-title">使用Vue可能遇到的问题（更新中）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">
                        <span class="chip bg-color">问题解决</span>
                    </a>
                    
                    <a href="/tags/vue/">
                        <span class="chip bg-color">vue</span>
                    </a>
                    
                    <a href="/tags/JavaScript/">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/HTML/">
                        <span class="chip bg-color">HTML</span>
                    </a>
                    
                    <a href="/tags/CSS/">
                        <span class="chip bg-color">CSS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('200')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 白米粥のBlog<br />'
            + '文章作者: Jourser<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2025</span>
            
            <a href="/about" target="_blank">Jourser</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
            
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/Jourser" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:863519940@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=863519940" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 863519940" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
