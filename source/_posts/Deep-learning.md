---
title: 深度学习基础笔记
date: 2024-03-13 20:12:39
img:
- /medias/featureimages/15.jpg
mathjax: true
categories: 人工智能
tags:
 - 深度学习
 - 机器学习
 - 神经网络
 - 笔记
---
# 深度学习基础笔记

----
## 深度学习简介
- **深度学习**，是一种基于无监督特征学习和特征层次结构学习的模型，在计算机视觉，语音识别，自然语言处理等领域有着突出的优势。

### 传统机器学习与深度学习
#### 传统机器学习与深度学习对比
|  传统机器学习   | 深度学习  |
|  :-----  | :-----  |
| 对计算机**硬件需求较小**：计算量级别有限，一般不需配用GPU显卡做并行运算  | 对硬件有一定要求：大量数据需进行大量的矩阵运算，**需配用GPU**做并行运算 |
| 适合**小数据量**训练，再增加数据量难以提升性能  | **高维的权重参数**，海量的训练数据下可以获得高性能 |
| 需要将问题逐层分解  | “端到端”的学习 |
| 人工进行特征选择  | 利用算法自动提取特征 |
| 特征可解释性强  | 特征可解释性弱 |
#### 传统机器学习一般流程
<div align="center">
<img src=./Deep-learning/1.png width=70%/>
</div>

- 在深度学习中，特征工程往往由算法自动完成
#### 深度学习介绍
- 深度学习一般指深度神经网络，深度指神经网络的层数（多层）。
<div align="center">
<img src=./Deep-learning/2.png width=100%/>
</div>

### 神经网络
#### 神经网络介绍
- 目前，关于神经网络的定义尚不统一，按美国神经网络学家Hecht Nielsen的观点，神经网络的定义是：“神经网络是由多个非常简单的处理单元彼此按某种方式相互连接而形成的计算机系统，该系统靠其状态对外部输入信息的动态响应来处理信息”。
- 综合神经网络的来源、特点和各种解释，它可简单地表述为：**人工神经网络是一种旨在模仿人脑结构及其功能的信息处理系统**。
- **人工神经网络（简称神经网络）**：是由人工神经元互连组成的网络，它是从微观结构和功能上对人脑的抽象、简化，是模拟人类智能的一条重要途径，反映了人脑功能的若干基本特征，如并行信息处理、学习、联想、模式分类记忆等。

#### 神经网络发展历程
<div align="center">
<img src=./Deep-learning/3.png width=100%/>
</div>

### 单层感知机
#### 单层感知机原理
- 感知机 ( perceptron )是Frank Rosenblatt在1957年所发明的一种最简单的人工神经网络。单层感知机本质上是一个二分类器。
- 输入向量：$X=[x_0,x_1,...x_n]^T$
- 权值：$W=[w_0,w_1,...,w_n]^T$，其中$w_0$称之为**偏置**
- 激活函数：$O=sign(net)=1,net>0/-1,otherwise$
<div align="center">
<img src=./Deep-learning/4.png width=70%/>
</div>

- 上面的感知器，相当于一个分类器，它使用高维$X$向量做输入，在高维空间对输入的样本进行二分类:当$W^TX> 0$时，$O=1$，相当于样本被归类为其中一类。否则，$O = —1$，相当于样本被归类为另一类。这两类的边界在哪里呢?就是$W^TX= 0$，这是一个高维的超平面。
<div align="center">
<img src=./Deep-learning/5.png width=70%/>
</div>



#### 单层感知机所遇障碍 - XOR问题
- 1969年，美国数学家及人工智能先驱Minsky在其著作中证明了感知器本质上是一种线性模型，只能处理线性分类问题，**无法处理非线性数据**。
<div align="center">
<img src=./Deep-learning/6.png width=70%/>
</div>

### 前馈神经网络
#### 前馈神经网络结构原理
<div align="center">
<img src=./Deep-learning/7.png width=70%/>
</div>

- 计算功能的神经元都在隐含层，隐含层中有激活函数，这些激活函数通过计算传递到下一层。同样同一层的神经元之间并不存在相互的联系，层与层之间的信息只沿着一个方向。

#### 解决异或问题
<div align="center">
<img src=./Deep-learning/8.png width=90%/>
</div>

#### 隐藏层数对神经网络的影响
<div align="center">
<img src=./Deep-learning/9.png width=90%/>
</div>

- 隐含层数越多，神经网络的分辨能力越强

----

## 训练法则
### 向前传播
#### 原理
- 输入信号从输入层传输到输出层
- 对于每个神经元︰
  - 计算上层输入的加权平均值: $\theta'=WX +b$
  - 计算激活函数值：$\theta = f(\theta')$
- 最后输出：模型预测值$f(x,\overline{\theta})$
<div align="center">
<img src=./Deep-learning/10.png width=80%/>
</div>

### 梯度下降与损失函数
#### 原理
- 对于多元函数 $o = f(x) = f(x_0,x_1,...,x_n)$ ，其在 $x'= [x_0' ,x_1 ',...,x_n']^T$ 处的梯度为:$$\nabla f(x_0' ,x_1 ',...,x_n')= [\frac{\partial f}{\partial x_0},\frac{\partial f}{\partial x_1},...,\frac{\partial f}{\partial x_n}]^T|X=X'$$
**梯度向量的方向，指向函数增长最快的方向**。因此，负梯度向量$-\nabla f$ ,则指向函数下降最快的方向。
- 在训练深度学习网络的时候，我们要首先要参数化描述目标分类的错误，这就是**损失函数**（误差函数），它反映了感知器目标输出和实际输出之间的误差。最常用的误差函数为**均方误差**：$$E(W)=\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$$ 其中，$d$ 为训练样例，$D$ 为训练样例集，$t_d$ 为目标输出，$o_d$ 为实际输出。
- 梯度下降法的思想是让损失函数沿着负梯度的方向进行搜索，不断迭代更新参数，最终使得损失函数最小化。



#### 损失函数极值
- **目的**：损失函数$E(W)$是定义在权值空间上的函数。我们的目的是搜索使得$E(W)$**最小**的权值向量$W$。
- **限制**：$E(W)=\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$ 的复杂高维曲面，**在数学上，尚没有求极值解有效方法。**
- **解决思路**：负梯度方向是函数下降最快的方向，那我们可以从某个点开始，沿着 $-\nabla E(W)$ 方向一路前行，期望最终可以找到 $E(W)$ 的极小值点，这就是梯度下降法的核心思想。
<div align="center">
<img src=./Deep-learning/11.png width=50%/>
</div>


#### 深度学习中常用的损失函数
- 均方误差：$$E(W)=\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$$
- 交叉熵误差：$$E(W)=\frac{1}{n}\sum_{d\in D}(t_d \ln{o_d}+(1-t_d) \ln({1-o_d}))^2$$
- 交叉嫡误差刻画了两个概率分布之间的距离，是分类问题中使用较多的一种损失函数。
- 一般均方误差更多得用于**回归问题**，而交叉嫡误差更多的用于**分类问题**。

#### 批量梯度下降(BGD)
- 对于训练样例集$D$中的每一个样例记为 $<X,t >$ ，$X$ 是输入值向量，$t$  为目标输出，$o$ 为实际输出，$\eta$ 是学习率。
  - 初始化每个 $w_i$ ，为绝对值较小的随机值
  - 遇到终止条件前，**do**：
    - 初始化每个 $\triangle w_i$ 为零
    - 对于 $D$ 中每个 $<X,t >$，**do**：
        - 将 $X$ 输入此单元，计算输出$o$
        - 对于此单元的每个 $w_i$，**do**：$\triangle w_i+= \eta(t-o) x_i$
    - ·对于此单元的每个 $w$ ,，**do**：$w_i+=\triangle w_i$
- 这个版本的梯度下降算法，实际上并不常用，它的主要问题是：
  - 收敛过程非常慢，因为每次更新权值都需要计算所有的训练样例;


#### 随机梯度下降(SGD)
- 针对原始梯度下降算法的弊端，一个常见的变体称为增量梯度下降( Incremental GradientDescent)，亦即**随机梯度下降**（SGD: Stochastic Gradient Descent ）。其中一种实现称为在线学习( online Learning )，它根据每一个样例来更新梯度：$$\triangle w_i=\eta \sum_{d\in D}(t_d-o_d)x_{id} \Rightarrow \triangle w_i=\eta (t_d-o_d)x_{id}$$
- ONLINE-GRADIENT-DESCENT $(D, \eta)$
  - 初始化每个 $w_i$ 为绝对值较小的随机值。
  - 遇到终止条件前，**do**：
  - 在 $D$ 中随机出一个 $<X, t>$ ，**do**:
    - 将x输入此单元，计算输出 $o$
    - 对于此单元的每个 $w_i$ ， **do**: $w_i += \eta(t-o)x_i$


#### 小批量梯度下降(MBGD)
- 针对上两种梯度下降算法的弊端，提出了一个实际工作中**最常用的梯度下降算法**，即 **Mini-BatchSGD**。它的思想是每次使用一小批固定尺寸（BS: Batch Size）的样例来计算 $\triangle w_i$ ，然后更新权值。
- BATCH-GRADIENT-DESCENT $(D,\eta,BS)$
  - 初始化每个 $w_i$ 为绝对值较小的随机值
  - 遇到终止条件前，**do**:
    - 初始化每个 $\triangle w_i$ 为零
    - 从 $D$ 中下一批(BS个)样例，对这批样例中的每一个 $<X,t >$，**do**:
      - 将 $X$ 输入此单元，计算输出 $o$
      - 对于此单元的每个 $w_i$ ，**do**: $\triangle w_i += \eta(t-o)x_i$
    - 对于此单元的每个 $w_i$ ，**do**: $w_i+=\triangle w_i$
    - 如果已经是最后一批，打乱训练样例的顺序。


### 反向传播算法
#### 原理
- **误差反向传播算法**（Error Back Propagation）是神经网络的重要算法。它使用链式求导法则将输出层的误差反向传回给网络，使神经网络的权重有了较简单的梯度计算实现方法。
- 信号正向传播，误差反向传播
- 对于训练样例集 $D$ 中的每一个样例记为 $<X,t>$ ，$X$ 是输入值向量，$t$ 为目标输出，$o$ 为实际输出，$w$ 为权重系数
- 损失函数：$$E(W)=\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$$

- 步骤:
    - 从最后一层开始，计算误差对于该层节点参数的梯度
    - 基于上一层的梯度值，对当前层参数的梯度值进行计算，重复该步骤，将参数传播至第一层



<div align="center">
<img src=./Deep-learning/12.png width=50%/>
</div>


-----

## 激活函数
### 激活函数介绍
- **激活函数**（Activation functions）对于神经网络模型去学习、理**解非常复杂和非线性的函数**来说具有十分重要的作用，激活函数的存在将**非线性特性**引入到我们的网络中。
- 如果我们不运用激活函数，则输出信号将仅仅是一个简单的线性函数。线性函数的复杂性有限，从数据中学习复杂函数映射的能力更小。
<div align="center">
<img src=./Deep-learning/13.png width=70%/>
</div>

### Sigmoid函数
<div align="center">
<img src=./Deep-learning/14.png width=70%/>
</div>

- 会出现**梯度消失问题**
- **梯度消失问题**：激活函数在某些输入范围内(往往是远离中心点)的导数趋近于零，反向传播中的梯度也会变得非常小，从而导致梯度消失问题

### tanh函数
<div align="center">
<img src=./Deep-learning/15.png width=70%/>
</div>

- 会出现**梯度消失问题**

### Softsign函数
<div align="center">
<img src=./Deep-learning/16.png width=70%/>
</div>

- 会出现**梯度消失问题**，但比起Sigmoid和tanh要好，在一定程度上缓解了梯度消失问题

### ReLU函数
<div align="center">
<img src=./Deep-learning/17.png width=70%/>
</div>

- **优点**：**计算量小**，同时进行了**特征选择**，也减缓了梯度消失问题
- **缺点**：由于 $x=0$ 这个拐角，在分析某些问题时，不能将数据蕴含的一些信息表达出来，尤其是**回归问题**，无法更好地预测

### Softplus函数
<div align="center">
<img src=./Deep-learning/18.png width=70%/>
</div>

- 对ReLU函数的更新，计算量有所增加，但可更好地解决回归问题

### Softmax函数
- Softmax函数体：$$\sigma(z)_j=\frac{e^{Z_j}}{\sum_k e^{Z_k}}$$
- Softmax函数的功能就是将一个 $K$ 维的任意实数向量映射成另一个 $K$ 维的实数向量，其中向量中的每个元素取值都介于 $(0，1)$ 之间。新的向量所有维度模长之和为1。
- Softmax函数经常用作**多分类任务**的输出层。

-----

## 正则化
### 正则化介绍
#### 基本介绍
- 正则化是机器学习中非常重要并且非常有效的减少泛化误差的技术，特别是在深度学习模型中，由于其模型参数非常多非常容易产生过拟合。因此研究者也提出很多有效的技术防止过拟合，比较常用的技术包括:
  - 参数添加约束，例如$L_1$、$L_2$范数等。
  - 训练集合扩充，例如添加噪声、数据变换等。
  - Dropout
  - 提前停止

#### 参数惩罚
- 许多正则化方法通过对目标函数 $J$ 添加一个参数惩罚 $\Omega(\theta)$ ,限制模型的学习能力。我们将正则化后的目标函数记为 $\tilde{J}$。$$\tilde{J}(\theta;X,y)=J(\theta;X,y)+\alpha\Omega(\theta)$$ 其中 $\alpha \in[0, \infty)$ 是权衡范数惩罚项 $\Omega$ 和标准目标函数 $J(X;\theta)$ 相对贡献的超参数。将 $\alpha$ 设为0表示没有正则化。 $\alpha$ 越大，对应正则化惩罚越大。


### $L_1$与$L_2$正则
#### $L_1$正则
- 对模型参数添加 $L_1$ 范数约束，即：$$\tilde{J}(w;X,y)=J(w;X,y)+\alpha ||w||_1$$，
- 如果通过梯度方法进行求解时，参数梯度为：$$\nabla \tilde{J}(w)=\propto sign(w)+\nabla J(w)$$

#### $L_2$正则
- 参数约束添加 $L_2$ 范数惩罚项，该技术**防止过拟合** $$\tilde{J}(w;X,y)=J(w;X,y)+\frac{1}{2}\alpha ||w||^2$$，
- 通过最优化技术，例如梯度相关方法可以很快推导出，参数优化方式为：$$w = (1 - \varepsilon \alpha)\omega - \varepsilon \nabla J(w)$$  其中 $\varepsilon$ 为学习率，相对于正常的梯度优化公式，对参数乘上一个缩减因子。

#### $L_1$ vs $L_2$
- Lz与 $L_1$ 的主要区别如下:
  - 通过上面的分析，$L_1$ 相对于 $L_2$ 能够产生 ，即当 $L_1$ 正则在参数 $w$ 比较小的情况下，能够直接缩减至0，因此可以起到特征选择的作用。
  - 如果从概率角度进行分析，很多范数约束相当于对参数添加先验分布，其中 $L_2$范数相当于参数服从**高斯先验分布**; $L_1$ 范数相当于**拉普拉斯分布**。
<div align="center">
<img src=./Deep-learning/19.png width=70%/>
</div>


### 数据集合扩充
- 防止过拟合最有效的方法是增加训练集合，**训练集合越大过拟合概率越小**。数据集合扩充是一个省时有效的方法，但是在不同领域方法不太通用
  - 在目标识别领域常用的方法是将图片进行旋转、缩放等（图片变换的前提是通过变换不能改变图片所属类别，例如手写数字识别，类别6和9进行旋转后容易改变类目）。
  - 语音识别中对输入数据添加随机噪声。
  - NLP中常用思路是进行近义词替换。
  - 噪声注入，可以对输入添加噪声，也可以对隐藏层或者输出层添加噪声。例如对于softmax分类问题可以通过Label Smoothing技术添加噪声，对于类目0-1添加噪声，则对应概率变成 $\frac{\varepsilon}{k}$，$1-\frac{k-1}{k} \varepsilon$

### Dropout
- Dropout是一类通用并且计算简洁的正则化方法，在2014年被提出后广泛的使用。简单的说，Dropout在训练过程中，随机的丢弃一部分输入，此时丢弃部分对应的参数不会更新。相当于Dropout是一个集成方法，将所有子网络结果进行合并，如图通过随机丢弃输入可以得到各种子网络。如图：
<div align="center">
<img src=./Deep-learning/20.png width=60%/>
</div>

- Dropout工作流程：
<div align="center">
<img src=./Deep-learning/21.png width=100%/>
</div>

- **Dropout的作用**（为什么可以解决过拟合）：
  - 取平均的作用。
  - 减少神经元之间复杂的共适应关系。
  - Dropout类似于性别在生物进化中的角色。

### 提前停止训练
- 在训练过程中，插入对验证集数据的测试。当发现验证集数据的Loss上升时，提前停止训练。
<div align="center">
<img src=./Deep-learning/22.png width=60%/>
</div>

### 随机池化(卷积网络)
#### 池化的意义
- 既对数据进行降采样操作，又可以用 $p$ 范数作非线性映射的“卷积”:$$||A||_p=(\sum_{i=1} ^m \sum_{j=1} ^n |a_{ij}|^p)^{\frac{1}{p}}$$
- 具体作用为：
  - 特征不变性：使模型更关注包含一定的自由度，能容忍特征微小的位移;
  - 特征降维：降采样使得后续操作的计算量得到减少
  - 一定程度防止过拟合。
- 池化层的常见操作∶最大值池化，均值池化，随机池化，中值池化，组合池化等
#### 最大池化和均值池化
- **最大池化**：最大值池化的优点在于它能学习到图像的边缘和纹理结构。
<div align="center">
<img src=./Deep-learning/23.png width=60%/>
</div>

- **均值池化**：均值池化的优点在于可以减小估计均值的偏移，提升模型的鲁棒性。
<div align="center">
<img src=./Deep-learning/24.png width=60%/>
</div>

#### 随机池化
- **随机池化**：按一定概率随机选取其中一个元素，介于平均池化和最大池化之间，并且受dropout启发，具有更好的正则化效果；可以看作是，在输入图片的许多副本（有一些小的局部变形）上进行标准的最大池化操作。
<div align="center">
<img src=./Deep-learning/25.png width=70%/>
</div>

----

## 优化器
### 优化器基本介绍
- 在梯度下降算法中，有各种不同的改进版本。在面向对象的语言实现中，往往把不同的梯度下降算法封装成一个对象，称为**优化器**。
- 算法改进的目的，包括但不限于:
  - 加快算法收敛速度;
  - 尽量避过或冲过局部极值;
  - 减小手工参数的设置难度，主要是Learning Rate ( LR)。
- 常见的优化器如︰普通GD优化器、动量优化器、Nesterov、**Adagrad**、Adadelta、**RMSprop**、**Adam**、AdaMax、Nadam。

### 动量优化器
#### 动量优化器原理
- 一个最基本的改进，是为 $\Delta w_{ji}(n)$ 增加动量项。记第 $n$ 次迭代时的权值修正量为 $\Delta w_{ji}(n)$ ，则权值修正法则变为：$$\Delta w_{ji}(n) = \eta \delta_j x_{ji}+\alpha \Delta w_{ji}(n-1)$$
其中，$\delta_j$ 为惯性的大小，$0\leq a<1$ 是一个常数，称为**动量**(Momentum) 。$\alpha\Delta w_{ji}(n-1)$ 称为动量项。
- 想象一个小球，从一个随机的点开始，沿着误差曲面滚下。动量项的引入相当于赋予了小球惯性:
<div align="center">
<img src=./Deep-learning/26.png width=60%/>
</div>

#### 动量优化器优缺点
- 动量优化器的优点是:
  - 增加了梯度修正方向的稳定性，减小突变。
  - 在梯度方向比较稳定的区域，小球滚动会越来越快（当然，因为 $\alpha <1$，其有一个速度上限），这有助于小球快速冲过平坦区域，加快收敛。
  - 带有惯性的小球更容易滚过一些狭窄的局部极值。
- 动量优化器的缺点是:
  - 学习率 $\eta$ 以及动量 $\alpha$ 仍需手动设置，这往往需要较多的实验来确定合适的值

### Adagrad优化器
#### Adagrad优化器原理
- 随机梯度下降算法(SGD )、小批量梯度下降算法（MBGD）、动量优化器的共同特点是：对于每一个参数都用相同的学习率进行更新。
- Adagrad的思想则是应该为不同的参数设置不同的学习率
$$g_t \leftarrow + \frac{1}{m} \nabla_\theta \sum_i L(f(x_i;w),y_i)  ，计算梯度$$ $$r \leftarrow r+g_t^2，累积平方梯度$$ $$\Delta w=-\frac{\eta}{\varepsilon +\sqrt{r}}g_t，计算更新$$ $$w \leftarrow w+ \Delta w，应用更新$$
  - $g_t$ 为第 $t$ 次的梯度，$r$ 为梯度累积变量，$r$ 的初始值为 $0$，会一直递增。$\eta$ 为全局学习率，需要手动设置。$\varepsilon$ 为小常数，为了数值稳定大约设置为 $10^{-7}$。

#### Adagrad优化器优缺点
- 从Adagrad优化算法中可以看出，随着算法不断迭代，$r$ 会越来越大，整体的学习率会越来越小。这样做的原因是随着更新次数的增大，我们希望学习率越来越慢。因为我们认为在学习率的最初阶段，我们距离损失函数最优解还很远，随着更新次数的增加，越来越接近最优解，所以学习率也随之变慢。
- 优点：
  - 学习率自动更新，随着更新次数增加，学习率随之变慢。
- 缺点：
  - 分母会不断累积，这样学习率就会后所并最终变得非常小（可能会提前停止），算法会失去效用。

### RMSprop优化器
- RMSprop优化器是一种改进的Adagrad优化器，通过引入一个衰减系数，让 $r$ 每回合都衰减一定的比例。
- RMSprop优化器很好的解决了Adagrad优化器过早结束的问题，很合适处理**非平稳目标**，对于**RNN网络**效果很好。
$$g_t \leftarrow + \frac{1}{m} \nabla_\theta \sum_i L(f(x_i;w),y_i)  ，计算梯度$$ $$r \leftarrow \beta r+(1-\beta)g_t^2，累积平方梯度$$ $$\Delta w=-\frac{\eta}{\varepsilon +\sqrt{r}}g_t，计算更新$$ $$w \leftarrow w+ \Delta w，应用更新$$
  - $g_t$ 为第 $t$ 次的梯度，$r$ 为梯度累积变量，$r$ 的初始值为 $0$，**未必递增，通过参数调节**。$\beta$ 为**衰减因子**，$\eta$ 为全局学习率，需要手动设置。$\varepsilon$ 为小常数，为了数值稳定大约设置为 $10^{-7}$。
### Adam优化器
- Adam ( Adaptive Moment Estimation )︰是从Adagrad、Adadelta上发展而来，Adam为每个待训练的变量，维护了两个附加的变量 $m_t$ 和 $v_t$：$$m_t=\beta_1m_{t-1}+(1-\beta_1)g_t$$ $$v_t=\beta_2v_{t-1}+(1-\beta_2)g_t^2$$
- 其中 $t$ 表示第 $t$ 次迭代，$g_t$ 是本次计算出的梯度，从形式上来看 $m_t$ 和 $v_t$ 分别是梯度和梯度平方的移动均值。从统计意义上看，$m_t$ 和 $v_t$ 是梯度的一阶矩(均值）和二阶矩（非中心方差)的估计，因此而得名。
- 如果以 $0$ 向量来初始化 $m_t$ 和 $v_t$ ，在开始的一些迭代，尤其是当 $\beta_1$ 和 $\beta_2$ ，接近于 $1$ 的时候， $m_t$ 和 $v_t$ 将非常接近于 $0$，为了解决这个问题，我们实际使用的是 $\widehat{m_t}$ 和 $\widehat{v_t}$：$$\widehat{m_t}=\frac{m_t}{1-\beta_1^t}$$ $$\widehat{v_t}=\frac{v_t}{1-\beta_2^t}$$
- 而Adam的权值更新法则是：$$w_{t+1}=w_t-\frac{\eta}{\sqrt{\widehat{v_t}}+\epsilon}\widehat{m_t}$$
- 虽然上面的法则中依然存在人工设置 $\eta$ 、$\beta_1$ 、$\beta_2$ ，但他们的设置难度大大降低。根据实验，一般取 $\beta_1=0.9$，$\beta_2=0.999$，$\epsilon = 10^{-8}$，$\eta=0.001$。在实际使用过程中，Adam将迅速收敛，当收敛到饱和的时候，可以适当降低，一般降低几次之后，即会收敛到满意的（局部）极值。其他参数一般不必调整。

### 优化器性能比较
<div align="center">
<img src=./Deep-learning/27.png width=100%/>
</div>

-----

## 神经网络类型
### 卷积神经网络
#### 卷积神经网络基本介绍
- **卷积神经网络**(Convolutional Neural Network,**CNN**)是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于**图像处理**有出色表现。它包括**卷积层**(convolutional layer)，**池化层**(pooling layer)和**全连接层**(fully_connected layer)。
- 20世纪60年代，Hubel和wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络(ConvolutionalNeural Networks-简称CNN)。
- 现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。


#### 卷积神经网络核心思想
- **局部感知**：一般认为，人对外界的认知是从局部到全局的，而**图像的空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱**。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。
- **参数共享**：对输入的图片，用一个或者多个卷积核扫描照片，卷积核自带的参数就是权重，在同一个卷积核扫描的图层当中，每个卷积核使用同样的参数进行加权计算。**权值共享意味着每一个卷积核在遍历整个图像的时候，卷积核的参数是固定不变的。**

#### 卷积神经网络架构
<div align="center">
<img src=./Deep-learning/28.png width=100%/>
</div>

#### 单卷积核计算
- **卷积计算描述**
<div align="center">
<img src=./Deep-learning/29.png width=100%/>
</div>

<div align="center">
<img src=./Deep-learning/30.png width=60%/>
</div>

#### 卷积层
- 卷积神经网络的基本结构，就是多通道卷积（由多个单卷积构成)。上一层的输出（或者第一层的原始图像），作为本层的输入，然后和本层的卷积核卷积，作为本层输出。而各层的卷积核，就是要学习的权值。和FCN类似，卷积完成后，输入下一层之前，也需要经过偏置和通过激活函数进行激活。
<div align="center">
<img src=./Deep-learning/31.png width=90%/>
</div>

#### 池化层
- 池化(Pooling)，它合并了附近的单元，减小了下层输入的尺寸，起到**降维**的作用。常用的池化有最大池化(Max Pooling)和平均池化(Average Pooling)，顾名思义，最大池化选择一小片正方形区域中最大的那个值作为这片小区域的代表，而平均池化则使用这篇小区域的均值代表之。这片小区域的边长为池化窗口尺寸。下图演示了池化窗口尺寸为2的一般最大池化操作。
<div align="center">
<img src=./Deep-learning/32.png width=90%/>
</div>



#### 全连接层
- 全连接层实质上就是一个分类器，将前面经过卷积层与池化层所提取的特征，拉直后放到全连接层中，输出结果并分类。
- 通常我们使用Softmax函数作为最后全连接输出层的激活函数，把所有局部特征结合变成全局特征，用来计算最后每一类的得分。
$$\sigma(z)_j=\frac{e^{Z_j}}{\sum_k e^{Z_k}}$$

### 循环神经网络
#### 循环神经网络基本介绍
- **循环神经网络**（Recurrent neural networks，简称**RNN**）是一种通过隐藏层节点周期性的连接，来**捕捉序列化数据中动态信息的神经网络**，可以对序列化的数据进行分类。
- 和其他前向神经网络不同，RNN可以保存一种**上下文**的状态，甚至能够在任意长的上下文窗口中存储、学习、表达相关信息，而且不再局限于传统神经网络在空间上的边界，可以在**时间序列上有延拓**，直观上讲，就是本时间的隐藏层和下一时刻的隐藏层之间的节点间有边。
- RNN广泛应用在和序列有关的场景，如如一帧帧图像组成的视频，一个个片段组成的音频，和一个个词汇组成的句子。

#### 循环神经网络架构
<div align="center">
<img src=./Deep-learning/33.png width=90%/>
</div>

<div align="center">
<img src=./Deep-learning/34.png width=90%/>
</div>

#### 循环神经网络类型
<div align="center">
<img src=./Deep-learning/35.png width=90%/>
</div>

#### 时序反向传播(BPTT)
- 时序反向传播(BPTT):
  - 传统反向传播(BP)在时间序列上的拓展
  - t 时刻的梯度是前 t -1 时刻所有梯度的累积
  - 时间越长，梯度消失越明显
- BPTT的三个步骤:
  - 前向计算每个神经元的输出值
  - 反向计算每个神经元的误差值 $\delta_j$
  - 计算每个权重的梯度
- 最后使用随机梯度下降算法更新权重。

#### 循环神经网络问题
- 标准RNN结构解决了信息记忆的问题，但是对**长时间记忆的信息会衰减**。
- 很多任务需要保存长时间的记忆信息，如推理小说开头埋下的伏笔，可能到结尾时候才解答。
- 在记忆单元容量有限的情况下，RNN会丢失长时间间隔的信息。
- 我们希望记忆单元能够选择性记住重点信息。

#### 长短记忆性网络
<div align="center">
<img src=./Deep-learning/36.png width=90%/>
</div>

##### Gated Recurrent Unit ( GRU )
<div align="center">
<img src=./Deep-learning/37.png width=90%/>
</div>

### 生成对抗网络
#### 生成对抗网络基本介绍
- 生成对抗网络(Generative Adversarial Nets)是一种**框架**，通过对抗过程，通过训练生成器G和判别器D。两者进行的博弈，最终使判别器无法区分样本是来自生成器伪造的样本还是真实样本。训练GAN框架采用成熟的BP算法。
 1. 生成器G：输入“噪声”z（z服从一个人为选取的先验概率分布，如均匀分布、高斯分布等）。采用多层感知机的网络结构，用最大似然估计(MLP)的参数来表示可导映射G(z)，将输入空间映射到样本空间。
 2. 判别器D：输入为真实样本x和伪造样本G(z)，并分别带有标签real和fake。判别器网络可以用带有参数多层感知机。输出为判别样本是否为真实样本数据的概率D(G(z))。
- 生成对抗网络可应用于**图像生成**、**语义分割**、**文字生成**、**数据增强**、**聊天机器人和信息检索**，排序等场景。

#### 生成对抗网络架构
- 生成器( Generator)/判别器( Discriminator )
<div align="center">
<img src=./Deep-learning/38.png width=90%/>
</div>

#### 生成模型与判别模型
<div align="center">
<img src=./Deep-learning/39.png width=100%/>
</div>

#### 生成对抗网络训练法则
- 优化目标：
  -  价值函数(Value Function) $$min_{G} max_{D}V (D,G)=E_{x\sim p_{data}(x)}[logD(x)]+E_{z\sim p_{z}(z)}[log(1-D(G(z)))]$$
  - 训练初期，当 $G$ 的生成效果很差时，$D$ 会以高置信度来判别生成样本为假，因为它们与训练数据明显不同此时，$log(1-D(G(z)))$ 饱和（即梯度为 $0$，无法迭代）。因此我们选择只通过最小化 $[-log(D(G(z)))]$ 来训练 $G$。


------

## 深度学习的常见问题
### 数据不平衡问题
- **问题描述**：在分类任务的数据集中，各个类别的样本数目不均衡，出现巨大的差异，预测的类别里有一个或者多个类别的样本量非常少。
- 比如：图像识别实验中，在4251个训练图片中，有超过2000个类别中只有一张图片。还有一些类中有2-5个图片。
- 导致问题:
  - 对于不平衡类别，我们不能得到实时的最优结果，因为模型/算法从来没有充分地考察隐含类。
  - 它对验证和测试样本的获取造成了一个问题，因为在一些类观测极少的情况下，很难在类中有代表性。

- **解决办法**：
  - 随机欠采样
    - 删除样本中多的样本
    - 优点：运行或训练模型的时间比较少，减少存储
    - 缺点：一些有潜在价值的信息可能被删除，存在偏差，导致结果不精确
  - 随机过采样
    - 拷贝样本
    - 优点：不会导致偏差，结果要优于欠采样
    - 缺点：加大过拟合的可能性
  - 合成采样
    - 提取样本
    - 合成样本      
    - 优点：缓解过拟合问题，也不会导致有价值的信息被删除
    - 缺点：类重叠性增加，引入额外的噪音，导致模型效果差，不适用于高维数据

### 梯度消失问题
- **梯度消失**：当网络层数越多时，进行反向传播求导值越小，导致梯度消失。
- **梯度爆炸**：当网络层数越多时，进行反向传播求导值越大，导致梯度爆炸。
- 导致原因：$$y_i=\sigma(z_i)=\sigma (w_ix_i+b_i)，其中\sigma为sigmoid函数$$
<div align="center">
<img src=./Deep-learning/40.png width=60%/>
</div>

- $\sigma'(x)$ 的最大值为 $\frac{1}{4}$
<div align="center">
<img src=./Deep-learning/41.png width=65%/>
</div>

- 而网络权值 $|w|$ 通常都小于 $1$ ，因此$|\sigma'(z)w|≤\frac{1}{4}$，因此对于上面的链式求导，层数越多，求导结果 $\frac{\partial C}{\partial b_1}$ 越小，因而导致梯度消失的情况出现。
- 当网络权值 $|w|$ 比较大时，导致 $|\sigma'(z)w| >1$，出现梯度爆炸。
- **解决方法**：梯度剪切、正则、ReLU激活函数、LSTM神经网络等。


### 过拟合问题
- **问题描述**：模型在训练集表现优异，但在测试集上表现较差。
- 根本原因：特征维度过多，模型假设过于复杂，参数过多，训练数据过少，噪声过多，导致拟合的函数完美的预测训练集，但对新数据的测试集预测结果差。过度的拟合了训练数据，而没有考虑到泛化能力。
- **解决方法**:
  1. 数据增强;
  2. 正则化，降低参数值;
  3. 限制训练时间;
  4. Dropout。
