<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FPGA学习笔记之IP核 FIFO</title>
      <link href="/2024/06/24/fifo/"/>
      <url>/2024/06/24/fifo/</url>
      
        <content type="html"><![CDATA[<h1 id="IP核之-FIFO"><a href="#IP核之-FIFO" class="headerlink" title="IP核之 FIFO"></a>IP核之 FIFO</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>FIFO</strong>（<strong>First In First Out</strong>，即<strong>先入先出</strong>），是一种数据缓存器，用来实现数据先入先出的读写方式。在FPGA 或者 ASIC 中使用到的 FIFO 一般指的是对数据的存储具有先入先出特性的缓存器，常被用于多比特数据跨时钟域的转换、读写数据带宽不同步等场合。</li></ul><h2 id="何为-FIFO"><a href="#何为-FIFO" class="headerlink" title="何为 FIFO"></a>何为 FIFO</h2><h3 id="FIFO与RAM的区别"><a href="#FIFO与RAM的区别" class="headerlink" title="FIFO与RAM的区别"></a>FIFO与RAM的区别</h3><ul><li>FIFO 本质上是由 RAM 加读写控制逻辑构成的一种先进先出的数据缓冲器，其与普通存储器 RAM 的<br>区别在于 FIFO 没有外部读写地址线，使用起来非常简单，但 FIFO 只能顺序写入数据，并按顺序读出数据，其数据地址由内部读写指针自动加 1 完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址，不过也正是因为这个特性，使得 FIFO 在使用时并不存在像 RAM 那样的读写冲突问题。</li></ul><h3 id="FIFO-分类"><a href="#FIFO-分类" class="headerlink" title="FIFO 分类"></a>FIFO 分类</h3><ul><li>根据 FIFO 工作的时钟域，可以将 FIFO 分为<strong>同步 FIFO</strong> 和<strong>异步 FIFO</strong>。</li><li><strong>同步 FIFO</strong> 是指读时钟和写时钟为同一个时钟，在时钟沿来临时同时发生读写操作，常用于两边数据处理带宽不一致的临时缓冲。</li><li><strong>异步FIFO</strong> 是指读写时钟不一致，读写时钟是互相独立的，一般用于数据信号跨时钟阈处理。 <div align="center"><img src="/2024/06/24/fifo/1.png" width="80%/"></div></li></ul><h3 id="FIFO-常见参数"><a href="#FIFO-常见参数" class="headerlink" title="FIFO 常见参数"></a>FIFO 常见参数</h3><ul><li><p>对于 FIFO 我们还需要了解一些常见参数： </p><ol><li>FIFO 的宽度：FIFO 一次读写操作的数据位宽 N。</li><li>FIFO 的深度：FIFO 可以存储多少个宽度为 N 位的数据。 </li><li>将空标志：almost_empty，FIFO 即将被读空。 </li><li>空标志：empty，FIFO 已空时由 FIFO 的状态电路送出的一个信号，以阻止 FIFO 的读操作继续从FIFO 中读出数据而造成无效数据的读出。 </li><li>将满标志：almost_full，FIFO 即将被写满。 </li><li>满标志：full，FIFO 已满时由 FIFO 的状态电路送出的一个信号，以阻止 FIFO 的写操作继续向FIFO 中写数据而造成溢出。 </li><li>写时钟：写 FIFO 时所遵循的时钟，在每个时钟的上升沿触发。 </li><li>读时钟：读 FIFO 时所遵循的时钟，在每个时钟的上升沿触发。 </li><li>可配置满阈值：影响可配置满信号于何时有效，其可配置范围一般为 3~写深度-3。</li><li>可配置满信号：prog_full，表示 FIFO 中存储的数据量达到可配置满阈值中配置的数值。 </li><li>可配置空阈值：影响可配置空信号于何时有效，其可配置范围一般为 2~读深度-3。 </li><li>可配置空信号：prog_empty，表示 FIFO 中剩余的数据量已经减少到可配置空阈值中配置的数值。</li></ol></li><li><p>注意：</p><ol><li><code>almost_empty</code>和<code>almost_full</code>这两个信号分别被看作<code>empty</code>和<code>full</code>的警告信号，他们相对于真正的空（empty）和满（full）都会提前一个时钟周期拉高。 </li><li>FIFO 中，先写入的数据被置于高位，后写入的数据被置于低位，由于其先入先出的特性，所以读出的数据也是高位在前，低位在后。这一点在读写数据位宽不对等时尤为重要，例如我们写数据位宽为8，读数据位宽为 2，当写入的数据为 11000111 时，读出的数据依次为 11、00、01、11。如下图所示：</li></ol>  <div align="center">  <img src="/2024/06/24/fifo/2.png" width="70%/">  </div><ul><li>读位宽大于写位宽时，原理是相同的，如下图所示：</li></ul>  <div align="center">  <img src="/2024/06/24/fifo/3.png" width="70%/">  </div></li></ul><h2 id="FIFO-设计"><a href="#FIFO-设计" class="headerlink" title="FIFO 设计"></a>FIFO 设计</h2><h3 id="FIFO-基础知识"><a href="#FIFO-基础知识" class="headerlink" title="FIFO 基础知识"></a>FIFO 基础知识</h3><ul><li><p>FIFO Generato IP 核（FIFO 发生器）其信号框图</p> <div align="center"> <img src="/2024/06/24/fifo/4.png" width="90%/"> </div><ul><li>PS：上图中<u><em>黑色箭头</em></u>表示此信号为<strong>必要信号</strong>；<u><em>蓝色箭头</em></u>表示此信号为<strong>可选信号</strong>；<u><em>灰色箭头</em></u>表示此信号为可选的<strong>边带信号</strong>。 </li><li>从图中我们可以了解到：<ul><li>当被配置为<strong>同步 FIFO</strong> 时，只使用 <code>wr_clk</code>，所有的输入输出信号都同步于<code>wr_clk</code> 信号。</li><li>当被配置为<strong>异步 FIFO</strong>时，写端口和读端口分别有独立的时钟，所有与写相关的信号都是同步于写时钟 <code>wr_clk</code>，所有与读相关的信号都是同步于读时钟 <code>rd_clk</code>。</li></ul></li></ul></li><li><p>各常用端口的功能描述如下：</p>  <div align="center">  <img src="/2024/06/24/fifo/5.png" width="100%/">  </div></li><li><p>一个典型的写操作时序如下图所示： </p>  <div align="center">  <img src="/2024/06/24/fifo/27.png" width="80%/">  </div><ul><li>当 <code>wr_en</code>（写使能）信号使能时，会在 <code>wr_clk</code>（写时钟）的下一个上升沿上发生写操作，由于 FIFO 未满，因此 <code>wr_ack</code>（写应答）信号处于有效状态，表示写入操作成功。当只能再执行一次写操作时，<code>almost_full</code>（将满）信号会被拉高，此时若再进行一次写操作，<code>full</code>（满）信号就会被拉高，表示 FIFO 已被写满，在有数据被读出前，无法再写入数据了。如果在 <code>full</code> 信号拉高后执意要进行写操作，<code>wr_ack</code> 就会被拉低，表示此次数据写入失败，同时 <code>overflow</code>（满溢出）信号就会被拉高，表示 FIFO 存在溢出现象。</li></ul></li><li><p>一个典型的读操作时序如下图所示： </p>  <div align="center">  <img src="/2024/06/24/fifo/28.png" width="80%/">  </div><ul><li>只要 FIFO 中存有数据，<code>empty</code>（空）信号就会一直为低电平，表明 FIFO 中有数据可以进行读取。当<code>rd_en</code>（读使能）信号使能时，会在 <code>rd_clk</code>（读时钟）的下一个上升沿上发生读操作，FIFO 会在 <code>dout</code>（数据输出线）上输出数据，并拉高 <code>valid</code>（读有效）信号，表示读操作成功。当 FIFO 中还剩最后一个数据时，<code>almost_empty</code>（将空）信号会被拉高，此时若再进行一次读操作，<code>empty</code>（空）信号就会被拉高，表示FIFO 已被读空，在 FIFO 中有存储数据前，读请求将被忽视。如果在 <code>empty</code> 信号拉高后执意要进行读操作，<code>valid</code> 就会被拉低，表示此次数据读出失败，同时 <code>underflow</code>（空溢出）信号就会被拉高，表示 FIFO 中已经没有可被读取的数据了。</li></ul></li></ul><h3 id="FIFO-设计思路"><a href="#FIFO-设计思路" class="headerlink" title="FIFO 设计思路"></a>FIFO 设计思路</h3><ul><li>本文的实验任务是使用 Vivado 生成一个<strong>异步 FIFO</strong>，并实现以下功能：<ul><li>当 FIFO 为空时，向 FIFO 中写入数据，直至将 FIFO 写满后停止写操作；</li><li>当 FIFO 为满时，从 FIFO 中读出数据，直到 FIFO 被读空后停止读操作</li></ul></li></ul><h4 id="顶层模块设计"><a href="#顶层模块设计" class="headerlink" title="顶层模块设计"></a>顶层模块设计</h4><ul><li><strong>顶层模块设计</strong>：本文设计的是异步 FIFO，因此需要一个 MMCM IP 核来输出 50MHz 的写时钟和 100MHz 的读时钟（当然输出其它频率的时钟也是可以的）；然后我们还需要一个<strong>写模块</strong><code>fifo_wr</code>和一个<strong>读模块</strong><code>fifo_rd</code>。写模块通过 FIFO 的状态来判断是否给出写请求信号和写数据，读模块通过 FIFO的状态来判断是否给出读请求信号，并接收从 FIFO 中读出的数据；系统时钟和系统复位是一个完整的工程中必不可少的输入端口信号，这里就不再多讲了。</li><li>经过上述分析可以得一个大致的模块框图，如下图所示：    <div align="center"><img src="/2024/06/24/fifo/6.png" width="50%/"></div></li></ul><h4 id="写模块设计"><a href="#写模块设计" class="headerlink" title="写模块设计"></a>写模块设计</h4><ul><li><p><strong>写模块设计</strong>：在 FIFO 写模块中，我们的输入信号主要有<strong>系统时钟信号</strong>（写时钟域的时钟）、<strong>系统复位信号</strong>；因为 FIFO 的写操作需要在 FIFO 完成复位后进行，所以我们还需要输入<strong>写复位忙信号</strong><code>wr_rst_busy</code>来判断 FIFO 是否结束了复位状态。实验任务中我们提到了 FIFO 为空时进行写操作，因此还需要引入一个空相关的信号，这里我们引入的是 <strong>空信号</strong><code>empty</code>；实验任务中我们还提到了写满了要停止写操作，所以这里我们引入了 <strong>将满信号</strong><code>almost_full</code>，因为将满信号表示 FIFO 还能再进行最后一次写操作，使用这个信号的话我们正好可以在写入最后一次数据后关闭写使能，当然引入<strong>满信号</strong><code>full</code>也是可以，区别只是在于这么做会在写使能关断前执行一次无效的写操作。输出信号有控制写 FIFO 所需的 <strong>写端口使能</strong><code>fifo_wr_en</code>和 <strong>写数据</strong><code>fifo_wr_data</code>这两个信号。</p></li><li><p>经过上述分析可以得一个大致的模块框图，如下图所示： </p><div align="center"><img src="/2024/06/24/fifo/7.png" width="50%/"></div></li><li><p>模块端口与功能描述如下表所示：</p><div align="center"><img src="/2024/06/24/fifo/8.png" width="80%/"></div></li></ul><h4 id="读模块设计"><a href="#读模块设计" class="headerlink" title="读模块设计"></a>读模块设计</h4><ul><li><p><strong>读模块设计</strong>：在 FIFO 读模块中，我们的输入信号主要有<strong>系统时钟信号</strong>（读时钟域的时钟）、<strong>系统复位信号</strong>；因为 FIFO 的读操作需要在 FIFO 完成复位后进行，所以我们还需要输入<strong>读复位忙信号</strong><code>rd_rst_busy</code>来判断 FIFO 是否结束了复位状态；实验任务中我们提到了 FIFO 为满时进行读操作，因此还需要引入一个满相关的信号，这里我们引入的是 <strong>满信号</strong><code>full</code>；实验任务中我们还提到了读空了要停止读操作，所以这里我们引入了 <strong>将空信号</strong><code>almost_empty</code>，因为将空信号表示 FIFO 还能再进行最后一次读操作，使用这个信号的话我们正好可以在读出最后一个数据后关闭读使能，当然引入<strong>空信号</strong><code>empty</code>也是可以，区别只是在于这么做会在读使能关断前执行一次无效的读操作。输出信号仅有控制写 FIFO 所需的 <strong>读端口使能信号</strong><code>fifo_rd_en</code>。</p></li><li><p>经过上述分析可以得一个大致的模块框图，如下图所示：</p><div align="center"><img src="/2024/06/24/fifo/9.png" width="50%/"></div></li><li><p>模块端口与功能描述如下表所示：</p><div align="center"><img src="/2024/06/24/fifo/10.png" width="80%/"></div></li></ul><h3 id="FIFO-配置实验步骤"><a href="#FIFO-配置实验步骤" class="headerlink" title="FIFO 配置实验步骤"></a>FIFO 配置实验步骤</h3><h4 id="一、创建工程"><a href="#一、创建工程" class="headerlink" title="一、创建工程"></a>一、创建工程</h4><ol><li>创建一个名为<code>ip_fifo</code>的空白工程，然后点击 Vivado 软件左侧<code>Flow Navigator</code>栏中的<code>IP Catalog</code>，如下图所示： <div align="center"><img src="/2024/06/24/fifo/4.png" width="40%/"></div></li></ol><h4 id="二、搜索创建-BMG-IP核"><a href="#二、搜索创建-BMG-IP核" class="headerlink" title="二、搜索创建 BMG IP核"></a>二、搜索创建 BMG IP核</h4><ol start="2"><li>在<code>IP Catalog</code>窗口的搜索栏中输入<code>fifo</code>关键字后，出现唯一匹配的<code>FIFO Generator</code>，如下图所示： <div align="center"><img src="/2024/06/24/fifo/11.png" width="80%/"></div></li></ol><h4 id="三、配置-IP-核"><a href="#三、配置-IP-核" class="headerlink" title="三、配置 IP 核"></a>三、配置 IP 核</h4><ol start="3"><li>双击<code>FIFO Generator</code>后弹出 IP 核的配置界面，对 BMG IP 核进行配置。</li></ol><ul><li><p><code>Basic</code>选项卡配置界面如下图所示:</p><div align="center"><img src="/2024/06/24/fifo/12.png" width="80%/"></div></li><li><p>该选项卡下各参数（重点关注（2）和（3）中的内容）含义如下：</p><ol><li>最上面的<code>Component Name</code>一栏可以设置该 IP 元件的名称，这里我们保持默认命名，当然也可以命名为其它方便自己一眼看出其功能的名称。 </li><li><code>lnterface Type（接口模式）</code>：有三种接口模式可选，分别为 <code>Native（常规）接口</code>、<code>AXI Memory Mapped（内存映射）接口</code>和 <code>AXI Stream（流）接口</code>。其中 AXI Memory Mapped 接口一般用于与PS 端进行数据交互；AXI Stream 接口一般应用于高速信号处理场景中，例如光口通信；通常情况下我们一般采用 Native 模式，所以本次实验我们选择 Native 模式。 </li><li><code>Fifo Implementation（FIFO 实现）</code>：用于设置用什么资源来实现什么样的 FIFO。可配置用于实现 FIFO 的资源有四种，分别为 <code>Block RAM（块 RAM）</code>、<code>Distributed RAM（分布式 RAM）</code>、<code>Shift Register （移位寄存器）</code>和 <code>Builtin FIFO（内置 FIFO）</code>，其中移位寄存器仅可用于实现同步 FIFO。可配置的 FIFO 类型有两类，分别为 <code>Common Clocks（公共时钟，即同步 FIFO）</code>和 <code>Independent Clocks（独立时钟，即异步FIFO）</code>。资源与种类两两组合之下便有了七种不同的选择。需要说明的是 BRAM 和分布式 RAM 是创建FIFO 时最常选用的存储资源类型，一般来说，FIFO 容量超过 1024 个字节就需要考虑使用 BRAM 了，没超过 1024 字节选择分布式 RAM。当然，如果芯片 BRAM 资源很富余的话，全部采用 BRAM 也是可以的，后两种基本用不到。本次实验我们选择<code>Independent Clocks Block RAM</code>，即使用 BRAM 资源来实现一个异步 FIFO。 </li><li><code>synchronization Stages（同步阶段）</code>：定义跨交叉时钟域逻辑的同步器级数，即设置读写状态信号的输出延迟。保持默认设置 2 即可。 </li><li><code>FIFO Implementation Options（FIFO 实现方案）</code>：此处的表格将实现 FIFO 的七种方案的特征都一一列出了，当我们不清楚自己的 FIFO 设计该使用哪种方案实现时，可以看下此处的表格。</li></ol></li><li><p><code>Native Ports</code>选项卡配置界面如下图所示:</p><div align="center"><img src="/2024/06/24/fifo/13.png" width="80%/"></div></li><li><p>该选项卡下各参数（重点关注（1）、（2）和（4）中的内容）含义如下：</p><ol><li><code>Read Mode（读取模式）</code>：有 <code>Standard FIFO（标准 FIFO）</code>和<code>First Word Fall Through（首字直通，简称 FWFT 模式，即预读模式）</code>两种可选，需要注意的是标准模式的数据输出会比读使能延迟一拍，预读模式的数据与读使能同时输出，这里我们选择默认的标准模式。 </li><li><code>Data Port Parameters（数据端口参数）</code>：用于设置 FIFO 的读写数据位宽和读写深度，其中写数据位宽可在 1<del>1024 内任意设置；写深度的可支持参数配置我们可以通过下拉来查看，这里我们设置为256，需要注意的是，虽然我们设置的深度为 256，但实际深度只有 255；读数据位宽支持 1：8</del>8：1 之间的偶数比，这里我们保持默认的 1：1 比例，即读数据位宽为 8；读深度是我们设置完读写数据位宽和写深度后自动确定的，无需我们进行设置。<br>  这里有一点需要我们注意，在实际应用中，FIFO 的读写数据位宽和深度在满足设计需求的情况下要尽量设置的小一点，因为 FIFO 使用的是片上 BRAM 资源，而 FPGA 内部的片上 BRAM 资源是有限的，所以大家不要将位宽和深度设置成远远超过实际需求的值，造成 BRAM 资源的过度浪费。 </li><li><code>ECC，Output Register and Power Gating Options（ECC、输出寄存器和电源选通选项）</code>，其下各配置如下： <ul><li>第一行有四个信号，当我们勾选 <code>ECC（纠错码）</code>后，可以选择 <code>Hard ECC（硬 ECC）</code>或 <code>Soft ECC （软 ECC）</code>，并可以勾选 <code>Single Bit Error Injection（注入单 bit 错误）</code>和 <code>Double Bit Error Injection（注入双bit 错误）</code>，这里我们保持默认的不启用 ECC 即可。 </li><li>第二行有两个信号，<code>ECC Pipeline Reg（ECC 管道寄存器）</code>和<code>Dynamic Power Gating（动态功率选通）</code>都是仅限 UltraScale 系列芯片使用 Builtin FIFO 资源实现 FIFO 时才可进行配置。</li><li>第三行用于配置输出寄存器，勾选<code>Output Registers（输出寄存器）</code>后，可以选择添加<code>Embedded Registers（嵌入式寄存器）</code>和<code>Fabric Registers（结构寄存器）</code>。其作用是可以改善 FIFO 的时序，为此付出的代价是每添加一个输出寄存器，输出就会延后一拍。这里我们保持默认，不做勾选。</li></ul></li><li><code>Initialization（初始化）</code>，也就是设置复位相关的参数，详情如下： <ul><li><code>Reset Pin（复位脚）</code>：选择是否引入复位信号，高电平有效。实际设计中，在 FPGA 配置完成后，读写操作开始前，FIFO 必须要进行复位操作，需要注意的是，在进行复位操作时，读写时钟必须是有效的。这里我们保持默认的勾选状态，即启用复位信号。 </li><li><code>Enable Reset Synchronization（启用复位同步）</code>：用于设置异步 FIFO 时是否启用同步复位，需要注意的是官方文档中建议复位信号至少要保持三个时钟周期（以慢时钟为准）的有效，且在复位后至少要经过三十个时钟周期（以慢时钟为准）后，才能对 FIFO 进行写数据操作。这里我们保持默认的勾选状态，即启用同步复位。 </li><li><code>Enable Safety Circuit（启用安全电路）</code>：用于设置 FIFO 是否向外输出 <code>wr_rst_busy</code>（写复位忙信号）和 <code>rd_rst_busy</code>（读复位忙信号），这两个信号皆是高电平表示处于复位状态，低电平表示空闲，我们可以通过这两个信号来判断 FIFO 是否复位完成，防止我们在复位完成前对 FIFO 进行读写操作而导致读写错误，所以我们保持默认的勾选状态，即启用安全电路。需要注意的是官方文档中建议当启用安全电路时，复位信号至少要保持八个时钟周期（以慢时钟为准）的有效，且在复位后至少要经过六十个时钟周期（以慢时钟为准）后，才能对 FIFO 进行写数据操作。 </li><li><code>Reset Type（复位类型）</code>：当选择使用非 Builtin FIFO 资源来实现同步 FIFO 时，可以选择复位类型为<code>Asynchronous Reset（异步复位）</code>或 <code>Synchronous Reset（同步复位）</code>，使用异步 FIFO 模式时不需要考虑该配置。 </li><li><code>Full Flags Reset Value（满信号的重置值）</code>：用于设置复位时三个满信号（满信号，将满信号，设置满信号）的状态是高电平还是低电平。这里我们保持默认设置 1 即可。 </li><li><code>Dout Reset Value（输出的数据重置值）</code>：设置复位期间 FIFO 输出总线上的数据值，若未启用，则复位期间输出总线上的值时未知的。切记设置时此值的位宽不可超过读数据的位宽，这里我们保持默认的 0 即可。</li></ul></li><li><code>Read Latency（读延迟）</code>，可以在此处看出经过以上设置后，输出被延迟了几拍。因为我们选择的读取模式是标准模式，且没有启用任何输出寄存器，所以输出延迟了一拍。</li></ol></li><li><p><code>Status Flags</code>选项卡配置界面如下图所示:</p><div align="center"><img src="/2024/06/24/fifo/14.png" width="80%/"></div></li><li><p>该选项卡下各参数（重点关注（1）中的内容）含义如下：</p><ol><li><code>Optional Flags（可选标准）</code>，可勾选是否输出 <code>Almost Full Flag（将满信号）</code>和 <code>Almost Empty Flag（将空信号）</code>，两个信号皆为高有效。其中将满信号是在 FIFO 内部写数据个数<strong>大于等于FIFO 深度-1</strong> 之后的第一个写时钟上升沿置高，直到 FIFO 内部写数据个数<strong>小于FIFO 深度-1</strong> 后的第一个写时钟上升沿拉低；将空信号是在 FIFO 内部读数据个数<strong>小于等于1</strong> 之后的第一个读时钟上升沿置高，直到 FIFO 内部读数据个数<strong>大于1</strong> 后的第一个读时钟上升沿拉低。这里我们选择输出这两个标志信号。</li><li><code>Handshaking Options（握手选项）</code>，可用于配置读写端口的握手机制，这里我们简单的介绍下各个配置含义：<ul><li><code>Write Port Handshaking（写端口握手）</code>：可使能 <code>Write Ackongledge</code>（写应答）信号和 <code>Overflow</code>（满溢出）信号。其中写应答信号是成功写入数据的标志，一次成功写入对应一个写时钟周期的写应答，有效电平状态可配；满溢出信号是写入数据无效（溢出）的标志，一次溢出对应一个写时钟周期，有效电平状态可配。这里我们不做任何勾选。 </li><li><code>Read Port Handshaking（读端口握手）</code>：可使能 <code>Valid Flag</code>（读有效标志）信号和 <code>Underflow Flag</code>（空溢出）信号。这两个信号的有效电平状态同样可配，信号含义和写端口握手中的两个信号类似，这里就不多赘述了，这里我们不做任何勾选。</li></ul></li><li><code>Programmable Flags（可编程标志）</code>有六个可配置参数，这里的参数配置将影响到可编程空满信号（<code>prog_empty</code>和 <code>prog_full</code> 信号）在何时使能，各参数含义如下：<ul><li><code>Programmable Full Type（可编程满类型）</code>：有五种类型可选，如下表所示：<img src="/2024/06/24/fifo/16.png"></li><li><code>Full Therhold Assert Value（满阈值有效值）</code>：当类型配置为单可编程满阈值常量，其可配置范围为 3~ 写深度-3；当类型配置为双可编程满阈值常量，其可配置范围为 4~写深度-3。 </li><li><code>Full Therhold Negate Value（满阈值无效值）</code>：当类型配置为双可编程满阈值常量才可进行配置，可配置范围为 3~满阈值有效值-1。</li><li><code>Programmable Empty Type（可编程空类型）</code>：有五种类型可选，含义与可编程满类型相同，只是满阈值变成了空阈值，这里就不再赘述了。 </li><li><code>Empty Threshold Assert Value（空阈值有效值）</code>：当类型配置为单可编程空阈值常量，其可配置范围为2<del>读实际深度-3；当类型配置为双可编程满阈值常量，其可配置范围为 2</del>读实际深度-4。 </li><li><code>Empty Threshold Negate Value（空阈值无效值）</code>：当类型配置为双可编程满阈值常量才可进行配置，可配置范围为空阈值有效值+1~读实际深度-3。 </li><li>以可编程满阈值为例，假如在单可编程满阈值类型下，写深度为 32，而我们将满阈值有效值设置为28，那么 <code>prog_full</code> 信号将会在 FIFO 中的数据<strong>大于等于28</strong> 后的第一个写时钟上升沿置高，直到 FIFO 内部写数据个数<strong>小于28</strong> 后的第一个写时钟上升沿拉低。</li></ul></li></ol></li><li><p><code>Data Counts</code>选项卡配置界面如下图所示:</p><div align="center"><img src="/2024/06/24/fifo/15.png" width="80%/"></div></li><li><p>该选项卡下各参数（重点关注（1）中的内容）含义如下：</p><ol><li><code>More Accurate Data Counts（更精确的数据计数）</code>，该功能只有选择使用块 RAM 或者分布式RAM 来实现 FIFO 时，将读取模式设置为预读模式才可进行配置和使用。 </li><li><code>Data Counts（数据计数）</code>，当使用非 Builtin FIFO 资源来实现同步 FIFO 时可进行设置，可用于跟踪 FIFO 中的字数（数据个数），我们可以指定其计数总线的宽度，最小为 1，最大宽度为 log2（FIFO 深度），如果指定的宽度小于最大宽度，则低位会被截断。例如数据深度为 16，则 Data Counts 的最大位宽为 4，如果我们设置为 3，那么 FIFO 中的数据量&#x3D;2 时，Data Counts 才会加 1。 </li><li><code>Write Data Count(写数据计数)</code>，与写时钟同步。当使用非 Builtin FIFO 资源来实现异步 FIFO 时可进行设置，可用于跟踪写 FIFO 中的字数（数据个数），我们可以指定其计数总线的宽度，最小为 1，最大宽度为 log2（写 FIFO 深度），如果指定的宽度小于最大宽度，则低位会被截断。 </li><li><code>Read Data Count(读数据计数)</code>，与读时钟同步。当使用非 Builtin FIFO 资源来实现异步 FIFO 时可进行设置，可用于跟踪读 FIFO 中的字数（数据个数），我们可以指定其计数总线的宽度，最小为 1，最大宽度为 log2（读 FIFO 深度），如果指定的宽度小于最大宽度，则低位会被截断。</li></ol></li><li><p><code>Summary</code>选项卡，该界面显示了我们配置的存储器的类型，消耗的 BRAM 资源等信息，我们直接点击<code>OK</code>按钮完成 FIFO Generator IP 核的配置，如下图所示：</p><div align="center"><img src="/2024/06/24/fifo/17.png" width="80%/"></div></li></ul><h4 id="四、生成-IP-核"><a href="#四、生成-IP-核" class="headerlink" title="四、生成 IP 核"></a>四、生成 IP 核</h4><ol start="4"><li>配置完成后，弹出了<code>Generate Output Products</code>窗口，点击<code>Generate</code>按钮，开始生成 IP 核。<div align="center"><img src="/2024/06/24/fifo/18.png" width="50%/"></div></li></ol><h4 id="五、等待综合"><a href="#五、等待综合" class="headerlink" title="五、等待综合"></a>五、等待综合</h4><ol start="5"><li>在<code>Design Run</code>窗口的<code>Out-of-Context Module Runs</code>一栏中看到该 IP 核对应的run <code>fifo_generator_0_synth_1</code>，其综合过程独立于顶层设计的综合，所以我们可以看到其正在综合，如下图所示： <div align="center"><img src="/2024/06/24/fifo/19.png" width="60%/"></div></li></ol><h4 id="六、拷贝例化模板代码"><a href="#六、拷贝例化模板代码" class="headerlink" title="六、拷贝例化模板代码"></a>六、拷贝例化模板代码</h4><ol start="6"><li>综合完成后，便可开始编写代码。首先查看IP核的例化模板。在<code>Source</code> 窗口中的<code>IP Sources</code>选项卡中，依次用鼠标单击展开<code>IP</code>-<code>fifo_generator_0</code>-<code>Instantitation Template</code>，我们可以看到<code>fifo_generator_0.veo</code>文件，它是由 IP 核自动生成的只读的 verilog 例化模板文件，双击就可以打开它，在例化时钟 IP 核模块的时钟，可以直接从这里拷贝，如下图所示 :<div align="center"><img src="/2024/06/24/fifo/20.png" width="100%/"></div></li></ol><h4 id="七、创建顶层模块"><a href="#七、创建顶层模块" class="headerlink" title="七、创建顶层模块"></a>七、创建顶层模块</h4><ol start="7"><li>本次实验除了调用 BMG IP 核外，需要使用到 PLL IP 核来输出两路不同频率的时钟来生成一个异步 FIFO，还需要例化一个写模块<code>fifo_wr</code>和一个读模块<code>fifo_rd</code>来进行异步的读写操作，所以需要创建一个顶层模块来例化两个 IP 核与读&#x2F;写模块。创建源文件后，将顶层模块命名为 <code>ip_fifo</code>，代码如下： <pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">ip_fifo</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>    sys_clk <span class="token punctuation">,</span>  <span class="token comment">// 系统时钟信号</span>    <span class="token keyword">input</span>    sys_rst_n  <span class="token comment">// 系统复位信号</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//wire define</span><span class="token keyword">wire</span>         clk_50m       <span class="token punctuation">;</span>  <span class="token comment">// 50M时钟</span><span class="token keyword">wire</span>         clk_100m      <span class="token punctuation">;</span>  <span class="token comment">// 100M时钟</span><span class="token keyword">wire</span>         locked        <span class="token punctuation">;</span>  <span class="token comment">// 时钟锁定信号</span><span class="token keyword">wire</span>         rst_n         <span class="token punctuation">;</span>  <span class="token comment">// 复位，低有效</span><span class="token keyword">wire</span>         wr_rst_busy   <span class="token punctuation">;</span>  <span class="token comment">// 写复位忙信号</span><span class="token keyword">wire</span>         rd_rst_busy   <span class="token punctuation">;</span>  <span class="token comment">// 读复位忙信号</span><span class="token keyword">wire</span>         fifo_wr_en    <span class="token punctuation">;</span>  <span class="token comment">// FIFO写使能信号</span><span class="token keyword">wire</span>         fifo_rd_en    <span class="token punctuation">;</span>  <span class="token comment">// FIFO读使能信号</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  fifo_wr_data  <span class="token punctuation">;</span>  <span class="token comment">// 写入到FIFO的数据</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  fifo_rd_data  <span class="token punctuation">;</span>  <span class="token comment">// 从FIFO读出的数据</span><span class="token keyword">wire</span>         almost_full   <span class="token punctuation">;</span>  <span class="token comment">// FIFO将满信号</span><span class="token keyword">wire</span>         almost_empty  <span class="token punctuation">;</span>  <span class="token comment">// FIFO将空信号</span><span class="token keyword">wire</span>         full          <span class="token punctuation">;</span>  <span class="token comment">// FIFO满信号</span><span class="token keyword">wire</span>         empty         <span class="token punctuation">;</span>  <span class="token comment">// FIFO空信号</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  wr_data_count <span class="token punctuation">;</span>  <span class="token comment">// FIFO写时钟域的数据计数</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  rd_data_count <span class="token punctuation">;</span>  <span class="token comment">// FIFO读时钟域的数据计数</span><span class="token comment">//通过系统复位信号和时钟锁定信号来产生一个新的复位信号</span><span class="token keyword">assign</span>   rst_n <span class="token operator">=</span> sys_rst_n <span class="token operator">&amp;</span> locked<span class="token punctuation">;</span><span class="token comment">//例化PLL IP核</span>clk_wiz_0 <span class="token function">clk_wiz_0</span><span class="token punctuation">(</span>   <span class="token comment">// Clock out ports</span>   <span class="token punctuation">.</span><span class="token function">clk_out1</span><span class="token punctuation">(</span>clk_50m<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out1</span>   <span class="token punctuation">.</span><span class="token function">clk_out2</span><span class="token punctuation">(</span>clk_100m<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out2</span>   <span class="token comment">// Status and control signals</span>   <span class="token punctuation">.</span><span class="token function">locked</span><span class="token punctuation">(</span>locked<span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment">// output locked</span>   <span class="token comment">// Clock in ports</span>   <span class="token punctuation">.</span><span class="token function">clk_in1</span><span class="token punctuation">(</span>sys_clk <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// input clk_in1</span><span class="token comment">//例化FIFO IP核</span>fifo_generator_0 fifo_generator_0_u <span class="token punctuation">(</span>      <span class="token punctuation">.</span><span class="token function">rst</span><span class="token punctuation">(</span><span class="token operator">~</span>rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>                      <span class="token comment">// input wire rst</span>      <span class="token punctuation">.</span><span class="token function">wr_clk</span><span class="token punctuation">(</span>clk_50m <span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">// input wire wr_clk</span>      <span class="token punctuation">.</span><span class="token function">rd_clk</span><span class="token punctuation">(</span>clk_100m<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">// input wire rd_clk</span>      <span class="token punctuation">.</span><span class="token function">din</span><span class="token punctuation">(</span>fifo_wr_data<span class="token punctuation">)</span><span class="token punctuation">,</span>                      <span class="token comment">// input wire [7 : 0] din</span>      <span class="token punctuation">.</span><span class="token function">wr_en</span><span class="token punctuation">(</span>fifo_wr_en<span class="token punctuation">)</span><span class="token punctuation">,</span>                  <span class="token comment">// input wire wr_en</span>      <span class="token punctuation">.</span><span class="token function">rd_en</span><span class="token punctuation">(</span>fifo_rd_en<span class="token punctuation">)</span><span class="token punctuation">,</span>                  <span class="token comment">// input wire rd_en</span>      <span class="token punctuation">.</span><span class="token function">dout</span><span class="token punctuation">(</span>fifo_rd_data<span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment">// output wire [7 : 0] dout</span>      <span class="token punctuation">.</span><span class="token function">full</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment">// output wire full</span>      <span class="token punctuation">.</span><span class="token function">almost_full</span><span class="token punctuation">(</span>almost_full<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// output wire almost_full</span>      <span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">,</span>                  <span class="token comment">// output wire empty</span>      <span class="token punctuation">.</span><span class="token function">almost_empty</span><span class="token punctuation">(</span>almost_empty<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// output wire almost_empty</span>      <span class="token punctuation">.</span><span class="token function">rd_data_count</span><span class="token punctuation">(</span>rd_data_count<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// output wire [7 : 0] rd_data_count</span>      <span class="token punctuation">.</span><span class="token function">wr_data_count</span><span class="token punctuation">(</span>wr_data_count<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// output wire [7 : 0] wr_data_count</span>      <span class="token punctuation">.</span><span class="token function">wr_rst_busy</span><span class="token punctuation">(</span>wr_rst_busy<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// output wire wr_rst_busy</span>      <span class="token punctuation">.</span><span class="token function">rd_rst_busy</span><span class="token punctuation">(</span>rd_rst_busy<span class="token punctuation">)</span>      <span class="token comment">// output wire rd_rst_busy</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//例化写FIFO模块</span>fifo_wr <span class="token function">fifo_wr_u</span><span class="token punctuation">(</span>    <span class="token punctuation">.</span>wr_clk      <span class="token punctuation">(</span>clk_50m<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 写时钟</span>    <span class="token punctuation">.</span>rst_n       <span class="token punctuation">(</span>rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 复位信号</span>    <span class="token punctuation">.</span>wr_rst_busy <span class="token punctuation">(</span>wr_rst_busy<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 写复位忙信号 </span>    <span class="token punctuation">.</span>almost_full <span class="token punctuation">(</span>almost_full<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// fifo将满信号</span>    <span class="token punctuation">.</span>empty       <span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// fifo空信号</span>    <span class="token punctuation">.</span>fifo_wr_en  <span class="token punctuation">(</span>fifo_wr_en<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// fifo写请求</span>    <span class="token punctuation">.</span><span class="token function">fifo_wr_data</span><span class="token punctuation">(</span>fifo_wr_data<span class="token punctuation">)</span>  <span class="token comment">// 写入FIFO的数据</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//例化读FIFO模块</span>fifo_rd <span class="token function">fifo_rd_u</span><span class="token punctuation">(</span>    <span class="token punctuation">.</span>rd_clk       <span class="token punctuation">(</span>clk_100m<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 读时钟</span>    <span class="token punctuation">.</span>rst_n        <span class="token punctuation">(</span>rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 复位信号     </span>    <span class="token punctuation">.</span>rd_rst_busy  <span class="token punctuation">(</span>rd_rst_busy<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 读复位忙信号</span>    <span class="token punctuation">.</span>almost_empty <span class="token punctuation">(</span>almost_empty<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// fifo将空信号</span>    <span class="token punctuation">.</span>full         <span class="token punctuation">(</span>full        <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// fifo满信号</span>    <span class="token punctuation">.</span>fifo_rd_en   <span class="token punctuation">(</span>fifo_rd_en  <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// fifo读请求</span>    <span class="token punctuation">.</span>fifo_rd_data <span class="token punctuation">(</span>fifo_rd_data<span class="token punctuation">)</span> <span class="token comment">// 从FIFO输出的数据</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>例化了 <strong>FIFO IP 核</strong><code>fifo_generator_0</code>、<strong>PLL IP 核</strong><code>clk_wiz_0</code>、<strong>读模块</strong><code>fifo_rd</code>和<strong>写模块</strong><code>fifo_wr</code>，其中写模块负责产生 FIFO IP 核写操作所需的所有数据、写请求等信号；读模块负责产生 FIFO IP 核读操作所需读请求信号，并将读出的数据也连接至读模块。 </li><li>因为读写模块的时钟皆来自 PLL IP 核，而 PLL IP 核需要一定的时间才能输出稳定的时钟，所以需要通过系统复位信号和时钟锁定信号来产生一个新的复位信号，使读&#x2F;写模块及 FIFO IP 核在时钟稳定后才进入工作状态。</li></ul><h4 id="八、创建写模块"><a href="#八、创建写模块" class="headerlink" title="八、创建写模块"></a>八、创建写模块</h4><ol start="8"><li><code>fifo_wr</code> 模块用于产生 FIFO 写操作所需的信号，绘制大致的模块端口信号的波形图方便理解。<div align="center"><img src="/2024/06/24/fifo/21.png" width="90%/"></div></li></ol><ul><li>由上图可知，当系统复位结束后，FIFO 还处于复位状态，我们需要等待 FIFO 写复位结束（即<code>wr_rst_busy</code> 信号拉低）后，再对 FIFO 进行写操作。这里说明一下，因为 <code>empty</code>（空）信号是 FIFO 读时钟域的输出信号，对于写操作来说属于异步信号，所以这里我们通过打拍的方式将 <code>empty</code> 信号同步到写时钟域下。需要注意的是，当 FIFO 中有两个或两个以上的数据时，将空信号就会被拉低，但是因为是异步FIFO，所以状态信号的同步需要一定的时间，因此将空信号并不是在写入第二个数据后拉低的。 </li><li>代码如下：<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">fifo_wr</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>                  wr_clk      <span class="token punctuation">,</span>  <span class="token comment">// 时钟信号</span>    <span class="token keyword">input</span>                  rst_n       <span class="token punctuation">,</span>  <span class="token comment">// 复位信号</span>    <span class="token comment">//FIFO interface       </span>    <span class="token keyword">input</span>                  wr_rst_busy <span class="token punctuation">,</span>  <span class="token comment">// 写复位忙信号</span>    <span class="token keyword">input</span>                  almost_full <span class="token punctuation">,</span>  <span class="token comment">// FIFO将满信号</span>    <span class="token keyword">input</span>                  empty       <span class="token punctuation">,</span>  <span class="token comment">// FIFO空信号</span>    <span class="token keyword">output</span>    <span class="token keyword">reg</span>          fifo_wr_en  <span class="token punctuation">,</span>  <span class="token comment">// FIFO写使能</span>    <span class="token keyword">output</span>    <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   fifo_wr_data   <span class="token comment">// 写入FIFO的数据</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//reg define</span><span class="token keyword">reg</span>        empty_d0<span class="token punctuation">;</span><span class="token keyword">reg</span>        empty_d1<span class="token punctuation">;</span>    <span class="token comment">//因为empty信号是属于FIFO读时钟域的</span><span class="token comment">//所以对empty打两拍同步到写时钟域下</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> wr_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>        empty_d0 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        empty_d1 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        empty_d0 <span class="token operator">&lt;=</span> empty<span class="token punctuation">;</span>        empty_d1 <span class="token operator">&lt;=</span> empty_d0<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span>    <span class="token comment">//对fifo_wr_en赋值，当FIFO为空时开始写入，写满后停止写</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> wr_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>         fifo_wr_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>wr_rst_busy<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>empty_d1<span class="token punctuation">)</span>            fifo_wr_en <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>almost_full<span class="token punctuation">)</span>            fifo_wr_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span>    <span class="token keyword">else</span>        fifo_wr_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token comment">//对fifo_wr_data赋值,0~254</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> wr_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>         fifo_wr_data <span class="token operator">&lt;=</span> <span class="token number">8'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>fifo_wr_en <span class="token operator">&amp;&amp;</span> fifo_wr_data <span class="token operator">&lt;</span> <span class="token number">8'd254</span><span class="token punctuation">)</span>        fifo_wr_data <span class="token operator">&lt;=</span> fifo_wr_data <span class="token operator">+</span> <span class="token number">8'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        fifo_wr_data <span class="token operator">&lt;=</span> <span class="token number">8'b0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="九、创建读模块"><a href="#九、创建读模块" class="headerlink" title="九、创建读模块"></a>九、创建读模块</h4><ol start="9"><li><code>fifo_rd</code> 模块用于产生 FIFO 读操作所需的信号，绘制大致的模块端口信号的波形图方便理解。<div align="center"><img src="/2024/06/24/fifo/22.png" width="90%/"></div></li></ol><ul><li>由上图可知，当系统复位结束后，FIFO 还处于复位状态，我们需要等待 FIFO 读复位结束（即<code>wr_rst_busy</code> 信号拉低）后，再对 FIFO 进行读操作。这里说明一下，因为 <code>full</code>（满）信号是 FIFO 写时钟域的输出信号，对于写操作来说属于异步信号，所以这里我们通过打拍的方式将 <code>full</code> 信号同步到写时钟域下。需要注意的是，当 FIFO 中的数据量小于写深度-1 时，将满信号就会被拉低，但是因为是异步 FIFO，所以状态信号的同步需要一定的时间，因此将空信号并不是在读出第二个数据后拉低的。 </li><li>代码如下：<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">fifo_rd</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>                  rd_clk      <span class="token punctuation">,</span>  <span class="token comment">// 时钟信号</span>    <span class="token keyword">input</span>                  rst_n       <span class="token punctuation">,</span>  <span class="token comment">// 复位信号</span>    <span class="token comment">//FIFO interface       </span>    <span class="token keyword">input</span>                  rd_rst_busy <span class="token punctuation">,</span>  <span class="token comment">// 读复位忙信号</span>    <span class="token keyword">input</span>                  almost_empty <span class="token punctuation">,</span>  <span class="token comment">// FIFO将满空信号</span>    <span class="token keyword">input</span>                  full       <span class="token punctuation">,</span>  <span class="token comment">// FIFO满信号</span>    <span class="token keyword">output</span>    <span class="token keyword">reg</span>          fifo_rd_en  <span class="token punctuation">,</span>  <span class="token comment">// FIFO读使能</span>    <span class="token keyword">input</span>          <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   fifo_rd_data   <span class="token comment">// 读入FIFO的数据</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//reg define</span> <span class="token keyword">reg</span>       full_d0<span class="token punctuation">;</span> <span class="token keyword">reg</span>       full_d1<span class="token punctuation">;</span>           <span class="token comment">//因为full信号是属于FIFO写时钟域的</span> <span class="token comment">//所以对full打两拍同步到读时钟域下</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> rd_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>     <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>         full_d0 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>         full_d1 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>     <span class="token keyword">end</span>     <span class="token keyword">else</span> <span class="token keyword">begin</span>         full_d0 <span class="token operator">&lt;=</span> full<span class="token punctuation">;</span>         full_d1 <span class="token operator">&lt;=</span> full_d0<span class="token punctuation">;</span>     <span class="token keyword">end</span> <span class="token keyword">end</span>        <span class="token comment">//对fifo_rd_en进行赋值,FIFO写满之后开始读，读空之后停止读</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> rd_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>         fifo_rd_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rd_rst_busy<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token function">if</span><span class="token punctuation">(</span>full_d1<span class="token punctuation">)</span>           fifo_rd_en <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>almost_empty<span class="token punctuation">)</span>           fifo_rd_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>     <span class="token keyword">end</span>    <span class="token keyword">else</span>        fifo_rd_en <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">end</span>                  <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="十、引脚约束"><a href="#十、引脚约束" class="headerlink" title="十、引脚约束"></a>十、引脚约束</h4><ol start="10"><li>完成模块设计后，需要将模块的端口与 FPGA 的引脚进行约束。对应的 XDC 约束语句如下所示：</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">create_clock <span class="token operator">-</span>period <span class="token number">20.000</span> <span class="token operator">-</span>name sys_clk <span class="token punctuation">[</span>get_ports sys_clk<span class="token punctuation">]</span> set_property <span class="token operator">-</span>dict <span class="token operator">&#123;</span>PACKAGE_PIN R4 IOSTANDARD LVCMOS33<span class="token operator">&#125;</span> <span class="token punctuation">[</span>get_ports sys_clk<span class="token punctuation">]</span> set_property <span class="token operator">-</span>dict <span class="token operator">&#123;</span>PACKAGE_PIN U2 IOSTANDARD LVCMOS33<span class="token operator">&#125;</span> <span class="token punctuation">[</span>get_ports sys_rst_n<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="十一、添加-ILA-IP-核"><a href="#十一、添加-ILA-IP-核" class="headerlink" title="十一、添加 ILA IP 核"></a>十一、添加 ILA IP 核</h4><ol start="11"><li>添加两个 ILA IP 核，用于观察 FIFO 的读&#x2F;写状态</li></ol><ul><li>本例程是将 ILA 例化在了 <code>ip_fifo</code> 模块中，例化代码如下所示：<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//写时钟域下 ila    </span>ila_0 ila_wr <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>clk_50m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire clk</span><span class="token punctuation">.</span><span class="token function">probe0</span><span class="token punctuation">(</span>fifo_wr_en<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe0  </span><span class="token punctuation">.</span><span class="token function">probe1</span><span class="token punctuation">(</span>fifo_wr_data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [7:0]  probe1 </span><span class="token punctuation">.</span><span class="token function">probe2</span><span class="token punctuation">(</span>almost_full<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe2 </span><span class="token punctuation">.</span><span class="token function">probe3</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe3 </span><span class="token punctuation">.</span><span class="token function">probe4</span><span class="token punctuation">(</span>wr_data_count<span class="token punctuation">)</span> <span class="token comment">// input wire [7:0]  probe4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读时钟域下 ila   </span>ila_1 your_instance_name <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>clk_100m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire clk</span><span class="token punctuation">.</span><span class="token function">probe0</span><span class="token punctuation">(</span>fifo_rd_en<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe0  </span><span class="token punctuation">.</span><span class="token function">probe1</span><span class="token punctuation">(</span>fifo_rd_data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [7:0]  probe1 </span><span class="token punctuation">.</span><span class="token function">probe2</span><span class="token punctuation">(</span>almost_empty<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe2 </span><span class="token punctuation">.</span><span class="token function">probe3</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe3 </span><span class="token punctuation">.</span><span class="token function">probe4</span><span class="token punctuation">(</span>rd_data_count<span class="token punctuation">)</span> <span class="token comment">// input wire [7:0]  probe4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="十二、上板验证"><a href="#十二、上板验证" class="headerlink" title="十二、上板验证"></a>十二、上板验证</h4><ol start="12"><li>综合、实现、下载比特流后，在 FPGA 上验证 FIFO 的读写功能。</li></ol><ul><li><p><strong>FIFO 写操作</strong>在 ILA 中观察到的波形如下图所示： </p><div align="center"><img src="/2024/06/24/fifo/23.png" width="75%/"></div><div align="center"><img src="/2024/06/24/fifo/24.png" width="90%/"></div></li><li><p>由上图可知，写使能拉高后，开始向 FIFO 中写入数据，当还能进行最后一次写操作时，将满信号<code>almost_full</code>拉高，当写入最后一个数据后，满信号<code>fifo_full</code>拉高，此时写使能关闭，等待读使能打开。 </p></li><li><p><strong>FIFO 读操作</strong>在 ILA 中观察到的波形如下图所示： </p><div align="center"><img src="/2024/06/24/fifo/25.png" width="75%/"></div><div align="center"><img src="/2024/06/24/fifo/26.png" width="90%/"></div></li><li><p>由上图可知，读使能拉高后，开始从 FIFO 中读出数据，当读出倒数第二个数后，将空信号<code>almost_empty</code>拉高，当读出最后一个数据后，空信号<code>fifo_empty</code>拉高，此时读使能关闭，等待写使能打开。从图中我们也可以看出读使能拉高后，读数据会延后一拍输出，和我们的设置相符。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之IP核 RAM</title>
      <link href="/2024/06/19/ram/"/>
      <url>/2024/06/19/ram/</url>
      
        <content type="html"><![CDATA[<h1 id="IP核之-RAM"><a href="#IP核之-RAM" class="headerlink" title="IP核之 RAM"></a>IP核之 RAM</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>由下图可知，存储器包括随机存储器和只读存储器</li><li><strong>随机存储器</strong>包括<strong>静态 RAM</strong> 和<strong>动态 RAM</strong>。静态RAM 只要有供电，它保存的数据就不会丢失；而动态 RAM 在供电的情况下，还需要根据其要求的时间来对存储的数据进行刷新，才能保持存储的数据不会丢失。</li><li><strong>只读存储器</strong>一般包括 <strong>PROM</strong>、<strong>EPROM</strong> 和 <strong>EEPROM</strong> 等，是非易失性的存储器。目前使用率较高的是EEPROM，其特点是容量相对较小，存储的一般是器件的配置参数信息，例如 USB 2.0 芯片一般会配有一个 EEPROM 来存储相关的固件信息。 </li><li>想要了解更多关于存储器的内容，可访问本人博客另一文章《计算机组成原理》的存储系统板块</li></ul><p><img src="/2024/06/19/ram/1.png"> </p><h2 id="何为-RAM"><a href="#何为-RAM" class="headerlink" title="何为 RAM"></a>何为 RAM</h2><h3 id="静态-RAM-和-动态-RAM"><a href="#静态-RAM-和-动态-RAM" class="headerlink" title="静态 RAM 和 动态 RAM"></a>静态 RAM 和 动态 RAM</h3><ul><li><strong>静态 RAM</strong> 一般包括<strong>单端口 RAM</strong>（Single Port RAM，缩写为 SP RAM）、<strong>简单双端口 RAM</strong>（Simple Dual Port RAM，缩写为 SDP RAM，也叫伪双端口 RAM）和<strong>真双端口 RAM</strong>（True Dual Port RAM，缩写为 TDP RAM）。静态 RAM 的特点是存储容量相对不是很大，但是读写速度非常高，其在 FPGA 或者 ASIC 设计中都属于非常重要的器件，可以说查找表、寄存器、组合逻辑和静态 RAM 构成了整个数字电路体系，足见静态 RAM 的重要性。 </li><li><strong>动态 RAM</strong> 一般包括 <strong>SDRAM</strong> 和 <strong>DDR SDRAM</strong>。目前 DDR SDRAM 已经从 DDR1 代发展到 DDR5 代了，DDR3 和 DDR4 SDRAM 是目前非常主流的存储器，大量使用在电脑、嵌入式和 FPGA 板卡上面，其特点是存储容量非常大、但是读写速度相比于静态 RAM 会稍低一些，这一点在数据量较少的情况下尤为明显。 </li><li>本文主要讲解<strong>静态 RAM</strong></li></ul><h3 id="静态-RAM-的常见种类及其特性与区别"><a href="#静态-RAM-的常见种类及其特性与区别" class="headerlink" title="静态 RAM 的常见种类及其特性与区别"></a>静态 RAM 的常见种类及其特性与区别</h3><table><thead><tr><th align="center">RAM类型</th><th align="left">特性说明</th><th align="center">数据读写口数量</th><th align="center">地址口数量</th></tr></thead><tbody><tr><td align="center">单端口RAM</td><td align="left">1. 允许通过一个端口对存储进行读写访问。<br> 2. 只有一组数据总线、地址总线、时钟信号以及读写使能信号。<br></td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">伪双端口RAM</td><td align="left">1. 提供A和B两个端口，端口A只能进行写访问，端口B只能进行读访问。 <br>2. 有两组数据总线、地址总线、时钟信号以及读写使能信号。<br></td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">真双端口RAM</td><td align="left">1. 提供A和B两个端口，两个端口均可对存储进行读写访问。 <br>2. 有两组数据总线、地址总线、时钟信号以及读写使能信号。<br></td><td align="center">2</td><td align="center">2</td></tr></tbody></table><ul><li>从上表可以看出:<ul><li><strong>单端口 RAM</strong> ，其只有一个端口进行读写，即读&#x2F;写只能通过这一个端口来进行。</li><li><strong>伪双端口 RAM</strong> ，其也有两个端口可以用于读写，但是其中一个端口只能读不能写，另一个端口只能写不能读；</li><li><strong>真双端口 RAM</strong> ，其有两个端口可以用于读写，且两个端口都可以进行读或写</li></ul></li></ul><h3 id="静态-RAM-的使用场景"><a href="#静态-RAM-的使用场景" class="headerlink" title="静态 RAM 的使用场景"></a>静态 RAM 的使用场景</h3><ul><li>不同的特性决定不同的应用场景，在 RAM 的实际应用中，一般根据功能需求和带宽需求来选择合适的 RAM 类型，例如： <ol><li>当我们需要读取一个配置，且这个配置只在上电的时候配置一次，其他时候不需要写操作，那么我们直接选择单端口 RAM 即可，通过一个端口要么进行写操作，要么进行读操作。</li><li>当我们需要使用 FIFO（先进先出存储器）来存储数据，就可以选择伪双端口 RAM，一个写端口，一个读端口，且读写可以同时进行。 </li><li>当我们想要实现一个对 10000 节车厢的人数进行统计的功能，每节车厢有两个门，一个门仅用于上车，另一个门仅用于下车，有人上车时需要在原有的人数基础上加一，有人下车时需要在原有的人数基础上减一，每时每刻都可能有人上下车，那么要使用逻辑统计这么多节车厢的人数时，就需要有两个写端<br>口的 RAM，深度为 10000（对应 10000 节车厢），这时就要选择真双端口 RAM 了。因为如果单纯的使用寄存器资源进行统计的话，仅这 10000 节车厢的计数就很可能把 FPGA 的寄存器资源消耗殆尽了。</li></ol></li></ul><h2 id="RAM-设计"><a href="#RAM-设计" class="headerlink" title="RAM 设计"></a>RAM 设计</h2><h3 id="单端口-RAM-配置"><a href="#单端口-RAM-配置" class="headerlink" title="单端口 RAM 配置"></a>单端口 RAM 配置</h3><h4 id="单端口-RAM-基础知识"><a href="#单端口-RAM-基础知识" class="headerlink" title="单端口 RAM 基础知识"></a>单端口 RAM 基础知识</h4><ul><li><p>BMG IP 核配置成单端口 RAM 的框图</p><div align="center"><img src="/2024/06/19/ram/2.png" width="70%/"></div></li><li><p>各个端口的功能描述如下：</p><div align="center"><img src="/2024/06/19/ram/3.png" width="100%/"></div></li></ul><h4 id="单端口-RAM-设计思路"><a href="#单端口-RAM-设计思路" class="headerlink" title="单端口 RAM 设计思路"></a>单端口 RAM 设计思路</h4><ul><li>本次实验的目的是为了将 Xilinx BMG IP 核配置成一个单端口的 RAM 并对其进行读写操作。</li></ul><h5 id="顶层模块设计"><a href="#顶层模块设计" class="headerlink" title="顶层模块设计"></a>顶层模块设计</h5><ul><li><strong>顶层模块设计</strong>：由于单端口 RAM 的读写是共用一组信号总线的，所以这里我们将读写操作合成一个模块，可以将其命名为 <code>ram_rw</code>；系统时钟和系统复位是一个完整的工程中必不可少的输入端口信号，这里就不再多讲了；因为 RAM 主要用于存储程序中的数据，并不需要输出到 IO 引脚上，所以本实验不需要输出端口。</li><li>综上可得一个大致的模块框图：<div align="center"><img src="/2024/06/19/ram/15.png" width="50%/"></div></li></ul><h5 id="读写模块设计"><a href="#读写模块设计" class="headerlink" title="读写模块设计"></a>读写模块设计</h5><ul><li><p><strong>读写模块设计</strong>：在 RAM 读写模块中，我们的输入信号主要有<strong>系统时钟信号</strong>、<strong>系统复位信号</strong>和 RAM IP 核输出的读数据<code>ram_rd_data</code>，输出有控制 RAM 所需的 <strong>RAM 端口使能</strong><code>ram_en</code>、<strong>读写使能</strong><code>ram_we</code>、<strong>读写地址</strong><code>ram_addr</code>和 <strong>写数据</strong><code>ram_wr_data</code>这四个信号。</p></li><li><p>综上可得一个大致的模块框图：</p><div align="center"><img src="/2024/06/19/ram/17.png" width="50%/"></div></li><li><p>模块端口与功能描述如下表所示：</p><div align="center"><img src="/2024/06/19/ram/18.png" width="80%/"></div></li></ul><h4 id="单端口-RAM-配置实验步骤"><a href="#单端口-RAM-配置实验步骤" class="headerlink" title="单端口 RAM 配置实验步骤"></a>单端口 RAM 配置实验步骤</h4><h5 id="一、创建工程"><a href="#一、创建工程" class="headerlink" title="一、创建工程"></a>一、创建工程</h5><ol><li>创建一个名为<code>ip_1port_ram</code>的空白工程，然后点击 Vivado 软件左侧<code>Flow Navigator</code>栏中的<code>IP Catalog</code>，如下图所示： <div align="center"><img src="/2024/06/19/ram/4.png" width="40%/"></div></li></ol><h5 id="二、搜索创建-BMG-IP核"><a href="#二、搜索创建-BMG-IP核" class="headerlink" title="二、搜索创建 BMG IP核"></a>二、搜索创建 BMG IP核</h5><ol start="2"><li>在<code>IP Catalog</code>窗口的搜索栏中输入<code>Block Memory</code>关键字后，出现唯一匹配的<code>Block Memory Generator</code>，如下图所示（图中出现的两个 IP 核为同一个 BMG IP 核）： <div align="center"><img src="/2024/06/19/ram/5.png" width="60%/"></div></li></ol><h5 id="三、配置-IP-核"><a href="#三、配置-IP-核" class="headerlink" title="三、配置 IP 核"></a>三、配置 IP 核</h5><ol start="3"><li>双击<code>Block Memory Generator</code>后弹出 IP 核的配置界面，对 BMG IP 核进行配置。</li></ol><ul><li><p><code>Basic</code>选项卡配置界面如下图所示:</p><div align="center"><img src="/2024/06/19/ram/6.png" width="100%/"></div></li><li><p>该选项卡下各参数（重点关注（2）和（3）中的内容）含义如下： </p><ol><li>最上面的 <code>Component Name</code>一栏可以设置该 IP 元件的名称，这里我们保持默认命名，当然也可以命名为其它方便自己一眼看出其功能的名称。 </li><li><code>lnterface Type（接口模式）</code>：有两种接口模式可选，分别为 <strong>Native（常规）接口</strong>和 <strong>AXI4 接口</strong>。AXI4 模式一般是在处理器中的数据需要和 BRAM 交互时才会使用，当不需要与处理器数据进行交互时，我们一般采用 Native 模式，所以本次实验我们选择 Native 模式。 </li><li><code>Memory Type（存储类型）</code>：有五种类型可选，分别为<code>Single Port RAM（单端口RAM）</code>、<code>Simple Dual Port RAM（伪双端口 RAM）</code>、<code>True Dual Port RAM（真双端口 RAM）</code>、<code>Single Port ROM（单端口 ROM）</code>和<code>Dual Port ROM（双端口 ROM）</code>，因为本节的试验任务是学习单端口 RAM，所以我们选择 <code>Single Port RAM</code>。</li><li><code>ECC（全称 Error Correcting Code，即纠错码） Options</code>，纠错码选项只有在伪双端口 RAM 类型下才可以进行配置。 </li><li><code>Write Enable（写使能）</code>：可以选择是否使用字节写使能功能，启用后可设置字节大小为 8 位（无奇偶校验）或 9 位（包括奇偶校验），需要注意的是启用后内存的数据位宽必须设置为所选字节大小的整数倍。这里我们不启用字节写使能功能。</li><li><code>Algorithm Options（算法选项）</code>：算法选项主要用于决定 BRAM 的拼接的方式，一般在BRAM 深度、宽度较大的时候起作用，有三种算法可选，分别为<code>Minimum Area（最小面积算法）</code>、<code>Low Power（低功耗算法）</code>和<code>Fixed Primitives（固定单元算法）</code>。这里我们保持默认即可</li><li><code>Generate address interface with 32 bits</code>选项为是否生成位宽为 32 的地址接口，勾选后内存的数据位宽必须设置成 32 的整数倍，在实际应用中，我们一般不做勾选。</li><li><code>Common Clock</code>选项为是否启用同步时钟，在单端口模式下不需要考虑这个问题，所以该选项也无法进行设置。</li></ol></li><li><p><code>Port A Options</code>选项卡配置界面如下图所示:</p><div align="center"><img src="/2024/06/19/ram/7.png" width="100%/"></div></li><li><p>该选项卡下各参数（重点关注（1）（2）（3）（4）中的内容）含义如下： </p><ol><li><code>Write Width</code>：写数据位宽，单位 bit，本次实验我们设置成 8，可设置的位宽范围为 1~4608。</li><li><code>Read Width</code>：读数据位宽，其位宽设置必须与写数据位宽存在倍数关系（倍数比仅支持 1：1、1：2、1：4、1：8、2：1、4：1、8：1 和 16：1），通常情况下读&#x2F;写数据位宽保持一致，所以这里设置成 8。</li><li><code>Write Depth</code>：写深度，这里设置成 32，即 RAM 所能访问的地址范围为 0~31。这里有一点需要大家注意，那就是写深度和写位宽的乘积不要超过器件本身的 ram 资源的大小，否则软件会报错。</li><li><code>Read Depth</code>：读深度，当写数据位宽、读数据位宽和写深度的值确定后，读深度的值就会自动确定。</li><li><ul><li><code>Operating Mode</code>：RAM 运作模式。该选项决定了我们在进行写操作期间，DOUT（读数据线）上的数据变化，有三种模式可选，分别为： <ol><li><p><code>Write First（写优先模式）</code>：当我们在对某个地址进行写操作时，则会将写入的数据传递到读数据线上。在写优先模式下，当 ENA（使能信号）为高后，第一个时钟上升沿 WEA（读&#x2F;写使能信号）为低电平，表示读数据，此时的地址为 aa，所以读出的就是 aa 内的数据；第二个时钟上升沿 WEA 为高电平，表示写数据，此时的地址为 bb，即先将数据（DAIN）“1111”写入地址 bb 后再读出，所以读出的数据也是“1111”；第三个时钟上升沿同理，将 DINA 数据写入存储器后再将更新后的数据送到 DOUTA 上进行输出；第四个时钟上升沿 WEA 为低电平，表示读数据，读取的就是地址 dd 内的数据。 </p><div align="center"><img src="/2024/06/19/ram/12.png" width="70%/"></div></li><li><p><code>Read First（读优先模式）</code>：当我们在对某个地址进行写操作时，则会将上次写入该地址的数据递到读数据线上。 在读优先模式下，当 ENA（使能信号）为高后，第一个时钟上升沿 WEA 为低电平，表示读数据，此时的地址为 aa，所以读出的就是 aa 内的数据；第二个时钟上升沿 WEA 为高电平，表示写数据，此时的地址为 bb，即先读出地址 bb 中的旧数据，然后再将数据（DAIN）“1111”写入地址 bb；第三个时钟上升沿同理，先将当前存储器中的旧数据送到 DOUTA 上进行输出，然后再将 DINA 数据写入当前存储地址；第四个时钟上升沿 WEA 为低电平，表示读数据，读取的就是地址 dd 内的数据。 </p><div align="center"><img src="/2024/06/19/ram/13.png" width="70%/"></div></li><li><p><code>No Change（不变模式）</code>：在该模式下，进行写操作时，读数据线上的数据保持不变。在不变模式下，当 ENA 和 WEA 同时为高时，只进行写操作，读数据保持不变，也就是说 DOUTA 保持前一拍数据，直到 WEA 为低。 </p><div align="center"><img src="/2024/06/19/ram/14.png" width="70%/"></div></li><li><p>总结一下就是在进行写操作时，读数据线（DOUT）上的数据在写优先模式和读优先模式下会随着地址的变化而输出相应的数据，在不变模式下则会保持最后一次读操作输出的数据。 </p></li><li><p>这里我们选择 No Change 模式。</p></li></ol></li><li><code>Enable Port Type</code>：使能端口类型。有两种可选，分别为 <code>Use ENA pin</code>（添加使能端口 A 信号）和 <code>Always Enabled</code>（取消使能信号，端口 A 一直处于使能状态），这里选择默认的 Use ENA pin。</li></ul></li><li><code>Port A Optional Output Register</code>：用于为 RAM 的输出端添加寄存器。其作用是提高 BRAM 的运行频率和改善时序，当然为此付出的代价就是每勾选一个寄存器，输出就会延迟一拍。其中： <ul><li><code>Primitives Output Register</code>，使用 BRAM 内部的寄存器打拍输出。 </li><li><code>Core Output Register</code>，使用 SLICE 的寄存器打拍输出。 </li><li><code>SoftECC Input Register</code>，当使用软 ECC 的时候，用 SLICE 的寄存器打拍。 </li><li><code>REGCEA</code>，当使用 Primitives Output Register 或者 Core Output Register 时，可以用 REGCEA 来使能相应的输出。 </li><li>本次实验中，建议生成 ip 的时候，取消 primitives output register 配置，这样我们在当前时钟周期发起读操作的话，在下一个时钟周期就可以读出有效数据了。</li></ul></li><li><code>Port A Output Reset Options</code>用于设置端口的复位信号，可以添加一个复位信号（RSTA Pin）、设置复位时 ram 输出总线上的数据值（Output Reset Value）、设置是否复位内置锁存器（Reset Memory Latch）和设置复位信号与时钟使能之间的优先级（Reset Priority），这里我们不需要添加，所以不做勾选。 </li><li><code>READ Address Change A</code>用于更改端口的读地址，这个功能只在 UltraScale 设备上使用，一般在某些低功耗场景中会应用到。</li></ol></li><li><p><code>Other Options</code>选项卡配置界面如下图所示:</p><div align="center"><img src="/2024/06/19/ram/8.png" width="100%/"></div></li><li><p>该选项卡下各参数含义如下： </p><ol><li><code>Pipeline Stages within Mux</code>，输出端 Mux 选择器的流水线级数。在大位宽、大深度的 BRAM 拼接场景中，我们会用 MUX 来选择输出地址所对应的数据，勾选该选项后可以使输出数据具有更好的时序。 </li><li><code>Memory Initialization（初始化文件）</code>，选择是否使用本地初始化文件（.coe 文件）来对存储空间进行初始化。 </li><li><code>Structural/UniSim Simulation Model Options</code>，用于选择结构仿真模型发生碰撞时生成的警告消息和输出的类型。 </li><li><code>Behavioral Simulation Model Options</code>，用于关闭仿真时的冲突告警和超出范围告警。</li></ol></li><li><p><code>Other Options</code>选项卡，用于设置 RAM 的初始值等信息</p></li><li><p><code>Summary</code>选项卡，该界面显示了我们配置的存储器的类型，消耗的 BRAM 资源等信息，我们直接点击<code>OK</code>按钮完成 BMG IP 核的配置，如下图所示： </p><div align="center"><img src="/2024/06/19/ram/9.png" width="70%/"></div></li></ul><h5 id="四、生成-IP-核"><a href="#四、生成-IP-核" class="headerlink" title="四、生成 IP 核"></a>四、生成 IP 核</h5><ol start="4"><li>配置完成后，弹出了<code>Generate Output Products</code>窗口，点击<code>Generate</code>按钮，开始生成 IP 核。<div align="center"><img src="/2024/06/19/ram/10.png" width="50%/"></div></li></ol><h5 id="五、等待综合"><a href="#五、等待综合" class="headerlink" title="五、等待综合"></a>五、等待综合</h5><ol start="5"><li>在<code>Design Run</code>窗口的<code>Out-of-Context Module Runs</code>一栏中看到该 IP 核对应的run <code>blk_mem_gen_0_synth_1</code>，其综合过程独立于顶层设计的综合，所以我们可以看到其正在综合，如下图所示： <div align="center"><img src="/2024/06/19/ram/11.png" width="60%/"></div></li></ol><h5 id="六、拷贝例化模板代码"><a href="#六、拷贝例化模板代码" class="headerlink" title="六、拷贝例化模板代码"></a>六、拷贝例化模板代码</h5><ol start="6"><li>综合完成后，便可开始编写代码。首先查看IP核的例化模板。在<code>Source</code> 窗口中的<code>IP Sources</code>选项卡中，依次用鼠标单击展开<code>IP</code>-<code>blk_mem_gen_0</code>-<code>Instantitation Template</code>，我们可以看到<code>blk_mem_gen_0.veo</code>文件，它是由 IP 核自动生成的只读的 verilog 例化模板文件，双击就可以打开它，在例化时钟 IP 核模块的时钟，可以直接从这里拷贝，如下图所示 :<div align="center"><img src="/2024/06/19/ram/16.png" width="100%/"></div></li></ol><h5 id="七、创建顶层模块"><a href="#七、创建顶层模块" class="headerlink" title="七、创建顶层模块"></a>七、创建顶层模块</h5><ol start="7"><li>本次实验除了调用 BMG IP 核外还需要例化一个读写模块（这里我们将其命名为 <code>ram_rw</code>），所以需要创建一个顶层模块来例化 IP 核与读写模块。创建源文件后，将顶层模块命名为 <code>ip_1port_ram</code>，代码如下：</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">ip_ram</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>         sys_clk <span class="token punctuation">,</span>  <span class="token comment">//系统时钟</span>    <span class="token keyword">input</span>         sys_rst_n  <span class="token comment">//系统复位，低电平有效</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//wire define</span>    <span class="token keyword">wire</span>             ram_en      <span class="token punctuation">;</span>  <span class="token comment">//RAM使能    </span>    <span class="token keyword">wire</span>             ram_wea      <span class="token punctuation">;</span>  <span class="token comment">//ram读写使能信号,高电平写入,低电平读出 </span>    <span class="token keyword">wire</span>    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    ram_addr    <span class="token punctuation">;</span>  <span class="token comment">//ram读写地址 </span>    <span class="token keyword">wire</span>    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    ram_wr_data <span class="token punctuation">;</span>  <span class="token comment">//ram写数据  </span>    <span class="token keyword">wire</span>    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    ram_rd_data <span class="token punctuation">;</span>  <span class="token comment">//ram读数据   </span><span class="token comment">//ram读写模块</span>ram_rw  <span class="token function">u_ram_rw</span><span class="token punctuation">(</span><span class="token punctuation">.</span>clk        <span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span>rst_n      <span class="token punctuation">(</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token punctuation">.</span>ram_en     <span class="token punctuation">(</span>ram_en     <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>ram_wea    <span class="token punctuation">(</span>ram_wea     <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>ram_addr   <span class="token punctuation">(</span>ram_addr   <span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ram_wr_data</span><span class="token punctuation">(</span>ram_wr_data<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token function">ram_rd_data</span><span class="token punctuation">(</span>ram_rd_data<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ram ip 核</span>blk_mem_gen_0 your_instance_name <span class="token punctuation">(</span>     <span class="token punctuation">.</span><span class="token function">clka</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input wire clka</span>     <span class="token punctuation">.</span>ena  <span class="token punctuation">(</span> ram_en     <span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// input wire ena</span>     <span class="token punctuation">.</span>wea  <span class="token punctuation">(</span> ram_wea     <span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// input wire [0 : 0] wea</span>     <span class="token punctuation">.</span><span class="token function">addra</span><span class="token punctuation">(</span> ram_addr   <span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// input wire [4 : 0] addra</span>     <span class="token punctuation">.</span>dina <span class="token punctuation">(</span> ram_wr_data<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input wire [7 : 0] dina</span>     <span class="token punctuation">.</span><span class="token function">douta</span><span class="token punctuation">(</span> ram_rd_data<span class="token punctuation">)</span>  <span class="token comment">// output wire [7 : 0] douta</span>   <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="八、创建读写模块"><a href="#八、创建读写模块" class="headerlink" title="八、创建读写模块"></a>八、创建读写模块</h5><ol start="8"><li><code>ram_rw</code> 模块用于产生 RAM 读&#x2F;写操作所需的信号，绘制大致的模块端口信号的波形图方便理解。</li></ol><div align="center"><img src="/2024/06/19/ram/19.png" width="100%/"></div><ul><li>当系统复位结束后，一直对 RAM 进行读写操作，所以 ram_en 在复位结束后一直处于使能状态。因为是读写 32 个数据，所以地址一直在 0<del>31 之间循环计数。接着我们用一个计数器（<code>rw_cnt</code>）循环计数 0</del>63，以此来对读写使能信号（<code>ram_we</code>）进行切换。当计数器值在 0<del>31 时进行写操作，写操作期间需要将 <code>ram_we</code> 置为高；当计数器值在 32</del>63 时进行读操作，读操作期间需要将 <code>ram_we</code> 置为低。 </li><li>在写操作期间，写数据（<code>ram_wr_data</code>）由 0 开始累加（步进为 1），直到累加值等于 31（即写入 32 个数据）时清零。而读数据只需要给出地址即可，需要注意的是读数据的输出会比地址晚一个时钟周期，当由读状态切换至写状态时，读数据会保持最后一次读出的数据。 </li><li>代码如下：</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">ram_rw</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>               clk        <span class="token punctuation">,</span>  <span class="token comment">//时钟信号</span>    <span class="token keyword">input</span>               rst_n      <span class="token punctuation">,</span>  <span class="token comment">//复位信号，低电平有效</span>        <span class="token keyword">output</span>               ram_en     <span class="token punctuation">,</span>      <span class="token comment">//ram使能信号</span>    <span class="token keyword">output</span>               ram_wea    <span class="token punctuation">,</span>     <span class="token comment">//ram读写选择</span>    <span class="token keyword">output</span>  <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   ram_addr   <span class="token punctuation">,</span>    <span class="token comment">//ram读写地址</span>    <span class="token keyword">output</span>  <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   ram_wr_data<span class="token punctuation">,</span>   <span class="token comment">//ram写数据</span>    <span class="token keyword">input</span>         <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  ram_rd_data   <span class="token comment">//ram读数据      </span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//reg define</span>    <span class="token keyword">reg</span>    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  rw_cnt <span class="token punctuation">;</span>                <span class="token comment">//读写控制计数器    </span><span class="token comment">//rw_cnt计数范围在0~31,写入数据;32~63时,读出数据</span><span class="token keyword">assign</span> ram_wea <span class="token operator">=</span> <span class="token punctuation">(</span>rw_cnt <span class="token operator">&lt;=</span> <span class="token number">6'd31</span> <span class="token operator">&amp;&amp;</span> ram_en <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>     <span class="token comment">//控制RAM使能信号</span><span class="token keyword">assign</span> ram_en <span class="token operator">=</span> rst_n<span class="token punctuation">;</span> <span class="token comment">//读写控制计数器,计数器范围0~63</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>rst_n <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>        rw_cnt <span class="token operator">&lt;=</span> <span class="token number">6'b0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>rw_cnt <span class="token operator">==</span> <span class="token number">6'd63</span>  <span class="token operator">&amp;&amp;</span> ram_en<span class="token punctuation">)</span>        rw_cnt <span class="token operator">&lt;=</span> <span class="token number">6'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ram_en<span class="token punctuation">)</span>        rw_cnt <span class="token operator">&lt;=</span> rw_cnt <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>     <span class="token keyword">else</span>        rw_cnt <span class="token operator">&lt;=</span> <span class="token number">6'b0</span><span class="token punctuation">;</span>      <span class="token keyword">end</span> <span class="token comment">//读写地址信号 范围：0~31</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>rst_n <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>        ram_addr <span class="token operator">&lt;=</span> <span class="token number">5'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ram_addr <span class="token operator">==</span> <span class="token number">5'd31</span> <span class="token operator">&amp;&amp;</span> ram_en<span class="token punctuation">)</span>        ram_addr <span class="token operator">&lt;=</span> <span class="token number">5'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ram_en<span class="token punctuation">)</span>           ram_addr <span class="token operator">&lt;=</span> ram_addr <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        ram_addr <span class="token operator">&lt;=</span> <span class="token number">5'b0</span><span class="token punctuation">;</span>         <span class="token keyword">end</span><span class="token comment">//在WE拉高期间产生RAM写数据,变化范围是0~31</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>rst_n <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>        ram_wr_data <span class="token operator">&lt;=</span> <span class="token number">8'b0</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ram_wr_data <span class="token operator">&lt;</span> <span class="token number">8'd31</span> <span class="token operator">&amp;&amp;</span> ram_wea<span class="token punctuation">)</span>        ram_wr_data <span class="token operator">&lt;=</span> ram_wr_data <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        ram_wr_data <span class="token operator">&lt;=</span> <span class="token number">8'b0</span> <span class="token punctuation">;</span>   <span class="token keyword">end</span>  <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模块中定义了一个读写控制计数器（<code>rw_cnt</code>），当计数范围在 0~31 之间时，向 ram 的 0 ~ 31 地址写入数据（0 ~ 31）；当计数范围在 32 ~ 63 之间时，从 ram 的 0 ~ 31 地址中读出数据。</li></ul><h5 id="九、引脚约束"><a href="#九、引脚约束" class="headerlink" title="九、引脚约束"></a>九、引脚约束</h5><ol start="9"><li>完成模块设计后，需要将模块的端口与 FPGA 的引脚进行约束。对应的 XDC 约束语句如下所示：</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">create_clock <span class="token operator">-</span>period <span class="token number">20.000</span> <span class="token operator">-</span>name sys_clk <span class="token punctuation">[</span>get_ports sys_clk<span class="token punctuation">]</span> set_property <span class="token operator">-</span>dict <span class="token operator">&#123;</span>PACKAGE_PIN R4 IOSTANDARD LVCMOS33<span class="token operator">&#125;</span> <span class="token punctuation">[</span>get_ports sys_clk<span class="token punctuation">]</span> set_property <span class="token operator">-</span>dict <span class="token operator">&#123;</span>PACKAGE_PIN U2 IOSTANDARD LVCMOS33<span class="token operator">&#125;</span> <span class="token punctuation">[</span>get_ports sys_rst_n<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="十、添加-ILA-IP-核"><a href="#十、添加-ILA-IP-核" class="headerlink" title="十、添加 ILA IP 核"></a>十、添加 ILA IP 核</h5><ol start="10"><li>添加 ILA IP 核，用于观察 RAM 的读写状态。同时，由于本次实验中没有使用输出端口，所以<code>ram_rd_data (ram读数据 )</code>没有输出，若是没有ILA IP 核用作其输出，在生成比特流时，vivado软件会报错，认为该程序为无效程序，如下图所示：<div align="center"><img src="/2024/06/19/ram/20.png" width="100%/"></div></li></ol><ul><li>添加 ILA IP 核，将 <code>ram_en</code>（1 位）、<code>ram_wea</code>（1 位）、<code>ram_addr</code>（5 位）、<code>ram_wr_data</code>（8 位）和 <code>ram_rd_data</code>（8 位）信号添加至观察列表中，添加 ILA IP 核的方法这里就不再赘述了，按如下图所示创建：</li></ul><div align="center"><img src="/2024/06/19/ram/21.png" width="90%/"></div><ul><li>本例程是将 ILA 例化在了 <code>ram_rw</code> 模块中，例化代码如下所示：<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ila_0 your_instance_name <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire clk</span><span class="token punctuation">.</span><span class="token function">probe0</span><span class="token punctuation">(</span>ram_en     <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe0  </span><span class="token punctuation">.</span><span class="token function">probe1</span><span class="token punctuation">(</span>ram_wea    <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe1 </span><span class="token punctuation">.</span><span class="token function">probe2</span><span class="token punctuation">(</span>ram_addr   <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [4:0]  probe2 </span><span class="token punctuation">.</span><span class="token function">probe3</span><span class="token punctuation">(</span>ram_wr_data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [7:0]  probe3 </span><span class="token punctuation">.</span><span class="token function">probe4</span><span class="token punctuation">(</span>ram_rd_data<span class="token punctuation">)</span> <span class="token comment">// input wire [7:0]  probe4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如图所示：<div align="center"><img src="/2024/06/19/ram/22.png" width="90%/"></div></li></ul><h5 id="十一、上板验证"><a href="#十一、上板验证" class="headerlink" title="十一、上板验证"></a>十一、上板验证</h5><ol start="11"><li>综合、实现、下载比特流后，在 FPGA 上验证 RAM 的读写功能。</li></ol><ul><li><p>RAM 写操作在 ILA 中观察到的波形如下图所示： </p><div align="center"><img src="/2024/06/19/ram/23.png" width="90%/"></div></li><li><p>由上图可知，<code>ram_wea</code> 信号拉高之后，地址和数据都从 0 开始累加，也就说当 ram 地址为 0 时，写入的数据也是 0；当 ram 地址为 1 时，写入的数据也是 1。可以发现，写操作的验证结果正确。 </p></li><li><p>RAM 读操作在 ILA 中观察到的波形如下图所示： </p><div align="center"><img src="/2024/06/19/ram/24.png" width="90%/"></div></li><li><p>由上图可知，<code>ram_wea</code> 信号拉低之后，<code>ram_addr</code> 从 0 开始增加，即从 ram 的地址 0 开始读数据；<code>ram_rd_data</code> 在给出地址的下一个时钟周期后，开始输出数据，输出的数据为 0，1，2……30，31，和我们写入的值是相等的。可以发现，读操作的验证结果正确。</p></li><li><p>至此说明了 IP 核之单端口 RAM 实验验证成功。</p></li></ul><h3 id="双端口-RAM-配置"><a href="#双端口-RAM-配置" class="headerlink" title="双端口 RAM 配置"></a>双端口 RAM 配置</h3><h4 id="双端口-RAM-配置基础知识"><a href="#双端口-RAM-配置基础知识" class="headerlink" title="双端口 RAM 配置基础知识"></a>双端口 RAM 配置基础知识</h4><ul><li><p>BMG IP 核配置成简单(伪)双端口 RAM 的框图：</p><div align="center"><img src="/2024/06/19/ram/25.png" width="70%/"></div></li><li><p>与单端口 RAM 对比：</p><ul><li>伪双端口 RAM 输入有两路时钟信号 CLKA&#x2F;CLKB；</li><li>独立的两组地址信号ADDRA&#x2F;ADDRB；</li><li>Port A 仅提供 DINA 写数据总线，作为数据的写入口；</li><li>Port B 仅提供数据读的功能，读出的数据为 DOUTB。</li></ul></li><li><p>各个新端口（这些信号很少使用，我们一般不用关注）的功能描述如下：</p><ul><li>INJECTSBITERR：Inject Single-Bit Error 的简写，即注入单 bit 错误，仅适用于 Xilinx Zynq-7000 和 7系列芯片的 ECC 配置。 </li><li>INJECTDBITERR：Inject Double-Bit Error 的简写，即注入双 bit 错误，同样仅适用于 Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。 </li><li>SBITERR：Single-Bit Error 的简写，即单 bit 错误，标记内存中存在的单 bit 错误，该错误已在输出总线上自动更正。 </li><li>DBITERR：Double-Bit Error 的简写，即双 bit 错误，标记内存中存在双 bit 错误，需要注意的是内置的ECC 解码模块不能自动纠正双 bit 错误。 </li><li>RDADDRECC：Read Address for ECC Error output 的简写，即读地址 ECC 错误输出，同样仅适用于Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。</li></ul></li><li><p>BMG IP 核配置成真双端口 RAM 的框图：</p><div align="center"><img src="/2024/06/19/ram/26.png" width="70%/"></div></li><li><p>真双端口 RAM 提供了两个独立的读写端口（A 和 B），既可以同时读，也可以同时写，也可以一个读一个写。通过框图对比可以发现，真双端口 RAM 只是将单端口 RAM 的所有信号做了一个复制处理，不同端口的同一信号以 A 和 B 作为区分</p></li><li><p>三种静态 RAM 的端口对比表：</p></li></ul><div align="center"><img src="/2024/06/19/ram/27.png" width="100%/"></div><ul><li><p><strong>注意</strong>，伪双端口模式下我们需要避免<strong>读写冲突</strong>；在真双端口模式下我们需要避免<strong>读写冲突</strong>和<strong>写写冲突</strong></p></li><li><p><strong>读写冲突</strong>：即同时刻读写同一地址所出现的冲突，例如理论上我们已经向某个地址写入了新的数据，我们也希望可以同时读到这个地址内新写入的数据，但实际上，这个新数据还没有写入 RAM 中，所以我们读出来的可能是 RAM 默认值，或者是 RAM 该地址中上一次的值，这便是读写冲突。</p></li></ul><div align="center"><img src="/2024/06/19/ram/28.png" width="70%/"></div><ul><li><p>由上图可知当发生读写冲突时，读优先的模式下读出的是读地址中存储的上一个数据；写优先模式时读出的是未知的数据“XX”。 </p></li><li><p><strong>写写冲突</strong>：表示两个端口写使能同时有效且写地址相同，此时需要关断一个写，把两个写端口都需要更新的值处理到一个写端口上。切记任何双端口 RAM 都不支持写写冲突。</p></li></ul><div align="center"><img src="/2024/06/19/ram/29.png" width="70%/"></div><ul><li>由上图可知当发生写写冲突时，发生冲突的地址写入的是未知的数据“XX”</li></ul><h4 id="双端口-RAM-设计思路"><a href="#双端口-RAM-设计思路" class="headerlink" title="双端口 RAM 设计思路"></a>双端口 RAM 设计思路</h4><h5 id="顶层模块设计-1"><a href="#顶层模块设计-1" class="headerlink" title="顶层模块设计"></a>顶层模块设计</h5><ul><li><strong>顶层模块设计</strong>：本节设计的是伪双端口 RAM 并对其进行读写操作。因为伪双端口的数据线，地址线及其他信号线都是相互独立的，所以这里我们将读写分为两个子模块，分别命名为 <code>ram_rd</code>（读模块）和 <code>ram_wr</code>（写模块）。同样系统时钟和系统复位信号不再赘述。</li><li>综上可得一个大致的模块框图：</li></ul><div align="center"><img src="/2024/06/19/ram/30.png" width="50%/"></div><h5 id="写模块设计"><a href="#写模块设计" class="headerlink" title="写模块设计"></a>写模块设计</h5><ul><li><p><strong>写模块设计</strong>：在 RAM 写模块中，我们的输入信号主要有<strong>系统时钟信号</strong>和<strong>系统复位信号</strong>；输出有控制写 RAM 所需的 <strong>写端口使能</strong><code>ram_wr_en</code>、<strong>写使能</strong><code>ram_wr_we</code>、<strong>写地址</strong><code>ram_wr_addr</code>和 <strong>写数据</strong><code>ram_wr_data</code>这四个信号，以及控制读模块启动 <strong>读启动</strong><code>rd_flag</code>信号。</p></li><li><p>经过上述分析可以得一个大致的模块框图，如下图所示：</p></li></ul><div align="center"><img src="/2024/06/19/ram/31.png" width="50%/"></div><ul><li>模块端口与功能描述如下表所示：</li></ul><div align="center"><img src="/2024/06/19/ram/32.png" width="80%/"></div><h5 id="读模块设计"><a href="#读模块设计" class="headerlink" title="读模块设计"></a>读模块设计</h5><ul><li><p><strong>读模块设计</strong>：在 RAM 读模块中，我们的输入信号主要有系<strong>统时钟信号</strong>、<strong>系统复位信号</strong>、从 RAM 中<strong>读出的数据</strong><code>ram_rd_data</code>以及我们自己定义的<strong>读启动标志信号</strong><code>rd_flag</code>；输出有控制读 RAM 所需的 <strong>读端口使能</strong><code>ram_rd_en</code>和 <strong>读地址</strong><code>ram_rd_addr</code>这两个信号。</p></li><li><p>经过上述分析可以得一个大致的模块框图，如下图所示：</p></li></ul><div align="center"><img src="/2024/06/19/ram/33.png" width="50%/"></div><ul><li>模块端口与功能描述如下表所示：</li></ul><div align="center"><img src="/2024/06/19/ram/34.png" width="80%/"></div><h4 id="双端口-RAM-配置实验步骤"><a href="#双端口-RAM-配置实验步骤" class="headerlink" title="双端口 RAM 配置实验步骤"></a>双端口 RAM 配置实验步骤</h4><h5 id="一、创建工程-1"><a href="#一、创建工程-1" class="headerlink" title="一、创建工程"></a>一、创建工程</h5><ol><li>创建一个名为<code>ip_2port_ram</code>的空白工程，然后点击 Vivado 软件左侧<code>Flow Navigator</code>栏中的<code>IP Catalog</code>，如下图所示： <div align="center"><img src="/2024/06/19/ram/4.png" width="40%/"></div></li></ol><h5 id="二、搜索创建-BMG-IP核-1"><a href="#二、搜索创建-BMG-IP核-1" class="headerlink" title="二、搜索创建 BMG IP核"></a>二、搜索创建 BMG IP核</h5><ol start="2"><li>在<code>IP Catalog</code>窗口的搜索栏中输入<code>Block Memory</code>关键字后，出现唯一匹配的<code>Block Memory Generator</code>，如下图所示（图中出现的两个 IP 核为同一个 BMG IP 核）： <div align="center"><img src="/2024/06/19/ram/5.png" width="60%/"></div></li></ol><h5 id="三、配置-IP-核-1"><a href="#三、配置-IP-核-1" class="headerlink" title="三、配置 IP 核"></a>三、配置 IP 核</h5><ol start="3"><li>双击<code>Block Memory Generator</code>后弹出 IP 核的配置界面，对 BMG IP 核进行配置。</li></ol><ul><li><code>Basic</code>选项卡配置界面如下图所示:</li></ul><div align="center"><img src="/2024/06/19/ram/35.png" width="90%/"></div><ul><li><p>本节是创建一个同步的伪双端口 RAM，所以<code>Memory Type（存储类型）</code>我们选择<code>Simple Dual Port RAM（伪双端口 RAM）</code>，并勾选<code>Common Clock（同步时钟）</code>选项</p></li><li><p><code>Port A Options</code>选项卡配置界面如下图所示:</p></li></ul><div align="center"><img src="/2024/06/19/ram/36.png" width="90%/"></div><ul><li><code>Port B Options</code>选项卡配置界面如下图所示:</li></ul><div align="center"><img src="/2024/06/19/ram/37.png" width="90%/"></div><ul><li>接下来是<code>Other Options</code>选项卡，同上一章一样，该选项卡无需配置，保存默认即可。 </li><li>最后一个是<code>Summary</code>选项卡，该界面显示了我们配置的存储器的类型，消耗的 BRAM 资源等信息，我们直接点击<code>OK</code>按钮完成 BMG IP 核的配置</li></ul><div align="center"><img src="/2024/06/19/ram/38.png" width="70%/"></div><h5 id="四、生成-IP-核-1"><a href="#四、生成-IP-核-1" class="headerlink" title="四、生成 IP 核"></a>四、生成 IP 核</h5><ol start="4"><li>配置完成后，弹出了<code>Generate Output Products</code>窗口，点击<code>Generate</code>按钮，开始生成 IP 核。<div align="center"><img src="/2024/06/19/ram/10.png" width="50%/"></div></li></ol><h5 id="五、等待综合-1"><a href="#五、等待综合-1" class="headerlink" title="五、等待综合"></a>五、等待综合</h5><ol start="5"><li>在<code>Design Run</code>窗口的<code>Out-of-Context Module Runs</code>一栏中看到该 IP 核对应的run <code>blk_mem_gen_0_synth_1</code>，其综合过程独立于顶层设计的综合，所以我们可以看到其正在综合，如下图所示： <div align="center"><img src="/2024/06/19/ram/11.png" width="60%/"></div></li></ol><h5 id="六、拷贝例化模板代码-1"><a href="#六、拷贝例化模板代码-1" class="headerlink" title="六、拷贝例化模板代码"></a>六、拷贝例化模板代码</h5><ol start="6"><li>综合完成后，便可开始编写代码。首先查看IP核的例化模板。在<code>Source</code> 窗口中的<code>IP Sources</code>选项卡中，依次用鼠标单击展开<code>IP</code>-<code>blk_mem_gen_0</code>-<code>Instantitation Template</code>，我们可以看到<code>blk_mem_gen_0.veo</code>文件，它是由 IP 核自动生成的只读的 verilog 例化模板文件，双击就可以打开它，在例化时钟 IP 核模块的时钟，可以直接从这里拷贝，如下图所示 :<div align="center"><img src="/2024/06/19/ram/39.png" width="100%/"></div></li></ol><h5 id="七、创建顶层模块-1"><a href="#七、创建顶层模块-1" class="headerlink" title="七、创建顶层模块"></a>七、创建顶层模块</h5><ol><li>本次实验除了调用 BMG IP 核外还需要例化两个子模块，分别命名为 <code>ram_rd</code>（读模块）和 <code>ram_wr</code>（写模块），所以需要创建一个顶层模块来例化 IP 核与读&#x2F;写模块。创建源文件后，将顶层模块命名为 <code>ip_2port_ram</code>，代码如下：</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">ip_2port_ram</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>       sys_clk    <span class="token punctuation">,</span>  <span class="token comment">//系统时钟</span>    <span class="token keyword">input</span>       sys_rst_n     <span class="token comment">//系统复位，低电平有效</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//wire define    </span><span class="token keyword">wire</span>        ram_wr_we   <span class="token punctuation">;</span><span class="token comment">//ram端口A写使能  </span><span class="token keyword">wire</span>        ram_wr_en   <span class="token punctuation">;</span><span class="token comment">//端口A使能</span><span class="token keyword">wire</span>        rd_flag     <span class="token punctuation">;</span><span class="token comment">//读启动标志</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram_wr_addr <span class="token punctuation">;</span><span class="token comment">//ram写地址</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram_wr_data <span class="token punctuation">;</span><span class="token comment">//ram写数据</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram_rd_data <span class="token punctuation">;</span><span class="token comment">//ram读地址</span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram_rd_addr <span class="token punctuation">;</span><span class="token comment">//ram读数据</span><span class="token keyword">wire</span>        ram_rd_en   <span class="token punctuation">;</span><span class="token comment">//端口B使能</span><span class="token comment">//简单双端口RAM</span>blk_mem_gen_0 your_instance_name <span class="token punctuation">(</span>  <span class="token punctuation">.</span>clka <span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input wire clka</span>  <span class="token punctuation">.</span>ena  <span class="token punctuation">(</span>ram_wr_en<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// input wire ena</span>  <span class="token punctuation">.</span>wea  <span class="token punctuation">(</span>ram_wr_we<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// input wire [0 : 0] wea</span>  <span class="token punctuation">.</span><span class="token function">addra</span><span class="token punctuation">(</span>ram_wr_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// input wire [5 : 0] addra</span>  <span class="token punctuation">.</span>dina <span class="token punctuation">(</span>ram_wr_data<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input wire [7 : 0] dina</span>  <span class="token punctuation">.</span>clkb <span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input wire clkb</span>  <span class="token punctuation">.</span>enb  <span class="token punctuation">(</span>ram_rd_en<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// input wire enb</span>  <span class="token punctuation">.</span><span class="token function">addrb</span><span class="token punctuation">(</span>ram_rd_addr <span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// input wire [5 : 0] addrb</span>  <span class="token punctuation">.</span><span class="token function">doutb</span><span class="token punctuation">(</span> ram_rd_data<span class="token punctuation">)</span>  <span class="token comment">// output wire [7 : 0] doutb</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//RAM写模块</span>ram_wr <span class="token function">ram_wr_u</span><span class="token punctuation">(</span>        <span class="token punctuation">.</span>clk          <span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>rst_n        <span class="token punctuation">(</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token punctuation">.</span>ram_wr_we    <span class="token punctuation">(</span>ram_wr_we  <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>ram_wr_en    <span class="token punctuation">(</span>ram_wr_en  <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>rd_flag      <span class="token punctuation">(</span>rd_flag    <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>ram_wr_addr  <span class="token punctuation">(</span>ram_wr_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>ram_wr_data  <span class="token punctuation">(</span>ram_wr_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//RAM读模块 </span>ram_rd <span class="token function">ram_rd_u</span><span class="token punctuation">(</span>    <span class="token punctuation">.</span>clk           <span class="token punctuation">(</span>sys_clk    <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>rst_n         <span class="token punctuation">(</span>sys_rst_n  <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>rd_flag       <span class="token punctuation">(</span>rd_flag    <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>ram_rd_en     <span class="token punctuation">(</span>ram_rd_en  <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>ram_rd_addr   <span class="token punctuation">(</span>ram_rd_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>ram_rd_data   <span class="token punctuation">(</span>ram_rd_data<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="八、创建写模块"><a href="#八、创建写模块" class="headerlink" title="八、创建写模块"></a>八、创建写模块</h5><ol start="8"><li><code>ram_wr</code> 模块用于产生 RAM 写操作所需的信号，绘制大致的模块端口信号的波形图方便理解。</li></ol><div align="center"><img src="/2024/06/19/ram/40.png" width="90%/"></div><ul><li><p>因为需要一直向 RAM 中写入数据，所以当复位结束后，就将 <code>ram_wr_en</code>（写端口使能）和 <code>ram_wr_we</code>（ram 写使能）一直置为高。当写使能拉高后，写地址一直在 0 ~ 63 之间循环计数，并向对应的RAM 地址中写入数据，当写地址第一次计数到 31 时，将 <code>rd_flag</code> 信号拉高并保持，以启动读模块进行读操作。 </p></li><li><p>代码如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">ram_wr</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>            clk         <span class="token punctuation">,</span> <span class="token comment">//时钟信号</span>    <span class="token keyword">input</span>            rst_n       <span class="token punctuation">,</span> <span class="token comment">//复位信号，低电平有效</span>                                        <span class="token comment">//RAM写端口操作                </span>    <span class="token keyword">output</span>           ram_wr_we   <span class="token punctuation">,</span> <span class="token comment">//ram写使能</span>    <span class="token keyword">output</span>           ram_wr_en   <span class="token punctuation">,</span> <span class="token comment">//端口使能</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span>       rd_flag     <span class="token punctuation">,</span> <span class="token comment">//读启动信号</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram_wr_addr <span class="token punctuation">,</span> <span class="token comment">//ram写地址        </span>    <span class="token keyword">output</span>     <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram_wr_data   <span class="token comment">//ram写数据   </span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//控制RAM使能信号</span><span class="token keyword">assign</span> ram_wr_en <span class="token operator">=</span> rst_n<span class="token punctuation">;</span>   <span class="token comment">//ram_wr_we为高电平表示写数据</span><span class="token keyword">assign</span> ram_wr_we <span class="token operator">=</span> ram_wr_en <span class="token punctuation">;</span><span class="token comment">//写数据与写地址相同，因位宽不等，所以高位补0</span><span class="token keyword">assign</span> ram_wr_data <span class="token operator">=</span> <span class="token operator">&#123;</span><span class="token number">2'b0</span><span class="token punctuation">,</span>ram_wr_addr<span class="token operator">&#125;</span> <span class="token punctuation">;</span><span class="token comment">//写地址信号 范围:0~63        </span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>                ram_wr_addr <span class="token operator">&lt;=</span> <span class="token number">6'd0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ram_wr_addr <span class="token operator">&lt;</span> <span class="token number">6'd63</span> <span class="token operator">&amp;&amp;</span> ram_wr_we<span class="token punctuation">)</span>        ram_wr_addr <span class="token operator">&lt;=</span> ram_wr_addr <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        ram_wr_addr <span class="token operator">&lt;=</span> <span class="token number">6'd0</span><span class="token punctuation">;</span><span class="token keyword">end</span>  <span class="token comment">//当写入32个数据（0~31）后，拉高读启动信号</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>        rd_flag <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ram_wr_addr <span class="token operator">==</span> <span class="token number">6'd31</span><span class="token punctuation">)</span>          rd_flag <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        rd_flag <span class="token operator">&lt;=</span> rd_flag<span class="token punctuation">;</span><span class="token keyword">end</span>    <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="九、创建读模块"><a href="#九、创建读模块" class="headerlink" title="九、创建读模块"></a>九、创建读模块</h5><ol start="9"><li><code>ram_rd</code> 模块用于产生 RAM 读操作所需的信号，绘制大致的模块端口信号的波形图方便理解。</li></ol><div align="center"><img src="/2024/06/19/ram/41.png" width="90%/"></div><ul><li><p>因为需要一直从 RAM 中读出数据，所以当复位结束且读启动信号拉高后，就将 <code>ram_rd_en</code> （读端口使能）一直置为高。当读端口使能后，读地址就会一直在 0 ~ 63 之间循环计数，并读出对应 RAM 地址中的数据，需要注意的是读数据的输出会比读地址晚一个时钟周期。 </p></li><li><p>代码如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">ram_rd</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>            clk         <span class="token punctuation">,</span> <span class="token comment">//时钟信号</span>    <span class="token keyword">input</span>            rst_n       <span class="token punctuation">,</span> <span class="token comment">//复位信号，低电平有效</span>        <span class="token comment">//RAM读端口操作   </span>    <span class="token keyword">input</span>             rd_flag     <span class="token punctuation">,</span> <span class="token comment">//读启动标志</span>    <span class="token keyword">input</span>       <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram_rd_data <span class="token punctuation">,</span><span class="token comment">//ram读数据</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  ram_rd_addr <span class="token punctuation">,</span><span class="token comment">//ram读地址     </span>    <span class="token keyword">output</span>            ram_rd_en   <span class="token comment">//端口使能</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//控制RAM使能信号</span><span class="token keyword">assign</span> ram_rd_en <span class="token operator">=</span> rd_flag<span class="token punctuation">;</span>  <span class="token comment">//读地址信号 范围:0~63        </span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>                ram_rd_addr <span class="token operator">&lt;=</span> <span class="token number">6'd0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ram_rd_addr <span class="token operator">&lt;</span> <span class="token number">6'd63</span> <span class="token operator">&amp;&amp;</span> ram_rd_en<span class="token punctuation">)</span>        ram_rd_addr <span class="token operator">&lt;=</span> ram_rd_addr <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        ram_rd_addr <span class="token operator">&lt;=</span> <span class="token number">6'd0</span><span class="token punctuation">;</span><span class="token keyword">end</span>   <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="十、引脚约束"><a href="#十、引脚约束" class="headerlink" title="十、引脚约束"></a>十、引脚约束</h5><ol start="10"><li>完成模块设计后，需要将模块的端口与 FPGA 的引脚进行约束。对应的 XDC 约束语句如下所示：</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">create_clock <span class="token operator">-</span>period <span class="token number">20.000</span> <span class="token operator">-</span>name sys_clk <span class="token punctuation">[</span>get_ports sys_clk<span class="token punctuation">]</span> set_property <span class="token operator">-</span>dict <span class="token operator">&#123;</span>PACKAGE_PIN R4 IOSTANDARD LVCMOS33<span class="token operator">&#125;</span> <span class="token punctuation">[</span>get_ports sys_clk<span class="token punctuation">]</span> set_property <span class="token operator">-</span>dict <span class="token operator">&#123;</span>PACKAGE_PIN U2 IOSTANDARD LVCMOS33<span class="token operator">&#125;</span> <span class="token punctuation">[</span>get_ports sys_rst_n<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="十一、添加-ILA-IP-核"><a href="#十一、添加-ILA-IP-核" class="headerlink" title="十一、添加 ILA IP 核"></a>十一、添加 ILA IP 核</h5><ol start="11"><li>添加两个 ILA IP 核，用于观察 RAM 的读&#x2F;写状态</li></ol><ul><li><p>ILA IP 核，将 <code>ram_wr_en</code>（1 位）、<code>ram_wr_we</code>（1 位）、<code>ram_rd_en</code>（1 位）、<code>rd_flag</code>（1 位）、<code>ram_wr_addr</code>（6 位）、<code>ram_wr_data</code>（8 位）、<code>ram_rd_addr</code>（6 位）和 <code>ram_rd_data</code>（8 位）信号添加至观察列表中</p></li><li><p>本例程是将 ILA 例化在了 <code>ip_2port_ram</code> 模块中，例化代码如下所示：</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">ila_0 ila_0_u <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire clk</span><span class="token punctuation">.</span><span class="token function">probe0</span><span class="token punctuation">(</span>ram_wr_we<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe0  </span><span class="token punctuation">.</span><span class="token function">probe1</span><span class="token punctuation">(</span>ram_wr_en<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe1 </span><span class="token punctuation">.</span><span class="token function">probe2</span><span class="token punctuation">(</span>rd_flag  <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe2 </span><span class="token punctuation">.</span><span class="token function">probe3</span><span class="token punctuation">(</span>ram_rd_en<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [0:0]  probe3 </span><span class="token punctuation">.</span><span class="token function">probe4</span><span class="token punctuation">(</span>ram_wr_addr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [5:0]  probe4 </span><span class="token punctuation">.</span><span class="token function">probe5</span><span class="token punctuation">(</span>ram_wr_data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [7:0]  probe5 </span><span class="token punctuation">.</span><span class="token function">probe6</span><span class="token punctuation">(</span>ram_rd_addr <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input wire [5:0]  probe6 </span><span class="token punctuation">.</span><span class="token function">probe7</span><span class="token punctuation">(</span> ram_rd_data<span class="token punctuation">)</span> <span class="token comment">// input wire [7:0]  probe7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="十二、上板验证"><a href="#十二、上板验证" class="headerlink" title="十二、上板验证"></a>十二、上板验证</h5><ul><li>综合、实现、下载比特流后，在 FPGA 上验证 简单双端RAM 的读写功能。</li><li>双端口 ram 的读写在 ILA 中观察到的波形如下图所示：</li></ul><div align="center"><img src="/2024/06/19/ram/42.png" width="50%/"><img src="/2024/06/19/ram/43.png" width="100%/"><img src="/2024/06/19/ram/44.png" width="90%/"></div><ul><li>由上图可知，读写端口和读端口能够同时对 ram 进行相应的操作，且没有发生读写冲突现象，至此说明了 IP 核之双端口 RAM 实验验证成功。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之IP核 MMCM/PLL</title>
      <link href="/2024/06/17/mmcm/"/>
      <url>/2024/06/17/mmcm/</url>
      
        <content type="html"><![CDATA[<h1 id="IP核之-MMCM-PLL"><a href="#IP核之-MMCM-PLL" class="headerlink" title="IP核之 MMCM&#x2F;PLL"></a>IP核之 MMCM&#x2F;PLL</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Clock IP核（Clock IP Core）是FPGA设计中一种用于时钟管理和生成的预设计模块。Clock IP核通常由FPGA厂商提供，旨在简化时钟信号的处理和管理，满足设计对时钟信号的各种需求。</li><li>Clock在时序逻辑的设计中是不可或缺的，同时对于Clock的编写和优化也能体现一个FPGA工程师的技术水平。熟练使用Clock IP核是学习FPGA的基础，需要熟练掌握。</li></ul><h2 id="何为Clock-IP-核"><a href="#何为Clock-IP-核" class="headerlink" title="何为Clock IP 核"></a>何为Clock IP 核</h2><h3 id="Clock-IP核的功能"><a href="#Clock-IP核的功能" class="headerlink" title="Clock IP核的功能"></a>Clock IP核的功能</h3><ul><li>Clock IP核可以实现以下功能：<ol><li><strong>时钟分频</strong>：将输入时钟信号分频生成较低频率的时钟信号。</li><li><strong>时钟倍频</strong>：将输入时钟信号倍频生成较高频率的时钟信号。</li><li><strong>相位偏移</strong>：调整时钟信号的相位，使其满足特定的时序要求。</li><li><strong>多输出时钟</strong>：生成多个不同频率、不同相位的时钟信号。</li><li><strong>时钟缓冲</strong>：增强时钟信号的驱动能力，确保时钟信号在FPGA内部和外部传输过程中不失真。</li><li><strong>时钟门控</strong>：根据设计需求动态启用或禁用时钟信号，减少功耗。</li><li><strong>时钟复位和启动控制</strong>：提供对时钟信号的复位和启动控制，确保系统可靠启动和运行。</li></ol></li></ul><h3 id="常见的Clock-IP核"><a href="#常见的Clock-IP核" class="headerlink" title="常见的Clock IP核"></a>常见的Clock IP核</h3><ol><li><strong>PLL</strong>（Phase-Locked Loop，锁相环）：<ul><li>用于生成稳定且低抖动的时钟信号。</li><li>支持时钟倍频、分频、相位调整等功能。</li></ul></li><li><strong>MMCM</strong>（Mixed-Mode Clock Manager，混合模式时钟管理器）：<ul><li>提供更高级的时钟管理功能，支持更多的输出时钟信号。</li><li>可用于实现复杂的时钟生成和管理需求。</li></ul></li><li><strong>BUFG</strong>（Global Clock Buffer，全局时钟缓冲）：<ul><li>提供高驱动能力的全局时钟缓冲，用于驱动FPGA内部的大量逻辑单元。</li></ul></li><li><strong>DCM</strong>（Digital Clock Manager，数字时钟管理器）：<ul><li>提供时钟分频、倍频和相位调整等基本功能。</li></ul></li></ol><h3 id="相关概念的详情介绍"><a href="#相关概念的详情介绍" class="headerlink" title="相关概念的详情介绍"></a>相关概念的详情介绍</h3><h4 id="1-CMT"><a href="#1-CMT" class="headerlink" title="1. CMT"></a>1. CMT</h4><ul><li>CMT(Clock Management Tile)：时钟管理器，包含了DCM&#x2F;PLL&#x2F;DCM等</li><li>Xilinx 7 系列器件中具有时钟管理单元 CMT 时钟资源，xc7a35t 芯片内部有 5 个 CMT，xc7a100t 芯片内部有 6 个 CMT，xc7a200t 芯片内部有 10 个 CMT，为设备提供强大的系统时钟管理以及高速 I&#x2F;O 通信的能力。时钟管理单元 CMT 的总体框图如下图所示。</li></ul><div align="center"><img src="/2024/06/17/mmcm/1.png" width="70%/"></div><ul><li>MMCM&#x2F;PLL 的参考时钟输入可以是 IBUFG(CC)即具有时钟能力的 IO 输入、区域时钟 BUFR、全局时钟 BUFG、GT 收发器输出时钟、行时钟 BUFH 以及本地布线（不推荐使用本地布线来驱动时钟资源）。在最多的情况下，MMCM&#x2F;PLL 的参考时钟输入都是来自 IBUFG(CC)即具有时钟能力的 IO 输入，本实验也是如此。MMCM&#x2F;PLL 的输出可以驱动全局时钟 BUFG 和行时钟 BUFH 等等。BUFG 能够驱动整个器件内部的通用逻辑的所有时序单元的时钟端口。BUFG&#x2F;BUFH&#x2F;CMT 在一个时钟区域内的连接框图如下图所示。</li></ul><div align="center"><img src="/2024/06/17/mmcm/2.png" width="80%/"></div><h4 id="2-时钟缓冲器（Buffer）"><a href="#2-时钟缓冲器（Buffer）" class="headerlink" title="2. 时钟缓冲器（Buffer）"></a>2. 时钟缓冲器（Buffer）</h4><ul><li><p>从前文可知，时钟缓冲器（Buffer）是时钟管理单元 CMT 的一个重要组成部分。下面将介绍最常用的三种时钟缓冲器：IBUFG(CC)、BUFR 和 BUFG，并总结三者区别</p></li><li><p><strong>IBUFG(CC) - 输入时钟缓冲器</strong></p><ul><li>功能：<ul><li>IBUFG (Input BUFG) 是输入时钟缓冲器，用于将外部时钟信号引入FPGA内部。</li></ul></li><li>特点：<ul><li>将输入时钟信号引入FPGA的全局时钟网络。</li><li>通常用于将来自板级的时钟信号（例如来自晶振或其他时钟源）直接传递给FPGA内部。</li></ul></li><li>应用：<ul><li>用于将外部时钟信号可靠地引入FPGA，以便在内部进一步处理或分配。</li><li>提供稳定的时钟信号，避免外部噪声和信号失真。</li></ul></li></ul></li><li><p><strong>BUFR - 区域时钟缓冲器</strong></p><ul><li>功能：<ul><li>BUFR (Regional Clock Buffer) 是区域时钟缓冲器，用于在FPGA的特定区域内分配时钟信号。</li></ul></li><li>特点：<ul><li>仅限于在FPGA的一个区域（通常是一个时钟区域或时钟域）内分配时钟信号。</li><li>支持时钟分频，可以根据需要对时钟信号进行分频。</li></ul></li><li>应用：<ul><li>用于需要在FPGA的特定区域内驱动时钟信号的应用场景。</li><li>适用于局部时钟需求，例如一个逻辑模块或区域内的时钟分配。</li></ul></li></ul></li><li><p><strong>BUFG - 全局时钟缓冲器</strong></p><ul><li>功能：<ul><li>BUFG (Global Clock Buffer) 是全局时钟缓冲器，用于在整个FPGA芯片范围内分配时钟信号。</li></ul></li><li>特点：<ul><li>能够驱动FPGA内部的全局时钟网络，将时钟信号分配到整个FPGA芯片的所有逻辑单元。</li><li>提供高驱动能力，确保时钟信号在全局范围内稳定传播。</li></ul></li><li>应用：<ul><li>用于需要在整个FPGA范围内分配时钟信号的应用场景。</li><li>适用于驱动全局时钟、复位信号或其他需要全局分配的重要控制信号。</li></ul></li></ul></li><li><p><strong>区别总结</strong></p><ul><li><p>作用范围：</p><ul><li>IBUFG(CC)：用于将外部时钟信号引入FPGA。</li><li>BUFR：用于在FPGA的特定区域内分配时钟信号。</li><li>BUFG：用于在整个FPGA芯片范围内分配时钟信号。</li></ul></li><li><p>功能和用途：</p><ul><li>IBUFG(CC)：引入并稳定外部时钟信号。</li><li>BUFR：局部区域时钟分配，支持时钟分频。</li><li>BUFG：全局时钟分配，高驱动能力。</li></ul></li><li><p>适用场景：</p><ul><li>IBUFG(CC)：连接外部时钟源到FPGA内部。</li><li>BUFR：特定区域内的时钟需求，如分频或区域性时钟信号。</li><li>BUFG：全局时钟需求，如同步全局逻辑单元的时钟信号。</li></ul></li></ul></li></ul><h4 id="3-MMCM和PLL"><a href="#3-MMCM和PLL" class="headerlink" title="3. MMCM和PLL"></a>3. MMCM和PLL</h4><ul><li><p>由上文介绍我们知道对于 Xilinx 7 系列的芯片一个 CMT 由一个 MMCM 和一个 PLL 组成。下面我们分别来看两者的关系。 </p></li><li><p><strong>PLL(Phase Locked Loop)</strong> ：</p><ul><li>为<strong>锁相回路</strong>或<strong>锁相环</strong>，用来统一整合时钟信号，使高频器件正常工作，如内存的存取资料等。PLL用于振荡器中的反馈技术。 许多电子设备要正常工作，通常需要外部的输入信号与内部的振荡信号同步。一般的晶振由于工艺与成本原因，做不到很高的频率，而在需要高频应用时，由相应的器件VCO，实现转成高频，但并不稳定，故利用锁相环路就可以实现稳定且高频的时钟信号。其具有时钟倍频、分频、相位偏移和可编程占空比的功能。</li><li><img src="/2024/06/17/mmcm/3.png"></li></ul></li><li><p>**MMCM(Mixed Mode Clock Manager)**：</p><ul><li>混合模式时钟管理器， MMCM 功能是 PLL 的超集 ,在PLL的基础上加上了相位动态调整功能，因为PLL是模块电路，而动态调相是数字电路，所以叫Mixed Mode。MMCM是在Virtex-6中被引入的，而且Virtex-6中也只有MMCM。</li><li><img src="/2024/06/17/mmcm/4.png"></li></ul></li><li><p>由MMCM和PLL结构图我们可以直观看到MMCM和PLL的组成结构基本相同。</p></li><li><p>MMCM（ Mixed-Mode Clock Manager）混合模式时钟管理器， MMCM 功能是 PLL 的超集，它是在 PLL的基础上加了相位动态调整功能， PLL 是模拟的，而动态调相是数字电路，所以称为混合模式。其相对于 PLL 的优势是相位可以动态调整，占用面积较大。 MMCM 主要用于驱动器件逻辑（ CLB、 DSP、 RAM 等）的时钟。 PLL 是和 IO 资源紧密绑定的，占用面积小，常用于为内存接口生成所需的时钟信号，但也具有与其他器件逻辑的连接，因此如果需要额外的功能，它们可以用作额外的时钟资源。</p></li></ul><h2 id="IP-核配置实验步骤"><a href="#IP-核配置实验步骤" class="headerlink" title="IP 核配置实验步骤"></a>IP 核配置实验步骤</h2><h3 id="一、创建工程"><a href="#一、创建工程" class="headerlink" title="一、创建工程"></a>一、创建工程</h3><ol><li>打开 Vivado，新建一个工程。工程名为<code>ip_clk_wiz</code>。接下来添加 PLL IP 核。在 Vivado 软件的左侧<code>Flow Navigator</code>栏中单击<code>IP Catalog</code><div align="center"><img src="/2024/06/17/mmcm/5.png" width="40%/"></div></li></ol><h3 id="二、搜索创建CLOCK-IP"><a href="#二、搜索创建CLOCK-IP" class="headerlink" title="二、搜索创建CLOCK IP"></a>二、搜索创建CLOCK IP</h3><ol start="2"><li>打开<code>IP Catalog</code>窗口后，在搜索栏中输入<code>clock</code>关键字，可以看到 Vivado 已经自动查找出了与关键字匹配的 IP 核名称，如下图所示。双击<code>FPGA Features and Design</code>→<code>Clocking”下的“Clocking Wizard</code><div align="center"><img src="/2024/06/17/mmcm/6.png" width="80%/"></div></li></ol><h3 id="三、配置-IP-核"><a href="#三、配置-IP-核" class="headerlink" title="三、配置 IP 核"></a>三、配置 IP 核</h3><ol start="3"><li>弹出 <code>Customize IP</code> 窗口，开始配置 IP 核</li></ol><ul><li><p>最上面的<code>Component Name</code>一栏设置该 IP 元件的名称，这里保持默认即可。在第一个<code>Clocking Options</code>选项卡中，<code>Primitive</code>选项用于选择是使用 MMCM 还是 PLL 来输出不同的时钟，对于我们的本次实验来说，MMCM 和 PLL 都可以完成，这里我们可以保持默认选择 MMCM。需要修改的是最下面的<code>Input Clock Information</code>一栏，把<code>Primary</code>时钟的输入频率修改为我们开发板的开发板上的晶振频率 50MHz，其他的设置保持默认即可，如下图所示。 </p><div align="center"><img src="/2024/06/17/mmcm/7.png" width="100%/"></div></li><li><p>接下来切换至<code>Output Clocks</code>选项卡，在<code>Output Clock</code>选项卡中，勾选前 4 个时钟，并且将其<code>Output Freq(MHz)</code>分别设置为 100、 100、 50、 25，注意，第 2 个 100MHz 时钟的相移<code>Phase(degrees)</code>一栏要设置为 180。其他设置保持默认即可，如下图所示：</p><div align="center"><img src="/2024/06/17/mmcm/8.png" width="100%/"></div></li><li><p><code>Port Renaming</code>选项卡主要是对一些控制信号的重命名。这里我们只用到了锁定指示 locked 信号，其名称保持默认即可，如下图所示。 </p><div align="center"><img src="/2024/06/17/mmcm/9.png" width="80%/"></div></li><li><p><code>MMCM Setting</code>选项卡展示了对整个 MMCM&#x2F;PLL 的最终配置参数，这些参数都是根据之前用户输入的时钟需求由 Vivado 来自动配置，Vivado 已经对参数进行了最优的配置，在绝大多数情况下都不需要用户对它们进行更改，也不建议更改，所以这一步保持默认即可，如下图所示。 </p><div align="center"><img src="/2024/06/17/mmcm/10.png" width="80%/"></div></li><li><p>最后的<code>Summary</code>选项卡是对前面所有配置的一个总结，在这里我们直接点击<code>OK</code>按钮即可，如下图所示。 </p><div align="center"><img src="/2024/06/17/mmcm/11.png" width="80%/"></div></li></ul><h3 id="四、生成-IP-核"><a href="#四、生成-IP-核" class="headerlink" title="四、生成 IP 核"></a>四、生成 IP 核</h3><ol start="4"><li>配置完成后，弹出了<code>Generate Output Products</code>窗口，点击<code>Generate</code>按钮，开始生成 IP 核。<div align="center"><img src="/2024/06/17/mmcm/12.png" width="50%/"></div></li></ol><h3 id="五、等待综合"><a href="#五、等待综合" class="headerlink" title="五、等待综合"></a>五、等待综合</h3><ol start="5"><li>在<code>Design Run</code>窗口的<code>Out-of-Context Module Runs</code>一栏中出现了该 IP 核对应的 run <code>clk_wiz_0_synth_1</code>，其综合过程独立于顶层设计的综合，所以在我们可以看到其正在综合，如下图所示。 <div align="center"><img src="/2024/06/17/mmcm/13.png" width="60%/"></div></li></ol><h3 id="六、拷贝例化模板代码"><a href="#六、拷贝例化模板代码" class="headerlink" title="六、拷贝例化模板代码"></a>六、拷贝例化模板代码</h3><ol start="6"><li>综合完成后，便可开始编写代码。首先查看IP核的例化模板。在<code>Source</code> 窗口中的<code>IP Sources</code>选项卡中，依次用鼠标单击展开<code>IP</code>-<code>clk_wiz_0</code>-<code>Instantitation Template</code>，我们可以看到<code>clk_wiz.veo</code>文件，它是由 IP 核自动生成的只读的 verilog 例化模板文件，双击就可以打开它，在例化时钟 IP 核模块的时钟，可以直接从这里拷贝，如下图所示 :</li></ol><div align="center"><img src="/2024/06/17/mmcm/14.png" width="90%/"></div><ul><li>模板文件里有例化 IP 核的模板，如下所示：<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">clk_wiz_0 instance_name  <span class="token punctuation">(</span>   <span class="token comment">// Clock out ports</span>   <span class="token punctuation">.</span><span class="token function">clk_out1</span><span class="token punctuation">(</span>clk_out1<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out1</span>   <span class="token punctuation">.</span><span class="token function">clk_out2</span><span class="token punctuation">(</span>clk_out2<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out2</span>   <span class="token punctuation">.</span><span class="token function">clk_out3</span><span class="token punctuation">(</span>clk_out3<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out3</span>   <span class="token punctuation">.</span><span class="token function">clk_out4</span><span class="token punctuation">(</span>clk_out4<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out4</span>   <span class="token comment">// Status and control signals</span>   <span class="token punctuation">.</span><span class="token function">resetn</span><span class="token punctuation">(</span>resetn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input resetn</span>   <span class="token punctuation">.</span><span class="token function">locked</span><span class="token punctuation">(</span>locked<span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment">// output locked</span>  <span class="token comment">// Clock in ports</span>   <span class="token punctuation">.</span><span class="token function">clk_in1</span><span class="token punctuation">(</span>clk_in1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// input clk_in1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="七、创建源文件"><a href="#七、创建源文件" class="headerlink" title="七、创建源文件"></a>七、创建源文件</h3><ol start="7"><li>创建一个 verilog 源文件，其名称为 ip_clk_wiz.v，代码如下： <pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">clk_wiz</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>  sys_clk<span class="token punctuation">,</span>    <span class="token keyword">input</span>  sys_rst_n<span class="token punctuation">,</span>    <span class="token keyword">output</span> clk_out1<span class="token punctuation">,</span>    <span class="token keyword">output</span> clk_out2<span class="token punctuation">,</span>    <span class="token keyword">output</span> clk_out3<span class="token punctuation">,</span>    <span class="token keyword">output</span> clk_out4<span class="token punctuation">,</span>    <span class="token keyword">output</span> locked<span class="token punctuation">)</span><span class="token punctuation">;</span>    clk_wiz_0 instance_name   <span class="token punctuation">(</span>    <span class="token comment">// Clock out ports</span>    <span class="token punctuation">.</span><span class="token function">clk_out1</span><span class="token punctuation">(</span>clk_out1<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out1</span>    <span class="token punctuation">.</span><span class="token function">clk_out2</span><span class="token punctuation">(</span>clk_out2<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out2</span>    <span class="token punctuation">.</span><span class="token function">clk_out3</span><span class="token punctuation">(</span>clk_out3<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out3</span>    <span class="token punctuation">.</span><span class="token function">clk_out4</span><span class="token punctuation">(</span>clk_out4<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// output clk_out4</span>    <span class="token comment">// Status and control signals</span>    <span class="token punctuation">.</span><span class="token function">resetn</span><span class="token punctuation">(</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// input resetn</span>    <span class="token punctuation">.</span><span class="token function">locked</span><span class="token punctuation">(</span>locked<span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment">// output locked</span>   <span class="token comment">// Clock in ports</span>    <span class="token punctuation">.</span><span class="token function">clk_in1</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// input clk_in1</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>它将 IP 核例化后，加上了输入输出，其原理图如下：<div align="center"><img src="/2024/06/17/mmcm/15.png" width="70%/"></div></li></ul><h3 id="八、创建仿真文件并模拟"><a href="#八、创建仿真文件并模拟" class="headerlink" title="八、创建仿真文件并模拟"></a>八、创建仿真文件并模拟</h3><ol start="8"><li>最后，仿真模拟。创建一个<code>tb_clk_wiz.v</code>的仿真文件，仿真代码编写如下：<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns <span class="token operator">/</span> <span class="token number">1</span>ps<span class="token keyword">module</span> <span class="token function">tb_clk_wiz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span>  sys_clk<span class="token punctuation">;</span><span class="token keyword">reg</span>  sys_rst_n<span class="token punctuation">;</span><span class="token keyword">wire</span> clk_out1<span class="token punctuation">;</span><span class="token keyword">wire</span> clk_out2<span class="token punctuation">;</span><span class="token keyword">wire</span> clk_out3<span class="token punctuation">;</span><span class="token keyword">wire</span> clk_out4<span class="token punctuation">;</span><span class="token keyword">wire</span> locked<span class="token punctuation">;</span>clk_wiz <span class="token function">clk_wiz_inst</span><span class="token punctuation">(</span>   <span class="token punctuation">.</span><span class="token function">sys_clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token punctuation">.</span><span class="token function">sys_rst_n</span><span class="token punctuation">(</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token punctuation">.</span><span class="token function">clk_out1</span><span class="token punctuation">(</span>clk_out1<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token punctuation">.</span><span class="token function">clk_out2</span><span class="token punctuation">(</span>clk_out2<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token punctuation">.</span><span class="token function">clk_out3</span><span class="token punctuation">(</span>clk_out3<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token punctuation">.</span><span class="token function">clk_out4</span><span class="token punctuation">(</span>clk_out4<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token punctuation">.</span><span class="token function">locked</span><span class="token punctuation">(</span>locked<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>    sys_clk <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>   sys_rst_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>   <span class="token number">#200</span>   sys_rst_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always</span> <span class="token number">#10</span> sys_clk <span class="token operator">=</span> <span class="token operator">~</span>sys_clk<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p>仿真波形如下：</p><div align="center"><img src="/2024/06/17/mmcm/16.png" width="100%/"></div></li><li><p>由上图可知，<code>locked</code> 信号拉高之后，锁相环开始输出 4 个稳定的时钟。<code>clk_100m</code> 和 <code>clk_100m_180deg</code> 周期都为 <code>10ns</code>，即时钟频率都为 100Mhz，但两个时钟相位偏移 180 度，所以这两个时钟刚好反相；<code>clk_50m</code> 周期为 20ns，时钟频率为 50Mhz；<code>clk_25m</code> 周期为 40ns，时钟频率为 25Mhz。也就是说，结果符合预期。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之Verilog 特殊技巧</title>
      <link href="/2024/06/14/verilog-special-skills/"/>
      <url>/2024/06/14/verilog-special-skills/</url>
      
        <content type="html"><![CDATA[<h1 id="Verilog-特殊技巧"><a href="#Verilog-特殊技巧" class="headerlink" title="Verilog 特殊技巧"></a>Verilog 特殊技巧</h1><h2 id="1-抓取上升沿和下降沿"><a href="#1-抓取上升沿和下降沿" class="headerlink" title="1. 抓取上升沿和下降沿"></a>1. 抓取上升沿和下降沿</h2><h3 id="实例-——-触摸按键控制LED亮灭"><a href="#实例-——-触摸按键控制LED亮灭" class="headerlink" title="实例 —— 触摸按键控制LED亮灭"></a>实例 —— 触摸按键控制LED亮灭</h3><h4 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h4><ul><li><strong>实验目的</strong>：本次实验通过电容式触摸按键控制LED的亮灭</li><li>电容触摸按键的<strong>工作原理</strong>：<ul><li>电容触摸按键主要由按键 IC 部分和电容部分构成。按键 IC 部分主要由元器件供应商提供，用于将电容的变化转换为电信号。电容部分指的是由电容极板、地、隔离区等组成触摸按键的电容环境。</li><li>任何两个导电的物体之间都存在着感应电容，在周围环境不变的情况下，该感应电容值是固定不变的。如下图所示，手指接触到触摸按键时，按键和手指之间产生寄生电容，使按键的总容值增加。 <div align="center"><img src="/2024/06/14/verilog-special-skills/1.png" width="40%/"></div></li><li>触摸按键按下前后，电容的变化如下图所示。电容式触摸按键 IC 在检测到按键的感应电容值改变，并超过一定的阈值后，将输出有效信号表示按键被按下。<div align="center"><img src="/2024/06/14/verilog-special-skills/2.png" width="70%/"></div></li></ul></li><li><strong>实验原理</strong>：通过捕捉按键的上升沿或者下降沿，实现LED的亮灭控制。</li></ul><h3 id="技巧功能"><a href="#技巧功能" class="headerlink" title="技巧功能"></a>技巧功能</h3><p>实现：</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ul><li>设计两个寄存器，$d_0$ 和 $d_1$<ul><li>假设 $T$ 为电容触摸按键<code>touch_key</code>的电平，则 $d_0$ 和 $d_1$ 的值分别为：<ul><li>$d_0$：保存 $T$ 的值</li><li>$d_1$：保存 $d_0$ 的值</li></ul></li><li>PS：描述时序逻辑，使用<strong>非阻塞赋值</strong><code>&lt;=</code>， $d_0$ 和 $d_1$ 同时赋值</li><li>目的：实现两个寄存器的值始终相差一个时钟周期</li></ul></li><li>若是抓取<strong>上升沿</strong>，正常情况，<code>touch_key</code>的电平始终为0，所以 $d_0$ 和 $d_1$ 的值始终相同为0，当出现一个脉冲时，$d_0$正好在脉冲的上升沿，值为1，而 $d_1$ 却在脉冲前一个时钟，还是0。</li><li>所以抓取上升沿，可以采取操作判断：<blockquote><p>~d1&amp;d0 &#x3D; 1</p></blockquote></li><li>同理，抓取下降沿，操作判断为：<blockquote><p>d1&amp;~d0 &#x3D; 1</p></blockquote></li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><font color="#dd0000">代码：</font></h4><p>此代码可作为抓取上升或下降沿的参考代码架构：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//reg define</span><span class="token keyword">reg</span>    d0<span class="token punctuation">;</span>    <span class="token comment">//端口的数据延迟一个时钟周期</span><span class="token keyword">reg</span>    d1<span class="token punctuation">;</span>    <span class="token comment">//端口的数据延迟两个时钟周期</span><span class="token comment">//wire define</span><span class="token keyword">wire</span>   en<span class="token punctuation">;</span>       <span class="token comment">//有效脉信号</span><span class="token comment">//捕获端口的上升沿，得到一个时钟周期的脉冲信号</span><span class="token keyword">assign</span>  en <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>d1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> d0<span class="token punctuation">;</span><span class="token comment">//对端口的数据延迟两个时钟周期</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>        d0 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        d1 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        d0 <span class="token operator">&lt;=</span> T<span class="token punctuation">;</span>        d1 <span class="token operator">&lt;=</span> d0<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例代码实现："><a href="#实例代码实现：" class="headerlink" title="实例代码实现："></a>实例代码实现：</h3><h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">touch_led</span><span class="token punctuation">(</span>    <span class="token comment">//input</span>    <span class="token keyword">input</span>        sys_clk<span class="token punctuation">,</span>      <span class="token comment">//时钟信号50Mhz</span>    <span class="token keyword">input</span>        sys_rst_n<span class="token punctuation">,</span>    <span class="token comment">//复位信号</span>    <span class="token keyword">input</span>        touch_key<span class="token punctuation">,</span>    <span class="token comment">//触摸按键 </span>     <span class="token comment">//output</span>    <span class="token keyword">output</span>  <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> led           <span class="token comment">//LED灯</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//reg define</span><span class="token keyword">reg</span>    touch_key_d0<span class="token punctuation">;</span>    <span class="token comment">//触摸按键端口的数据延迟一个时钟周期</span><span class="token keyword">reg</span>    touch_key_d1<span class="token punctuation">;</span>    <span class="token comment">//触摸按键端口的数据延迟两个时钟周期</span><span class="token comment">//wire define</span><span class="token keyword">wire</span>   touch_en<span class="token punctuation">;</span>       <span class="token comment">//触摸有效脉信号</span><span class="token comment">//捕获触摸按键端口的上升沿，得到一个时钟周期的脉冲信号</span><span class="token keyword">assign</span>  touch_en <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">~</span>touch_key_d1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> touch_key_d0<span class="token punctuation">;</span><span class="token comment">//对触摸按键端口的数据延迟两个时钟周期</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>        touch_key_d0 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        touch_key_d1 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        touch_key_d0 <span class="token operator">&lt;=</span> touch_key<span class="token punctuation">;</span>        touch_key_d1 <span class="token operator">&lt;=</span> touch_key_d0<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">end</span><span class="token comment">//根据触摸按键上升沿的脉冲信号切换led状态</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span>        led <span class="token operator">&lt;=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>       <span class="token comment">//默认状态下,LED灯灭</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>touch_en<span class="token punctuation">)</span>      <span class="token comment">//检测到触摸按键信号</span>            led <span class="token operator">&lt;=</span> <span class="token operator">~</span>led<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Testbench-模块代码："><a href="#Testbench-模块代码：" class="headerlink" title="Testbench 模块代码："></a>Testbench 模块代码：</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns <span class="token operator">/</span> <span class="token number">1</span>ps    <span class="token keyword">module</span> <span class="token function">tb_touch_led</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//reg define </span><span class="token keyword">reg</span>     sys_clk<span class="token punctuation">;</span> <span class="token keyword">reg</span>     sys_rst_n<span class="token punctuation">;</span>      <span class="token keyword">reg</span>     touch_key<span class="token punctuation">;</span>    <span class="token comment">//wire define </span><span class="token keyword">wire</span>          led <span class="token punctuation">;</span>           <span class="token important">always</span> <span class="token number">#10</span> sys_clk <span class="token operator">=</span> <span class="token operator">~</span>sys_clk<span class="token punctuation">;</span>   <span class="token keyword">initial</span> <span class="token keyword">begin</span>     sys_clk <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>     sys_rst_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>     touch_key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token number">#200</span>     sys_rst_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span> <span class="token comment">//touch_key 信号变化 </span>    <span class="token number">#40</span>  touch_key <span class="token operator">=</span> <span class="token number">1'b1</span> <span class="token punctuation">;</span>  <span class="token comment">//40ns 后触摸按键按下 </span>    <span class="token number">#200</span> touch_key <span class="token operator">=</span> <span class="token number">1'b0</span> <span class="token punctuation">;</span>  <span class="token comment">//200ns 触摸按键抬起 </span>    <span class="token number">#40</span>  touch_key <span class="token operator">=</span> <span class="token number">1'b1</span> <span class="token punctuation">;</span>  <span class="token comment">//40ns 后触摸按键按下 </span>    <span class="token number">#200</span> touch_key <span class="token operator">=</span> <span class="token number">1'b0</span> <span class="token punctuation">;</span>  <span class="token comment">//200ns 触摸按键抬起 </span>    <span class="token number">#40</span>  touch_key <span class="token operator">=</span> <span class="token number">1'b1</span> <span class="token punctuation">;</span>  <span class="token comment">//40ns 后触摸按键按下 </span>    <span class="token number">#200</span> touch_key <span class="token operator">=</span> <span class="token number">1'b0</span> <span class="token punctuation">;</span>  <span class="token comment">//200ns 触摸按键抬起 </span>    <span class="token number">#40</span>  touch_key <span class="token operator">=</span> <span class="token number">1'b1</span> <span class="token punctuation">;</span>  <span class="token comment">//40ns 后触摸按键按下 </span>    <span class="token number">#200</span> touch_key <span class="token operator">=</span> <span class="token number">1'b0</span> <span class="token punctuation">;</span>  <span class="token comment">//200ns 触摸按键抬起              </span><span class="token keyword">end</span>   touch_led  <span class="token function">u_touch_led</span><span class="token punctuation">(</span>     <span class="token punctuation">.</span>sys_clk   <span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">.</span>sys_rst_n <span class="token punctuation">(</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">.</span>touch_key <span class="token punctuation">(</span>touch_key<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token punctuation">.</span>led       <span class="token punctuation">(</span>led<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>仿真得到的波形图如图所示。从图中可以看出，当 <code>touch_key</code> 信号由低电平变为高电平时，<code>touch_key_d0</code> 和 <code>touch_key_d1</code> 信号分别延迟 <code>touch_key</code> 一个时钟周期和两个时钟周期，将 <code>touch_key_d0</code> 信号的和取反后的 <code>touch_key_d1</code> 信号相与，就得到一个时钟周期的脉冲信号（<code>touch_en</code>）。当检测到 <code>touch_en</code> 信号为高电平时，对 led 信号进行取反，从而实现触摸按键控制 led 灯的功能。    <div align="center">  <img src="/2024/06/14/verilog-special-skills/3.png" width="90%/">  </div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之Verilog HDL语法</title>
      <link href="/2024/06/10/verilog-hdl/"/>
      <url>/2024/06/10/verilog-hdl/</url>
      
        <content type="html"><![CDATA[<h1 id="Verilog-HDL语法"><a href="#Verilog-HDL语法" class="headerlink" title="Verilog HDL语法"></a>Verilog HDL语法</h1><p>本文参考了《正点原子 达芬奇 Pro 之 FPGA 开发指南》</p><h2 id="Verilog-简介"><a href="#Verilog-简介" class="headerlink" title="Verilog 简介"></a>Verilog 简介</h2><p>Verilog 是一种硬件描述语言（HDL），用于描述数字电路和系统的设计与验证。</p><h3 id="为什么需要-Verilog？"><a href="#为什么需要-Verilog？" class="headerlink" title="为什么需要 Verilog？"></a>为什么需要 Verilog？</h3><ol><li><strong>硬件设计</strong>：Verilog 用于描述硬件电路的结构和行为，便于在设计阶段对电路进行建模、仿真和验证。</li><li><strong>高效性</strong>：使用 Verilog，可以在较高抽象层次上设计电路，大大提高了设计效率。</li><li><strong>自动化工具支持</strong>：Verilog 被广泛支持，许多 EDA（电子设计自动化）工具可以直接读取 Verilog 代码，进行综合、仿真和布局布线等操作。</li><li><strong>可移植性</strong>：Verilog 代码是平台无关的，可以方便地在不同的硬件平台上实现。</li><li><strong>验证和调试</strong>：通过 Verilog 可以方便地对设计进行仿真和调试，发现和修复问题。</li></ol><h3 id="Verilog-和-VHDL-的区别"><a href="#Verilog-和-VHDL-的区别" class="headerlink" title="Verilog 和 VHDL 的区别"></a>Verilog 和 VHDL 的区别</h3><p>Verilog 和 VHDL（VHSIC Hardware Description Language）是两种主要的硬件描述语言。它们各有特点和优缺点。</p><ul><li><strong>语法风格</strong>：<ul><li>Verilog：类似于 C 语言，语法简洁明了，易于学习和使用。</li><li>VHDL：类似于 Ada 语言，语法更加严谨和复杂，提供了更强的类型检查。</li></ul></li><li><strong>使用领域</strong>：<ul><li>Verilog：在北美和商用 ASIC 设计中更为流行。</li><li>VHDL：在欧洲和国防、航空等高可靠性应用中更常见。</li></ul></li><li><strong>模块化设计</strong>：<ul><li>Verilog：模块化设计简单直观，但在一些复杂的类型处理上较为弱势。</li><li>VHDL：支持更强大的模块化设计和数据类型，适合复杂系统的设计。</li></ul></li><li><strong>语言功能</strong>：<ul><li>Verilog：更适合快速原型设计和较为简单的硬件描述。</li><li>VHDL：提供了更多的语法结构和功能，更适合复杂系统和高可靠性设计。</li></ul></li></ul><h3 id="Verilog-和-C-的区别"><a href="#Verilog-和-C-的区别" class="headerlink" title="Verilog 和 C 的区别"></a>Verilog 和 C 的区别</h3><p>Verilog 和 C 语言有许多根本性的区别，因为它们针对不同的应用领域。</p><ul><li><strong>用途</strong>：<ul><li>Verilog：用于描述和仿真硬件电路的行为和结构。</li><li>C 语言：用于编写软件程序，运行在通用处理器上。</li></ul></li><li><strong>抽象层次</strong>：<ul><li>Verilog：强调并行性，适合描述硬件的并行操作和时序行为。</li><li>C 语言：强调顺序执行，适合描述算法和顺序逻辑。</li></ul></li><li><strong>执行方式</strong>：<ul><li>Verilog：代码通过硬件描述语言仿真工具执行，用于生成综合后的硬件电路。</li><li>C 语言：代码通过编译器编译成机器代码，在处理器上运行。</li></ul></li><li><strong>设计目标</strong>：<ul><li>Verilog：目标是生成高效的硬件电路，关注时序、延迟和资源利用。</li><li>C 语言：目标是生成可执行的软件程序，关注性能、可读性和可维护性。</li></ul></li></ul><h2 id="Verilog-基础语法"><a href="#Verilog-基础语法" class="headerlink" title="Verilog 基础语法"></a>Verilog 基础语法</h2><h3 id="Verilog的逻辑值"><a href="#Verilog的逻辑值" class="headerlink" title="Verilog的逻辑值"></a>Verilog的逻辑值</h3><ul><li>逻辑 0：表示低电平，也就是对应我们电路的 GND；</li><li>逻辑 1：表示高电平，也就是对应我们电路的 VCC；</li><li>逻辑 X：表示未知，有可能是高电平，也有可能是低电平；</li><li>逻辑 Z：表示高阻态，外部没有激励信号是一个悬空状态。</li></ul><div align="center"><img src="/2024/06/10/verilog-hdl/1.png" width="70%/"></div><h3 id="Verilog的数字进制格式"><a href="#Verilog的数字进制格式" class="headerlink" title="Verilog的数字进制格式"></a>Verilog的数字进制格式</h3><ul><li>Verilog 数字进制格式包括二进制、八进制、十进制和十六进制，一般常用的为二进制、十进制和十六进制。 </li><li>二进制表示如下：4’<strong>b</strong>0101 表示 4 位二进制数字 0101； </li><li>十进制表示如下：4’<strong>d</strong>2 表示 4 位十进制数字 2（二进制 0010）； </li><li>十六进制表示如下：4’<strong>h</strong>a 表示 4 位十六进制数字 a（二进制 1010），十六进制的计数方式为 0，1，2…9，a，b，c，d，e，f，最大计数为 f（f：十进制表示为 15）。 </li><li>当代码中没有指定数字的位宽与进制时，默认为 32 位的十进制，比如 100，实际上表示的值为32’d100。</li></ul><h3 id="Verilog-的标识符"><a href="#Verilog-的标识符" class="headerlink" title="Verilog 的标识符"></a>Verilog 的标识符</h3><ul><li><p>标识符(identifier）用于定义模块名、端口名和信号名等。</p></li><li><p>Verilog 的标识符可以是任意一组字母、数字、$和_(下划线)符号的组合</p></li><li><p>但标识符的第一个字符必须是字母或者下划线。</p></li><li><p>另外，标识符是区分大小写的。</p></li><li><p>注意：</p><ul><li>不建议大小写混合使用，</li><li>普通内部信号建议全部小写，</li><li>参数定义建议大写，</li><li>另外信号命名最好体现信号的含义。</li></ul></li><li><p>以下是一些书写规范的要求： </p><ol><li>用有意义的有效的名字如 sum、cpu_addr 等。 </li><li>用下划线区分词语组合，如 cpu_addr。 </li><li>采用一些前缀或后缀，比如：时钟采用 clk 前缀：clk_50m，clk_cpu；低电平采用_n 后缀：enable_n； </li><li>统一缩写，如全局复位信号 rst。 </li><li>同一信号在不同层次保持一致性，如同一时钟信号必须在各模块保持一致。 </li><li>自定义的标识符不能与保留字（关键词）同名。 </li><li>参数统一采用大写，如定义参数使用 SIZE。</li></ol></li></ul><h3 id="Verilog-的数据类型"><a href="#Verilog-的数据类型" class="headerlink" title="Verilog 的数据类型"></a>Verilog 的数据类型</h3><p>在 Verilog 语法中，主要有三大类数据类型，即<strong>寄存器类型</strong>、<strong>线网类型</strong>和<strong>参数类型</strong>。从名称中，我们可以看出，真正在数字电路中起作用的数据类型应该是寄存器类型和线网类型。</p><h4 id="1-寄存器类型"><a href="#1-寄存器类型" class="headerlink" title="1. 寄存器类型"></a>1. 寄存器类型</h4><ul><li>寄存器类型表示一个抽象的数据存储单元，它只能在 <code>always</code> 语句和 <code>initial</code> 语句中被赋值</li><li>如果该过程语句描述的是<strong>时序逻辑</strong>，即 <code>always</code> 语句<u>带有时钟信号</u>，则该寄存器变量对应为<strong>寄存器</strong></li><li>如果该过程语句描述的是<strong>组合逻辑</strong>，即 <code>always</code> 语句<u>不带有时钟信号</u>，则该寄存器变量对应为<strong>硬件连线</strong></li><li>寄存器类型的缺省值是 x（未知状态）。</li><li>寄存器数据类型有很多种，如 <code>reg</code>、<code>integer</code>、<code>real</code> 等，其中最常用的就是 <code>reg</code> 类型，它的使用方法如下：</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//reg define </span><span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  delay_cnt<span class="token punctuation">;</span>    <span class="token comment">//延时计数器 </span><span class="token keyword">reg</span>          key_flag <span class="token punctuation">;</span>    <span class="token comment">//按键标志 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-线网类型"><a href="#2-线网类型" class="headerlink" title="2. 线网类型"></a>2. 线网类型</h4><ul><li>线网表示 Verilog 结构化元件间的物理连线。</li><li>它的值由驱动元件的值决定，例如连续赋值或门的输出。</li><li>如果没有驱动元件连接到线网，线网的缺省值为 z（高阻态）。</li><li>线网类型同寄存器类型一样也是有很多种，如 <code>tri</code> 和 <code>wire</code> 等，其中最常用的就是 <code>wire</code> 类型，它的使用方法如下：</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//wire define </span><span class="token keyword">wire</span>         data_en<span class="token punctuation">;</span>         <span class="token comment">//数据使能信号 </span><span class="token keyword">wire</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  data   <span class="token punctuation">;</span>         <span class="token comment">//数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-参数类型"><a href="#3-参数类型" class="headerlink" title="3. 参数类型"></a>3. 参数类型</h4><ul><li>参数其实就是一个常量，常被用于定义状态机的状态、数据位宽和延迟大小<br>等</li><li>在定义参数时，我们可以一次定义多个参数，参数与参数之间需要用逗号隔开。</li><li>采用标识符来代表一个常量可以提高程序的可读性和可维护性。</li><li>在模块调用时，可通过参数传递来改变被调用模块中已定义的参数。</li><li>是参数的定义是局部的，只在当前模块中有效。它的使用方法如下：</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//parameter define </span><span class="token keyword">parameter</span>    DATA_WIDTH <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment">//数据位宽为8位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Verilog-的运算符"><a href="#Verilog-的运算符" class="headerlink" title="Verilog 的运算符"></a>Verilog 的运算符</h3><ul><li>大部分运算符与C相同，本文就讲述特别且常用的运算符</li></ul><h4 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1.位运算符"></a>1.位运算符</h4><ul><li>位运算符是一类最基本的运算符，可以认为它们直接对应数字逻辑中的与、或、非门等逻辑门。常用的位运算符如下表所示。</li><li>位运算符的与、或、非与逻辑运算符逻辑与、逻辑或、逻辑非使用时候容易混淆，逻辑运算符一般用在条件判断上，位运算符一般用在信号赋值上。</li></ul><table><thead><tr><th align="left">符合</th><th align="left">使用方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">~</td><td align="left">~a</td><td align="left">将 a 的每个位进行取反</td></tr><tr><td align="left">&amp;</td><td align="left">a&amp;b</td><td align="left">将 a 的每个位与 b 相同的位进行相与</td></tr><tr><td align="left">|</td><td align="left">a|b</td><td align="left">将 a 的每个位与 b 相同的位进行相或</td></tr><tr><td align="left">^</td><td align="left">a ^ b</td><td align="left">将 a 的每个位与 b 相同的位进行异或</td></tr></tbody></table><h4 id="2-移位运算符"><a href="#2-移位运算符" class="headerlink" title="2.移位运算符"></a>2.移位运算符</h4><ul><li>移位运算符包括左移位运算符和右移位运算符，这两种移位运算符都<strong>用 0 来填补移出的空位</strong>。</li><li>假设 a 有 8bit 数据位宽，那么 <code>a&lt;&lt;2</code>，表示 a 左移 2bit，a 还是 8bit 数据位宽，a 的最高 2bit 数据被移位丢弃了，最低 2bit 数据固定补 0。</li><li>如果 a 是 3（二进制：00000011），那么 3 左移 2bit，<code>3&lt;&lt;2</code>，就是 12（二进制：00001100）。一般使用左移位运算代替乘法，右移位运算代替除法，但是这种也只能表示 2 的指数次幂的乘除法。</li></ul><table><thead><tr><th align="left">符合</th><th align="left">使用方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&lt;&lt;</td><td align="left">a &lt;&lt; b</td><td align="left">将 a 左移 b 位</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">a &gt;&gt; b</td><td align="left">将 a 右移 b 位</td></tr></tbody></table><h4 id="3-拼接运算符"><a href="#3-拼接运算符" class="headerlink" title="3.拼接运算符"></a>3.拼接运算符</h4><ul><li>Verilog 中有一个特殊的运算符是 C 语言中没有的，就是位拼接运算符。用这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。</li></ul><table><thead><tr><th align="left">符合</th><th align="left">使用方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">{}</td><td align="left">{a,b}</td><td align="left">将 a 和 b 拼接起来，作为一个新信号</td></tr></tbody></table><h2 id="Verilog-程序框架"><a href="#Verilog-程序框架" class="headerlink" title="Verilog 程序框架"></a>Verilog 程序框架</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul><li>Verilog 和 C 语言类似，都因编写需要定义了一系列保留字，叫做关键字（或关键词）。这些保留字是识别语法的关键。<br><img src="/2024/06/10/verilog-hdl/2.png"></li><li><strong>实际经常使用的主要如下表</strong>:</li></ul><div align="center"><img src="/2024/06/10/verilog-hdl/3.png" width="70%/"></div><h3 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h3><ul><li><p>Verilog 的基本设计单元是“<strong>模块</strong>”(block)，一个模块是由两部分组成的，一部分<strong>描述接口</strong>，另一部分<strong>描述逻辑功能</strong>。</p></li><li><p>每个Verilog程序包括4个主要的部分：<strong>端口定义</strong>、<strong>IO说明</strong>、<strong>内部信号声明</strong>、<strong>功能定义</strong>。</p></li><li><p>以 《正点原子 达芬奇 Pro 之 FPGA 开发指南》提供的LED 流水灯程序为例来展示 Verilog 的程序框架，代码如下所示（注意：代码中前面的行号只是为了方便大家阅读代码与快速定位到行号的位置，在实际编写代码时不可以添加行号，否则编译代码时会报错）。</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">1</span>  <span class="token keyword">module</span> <span class="token function">led</span><span class="token punctuation">(</span> <span class="token number">2</span>      <span class="token keyword">input</span>               sys_clk  <span class="token punctuation">,</span>  <span class="token comment">//系统时钟 </span><span class="token number">3</span>      <span class="token keyword">input</span>               sys_rst_n<span class="token punctuation">,</span>  <span class="token comment">//系统复位，低电平有效 </span><span class="token number">4</span>      <span class="token keyword">output</span>  <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  led         <span class="token comment">//4 位 LED 灯 </span><span class="token number">5</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">6</span>   <span class="token number">7</span>  <span class="token comment">//parameter define </span><span class="token number">8</span>  <span class="token keyword">parameter</span>  WIDTH     <span class="token operator">=</span> <span class="token number">25</span>        <span class="token punctuation">;</span> <span class="token number">9</span>  <span class="token keyword">parameter</span>  COUNT_MAX <span class="token operator">=</span> <span class="token number">25_000</span><span class="token number">_000</span><span class="token punctuation">;</span>  <span class="token comment">//板载 50M 时钟=20ns，0.5s/20ns=25000000，需要 25bit </span><span class="token number">10</span>                                     <span class="token comment">//位宽 </span><span class="token number">11</span><span class="token number">12</span> <span class="token comment">//reg define </span><span class="token number">13</span> <span class="token keyword">reg</span>    <span class="token punctuation">[</span>WIDTH<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  counter     <span class="token punctuation">;</span> <span class="token number">14</span> <span class="token keyword">reg</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>        led_ctrl_cnt<span class="token punctuation">;</span> <span class="token number">15</span>  <span class="token number">16</span> <span class="token comment">//wire define </span><span class="token number">17</span> <span class="token keyword">wire</span>                counter_en  <span class="token punctuation">;</span> <span class="token number">18</span>  <span class="token number">19</span> <span class="token comment">//*******************************************************************</span><span class="token number">20</span> <span class="token comment">//**                                 main code </span><span class="token number">21</span> <span class="token comment">//*******************************************************************</span><span class="token number">22</span>  <span class="token number">23</span> <span class="token comment">//计数到最大值时产生高电平使能信号 </span><span class="token number">24</span> <span class="token keyword">assign</span>  counter_en <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token punctuation">(</span>COUNT_MAX <span class="token operator">-</span> <span class="token number">1'b1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">?</span>  <span class="token number">1'b1</span>  <span class="token punctuation">:</span>  <span class="token number">1'b0</span><span class="token punctuation">;</span>   <span class="token number">25</span>           <span class="token number">26</span> <span class="token comment">//用于产生 0.5 秒使能信号的计数器 </span><span class="token number">27</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token number">28</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>sys_rst_n <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token number">29</span>         counter <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span> <span class="token number">30</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_en<span class="token punctuation">)</span> <span class="token number">31</span>         counter <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span> <span class="token number">32</span>     <span class="token keyword">else</span> <span class="token number">33</span>         counter <span class="token operator">&lt;=</span> counter <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span> <span class="token number">34</span> <span class="token keyword">end</span> <span class="token number">35</span>  <span class="token number">36</span> <span class="token comment">//led 流水控制计数器 </span><span class="token number">37</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token number">38</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>sys_rst_n <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token number">39</span>         led_ctrl_cnt <span class="token operator">&lt;=</span> <span class="token number">2'b0</span><span class="token punctuation">;</span> <span class="token number">40</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_en<span class="token punctuation">)</span> <span class="token number">41</span>         led_ctrl_cnt <span class="token operator">&lt;=</span> led_ctrl_cnt <span class="token operator">+</span> <span class="token number">2'b1</span><span class="token punctuation">;</span> <span class="token number">42</span> <span class="token keyword">end</span> <span class="token number">43</span>  <span class="token number">44</span> <span class="token comment">//通过控制 IO 口的高低电平实现发光二极管的亮灭 </span><span class="token number">45</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token number">46</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>sys_rst_n <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token number">47</span>         led <span class="token operator">&lt;=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span> <span class="token number">48</span>     <span class="token keyword">else</span> <span class="token keyword">begin</span> <span class="token number">49</span>         <span class="token keyword">case</span> <span class="token punctuation">(</span>led_ctrl_cnt<span class="token punctuation">)</span>                  <span class="token number">50</span>             <span class="token number">2'd0</span> <span class="token punctuation">:</span> led <span class="token operator">&lt;=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span> <span class="token number">51</span>             <span class="token number">2'd1</span> <span class="token punctuation">:</span> led <span class="token operator">&lt;=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span> <span class="token number">52</span>             <span class="token number">2'd2</span> <span class="token punctuation">:</span> led <span class="token operator">&lt;=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span> <span class="token number">53</span>             <span class="token number">2'd3</span> <span class="token punctuation">:</span> led <span class="token operator">&lt;=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span> <span class="token number">54</span>             <span class="token keyword">default</span> <span class="token punctuation">:</span> <span class="token punctuation">;</span> <span class="token number">55</span>         <span class="token keyword">endcase</span> <span class="token number">56</span>     <span class="token keyword">end</span> <span class="token number">57</span> <span class="token keyword">end</span> <span class="token number">58</span>  <span class="token number">59</span> <span class="token keyword">endmodule</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>首先&#x2F;&#x2F;开头的都是注释，这个之前我们讲解过了。下面我们来看下具体的解释。 </li><li>第 1 行为模块定义，模块定义以 module 开始，endmodule 结束，如 59 行所示。 </li><li>其次 2 到 5 行为端口定义，需要定义 led 模块的输入信号和输出信号，此处输入信号为系统时钟和复位信号，输出为 led 控制信号。 </li><li>7 到 9 行为参数 parameter 定义，语法如 7 到 9 行所示，定义 parameter 的好处是可以灵活改变参数数字就能控制一些计数器最大计数值或者信号位宽的最大位宽。 </li><li>12 到 14 行为 reg 信号定义，reg 信号一般情况下代表寄存器，比如此处控制 0.5 秒使能信号的计数器counter。 </li><li>16 到 17 行为 wire 信号定义，wire 信号就是硬件连线，比如此处的 counter_en，代表计数到最大值时产生高电平使能，本质上是一个硬件连线，其实代表的是一些计数器&#x2F;寄存器做逻辑判断的结果。 19 到 21 行为 moudle 开始的注释，不添加工具综合也不会报错，但是我们推荐添加，作为一个良好的编程规范。 </li><li>23 到 24 行为 assign 语句的样式，条件成立选择 1，否则选择 0。 </li><li>26 到 34 行是 always 语句的样式，27 行代表在时钟上升沿或者复位的下降沿进行信号触发。begin&#x2F;end 代表语句的开始和结束。28 到 33 行为 if&#x2F;else 语句，和 C 语言是比较类似的。29 行的“&lt;&#x3D;”标记代表信号是非阻塞赋值，信号赋值有非阻塞赋值和阻塞赋值两个方式，这个我们后面会详细解释。 36 和 42 行也是一个 always 语句，和 26 到 34 行类似。 </li><li>44 和 57 行也是一个 always 语句，不过这个 always 语句中嵌入了一个 case 语句，case 语句的语法如49 到 55 行所示，需要一个 case 关键字开始，endcase 关键字结束，default 作为默认分支，和 C 语言也是类似的。当然 case 语句也可以用在不带时钟的 always 语句中，不过本例子的 always 都是带有时钟的。不带时钟的 always 和带时钟的 always 语句的差异这个我们后面也会详细解释。 </li><li>59 行是 endmodule 标记，代表模块的结束。 </li><li>如果只有一条赋值语句时，if 后面可以加 begin 和 end，也可以不加；如果超过一条赋值语句时，就必须加上 begin 和 end。 代码如下所示：<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">if</span><span class="token punctuation">(</span>en <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>     b <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>     c <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span> <span class="token keyword">end</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Verilog-高级知识点"><a href="#Verilog-高级知识点" class="headerlink" title="Verilog 高级知识点"></a>Verilog 高级知识点</h2><h3 id="结构语句"><a href="#结构语句" class="headerlink" title="结构语句"></a>结构语句</h3><h4 id="initial和-always"><a href="#initial和-always" class="headerlink" title="initial和 always"></a>initial和 always</h4><ul><li><code>initial</code>语句它在模块中只执行一次。<br>它常用于测试文件的编写，用来产生仿真测试信号(激励信号)，或者用于对存储器变量赋初值。</li><li><code>always</code>语句一直在不断地重复活动。<br>但是只有和一定的时间控制结合在一起才有作用。</li></ul><h4 id="assign-和-always-区别"><a href="#assign-和-always-区别" class="headerlink" title="assign 和 always 区别"></a>assign 和 always 区别</h4><ul><li><code>assign</code> 语句使用时不能带时钟。 </li><li><code>always</code> 语句可以带时钟，也可以不带时钟。在 <code>always</code> 不带时钟时，逻辑功能和 <code>assign</code> 完全一致，都是</li><li>只产生组合逻辑。比较<strong>简单的组合逻辑</strong>推荐使用 <code>assign</code> 语句，比较<strong>复杂的组合逻辑</strong>推荐使用 <code>always</code> 语句。</li></ul><h4 id="带不带时钟的-always-语句"><a href="#带不带时钟的-always-语句" class="headerlink" title="带不带时钟的 always 语句"></a>带不带时钟的 always 语句</h4><ul><li><code>always</code>的时间控制可以是<strong>沿触发</strong>也可以是<strong>电平触发</strong>:</li><li>可以是单个信号，也可以是多个信号，多个信号中间要用关键字or连接。</li><li>信号的上升沿触发：<code>@(posedge signal)</code></li><li>信号的下降沿触发：<code>@(negedge signal)</code></li><li>信号的电平触发：<code>@(signal)</code></li><li>在 <code>always</code> 不带时钟时，逻辑功能和 <code>assign</code> 完全一致，虽然产生的信号定义还是 <code>reg</code> 类型，但是该语句产生的还是<strong>组合逻辑</strong>。 <pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span>   <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> led； <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span>led_ctrl_cnt<span class="token punctuation">)</span>                              <span class="token number">2'd0</span>    <span class="token punctuation">:</span> led <span class="token operator">=</span> <span class="token number">4'b0001</span><span class="token punctuation">;</span>             <span class="token number">2'd1</span>    <span class="token punctuation">:</span> led <span class="token operator">=</span> <span class="token number">4'b0010</span><span class="token punctuation">;</span>             <span class="token number">2'd2</span>    <span class="token punctuation">:</span> led <span class="token operator">=</span> <span class="token number">4'b0100</span><span class="token punctuation">;</span>             <span class="token number">2'd3</span>    <span class="token punctuation">:</span> led <span class="token operator">=</span> <span class="token number">4'b1000</span><span class="token punctuation">;</span>             <span class="token keyword">default</span> <span class="token punctuation">:</span> led <span class="token operator">=</span> <span class="token number">4'b0000</span><span class="token punctuation">;</span>         <span class="token keyword">endcase</span> <span class="token keyword">end</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在 <code>always</code> 带时钟信号时，这个逻辑语句才能产生真正的寄存器，如下示例 <code>counter</code> 就是真正的寄存器。 <pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//用于产生 0.5 秒使能信号的计数器 </span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>sys_rst_n <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>         counter <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_en<span class="token punctuation">)</span>         counter <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>     <span class="token keyword">else</span>         counter <span class="token operator">&lt;=</span> counter <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span> <span class="token number">34</span>  <span class="token keyword">end</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="组合逻辑电路和时序逻辑电路"><a href="#组合逻辑电路和时序逻辑电路" class="headerlink" title="组合逻辑电路和时序逻辑电路"></a>组合逻辑电路和时序逻辑电路</h4><ul><li>根据逻辑功能的不同特点，可以将数字电路分成两大类：<strong>组合逻辑电路</strong>和<strong>时序逻辑电路</strong>。</li><li><strong>组合逻辑电路</strong>中，任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。</li><li><strong>时序逻辑电路</strong>中，任一时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态。或者说还与以前的输入有关，因此时序逻辑必须具备记忆功能。<br><img src="/2024/06/10/verilog-hdl/4.png"></li></ul><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><h4 id="阻塞赋值（Blocking）"><a href="#阻塞赋值（Blocking）" class="headerlink" title="阻塞赋值（Blocking）"></a>阻塞赋值（Blocking）</h4><ul><li>阻塞赋值，顾名思义即在一个 <code>always</code> 块中，一条阻塞赋值语句如果没有执行结束，那么该语句后面的语句就不能被执行，即被“阻塞”。</li><li>RHS：赋值等号右边的表达式或变量可以写作 RHS 表达式或 RHS 变量 </li><li>LHS：赋值等号左边的表达式或变量可以写作 LHS 表达式或 LHS 变量<br><img src="/2024/06/10/verilog-hdl/5.png"><br><img src="/2024/06/10/verilog-hdl/6.png"></li><li>代码中使用的是阻塞赋值语句，从波形图中可以看到：<ul><li>在复位的时候（rst_n&#x3D;0），a&#x3D;1，b&#x3D;2，c&#x3D;3；</li><li>而结束复位之后（波形图中的 0 时刻），当 clk 的上升沿到来时（波形图中的 2 时刻），a&#x3D;0，b&#x3D;0，c&#x3D;0。</li><li>这是因为阻塞赋值是在当前语句执行完成之后，才会执行后面的赋值语句，因此首先执行的是 a&#x3D;0，赋值完成后将 a 的值赋值给 b，由于此时 a 的值已经为 0，所以 b&#x3D;a&#x3D;0，最后执行的是将 b 的值赋值给 c，而 b 的值已经赋值为 0，所以 c 的值同样等于 0。</li></ul></li></ul><h4 id="非阻塞赋值（Non-blocking）"><a href="#非阻塞赋值（Non-blocking）" class="headerlink" title="非阻塞赋值（Non-blocking）"></a>非阻塞赋值（Non-blocking）</h4><ul><li>符号“&lt;&#x3D;”用于非阻塞赋值（如:b &lt;&#x3D; a;），非阻塞赋值是由时钟节拍决定，在时钟上升到来时，执行赋值语句右边，然后将 begin-end 之间的所有赋值语句同时赋值到赋值语句的左边</li><li>非阻塞赋值的操作过程可以看作两个步骤： <ol><li>赋值开始的时候，计算 RHS； </li><li>赋值结束的时候，更新 LHS。</li></ol></li></ul><p><img src="/2024/06/10/verilog-hdl/7.png"><br><img src="/2024/06/10/verilog-hdl/8.png"></p><ul><li>代码中使用的是非阻塞赋值语句，从波形图中可以看到：<ul><li>在复位的时候（rst_n&#x3D;0），a&#x3D;1，b&#x3D;2，c&#x3D;3；</li><li>而结束复位之后（波形图中的 0 时刻），当 clk 的上升沿到来时（波形图中的 2 时刻），a&#x3D;0，b&#x3D;1，c&#x3D;2。</li><li>这是因为非阻塞赋值在计算 RHS 和更新 LHS 期间，允许其它的非阻塞赋值语句同时计算 RHS 和更新 LHS。在波形图中的 2 时刻，RHS 的表达是 0、a、b，分别等于 0、1、2，这三条语句是同时更新 LHS，所以 a、b、c 的值分别等于 0、1、2。</li></ul></li></ul><h4 id="阻塞和非阻塞何时使用"><a href="#阻塞和非阻塞何时使用" class="headerlink" title="阻塞和非阻塞何时使用"></a>阻塞和非阻塞何时使用</h4><ul><li>在描述<strong>组合逻辑电路</strong>的时候，使用<strong>阻塞赋值</strong>，比如 <code>assign</code> 赋值语句和不带时钟的 <code>always</code> 赋值语句</li><li>在描述<strong>时序逻辑</strong>的时候，使用<strong>非阻塞赋值</strong>，综合成时序逻辑的电路结构，比如带时钟的 <code>always</code> 语句；这种电路结构往往与触发沿有关系，只有在触发沿时才可能发生赋值的变化</li></ul><h2 id="Verilog-状态机"><a href="#Verilog-状态机" class="headerlink" title="Verilog 状态机"></a>Verilog 状态机</h2><ul><li>状态机(State Machine)<ul><li>有限状态机(Finite State Machine，简称FSM)</li><li>在有限个状态之间按一定规律转换的时序电路。</li></ul></li><li>根据状态机的输出是否与输入条件相关，可将状态机分为两大类，即<strong>摩尔(Moore)型状态机</strong>和<strong>米勒(Mealy)型状态机</strong>。 <ul><li><strong>Mealy 状态机</strong>：组合逻辑的输出不仅取决于当前状态，还取决于输入状态。 </li><li><strong>Moore 状态机</strong>：组合逻辑的输出只取决于当前状态。</li></ul></li></ul><h3 id="1-Mealy-状态机"><a href="#1-Mealy-状态机" class="headerlink" title="1. Mealy 状态机"></a>1. Mealy 状态机</h3><ul><li>米勒状态机的模型如下图所示：<ul><li>模型中第一个方框是指产生下一状态的组合逻辑 F，F 是当前状态和输入信号的函数，状态是否改变、如何改变，取决于组合逻辑 F 的输出；</li><li>第二框图是指状态寄存器，其由一组触发器组成，用来记忆状态机当前所处的状态，状态的改变只发生在时钟的跳边沿；</li><li>第三个框图是指产生输出的组合逻辑 G，状态机的输出是由输出组合逻辑 G 提供的，G 也是当前状态和输入信号的函数。</li></ul></li></ul><p><img src="/2024/06/10/verilog-hdl/10.png"></p><h3 id="2-Moore-状态机"><a href="#2-Moore-状态机" class="headerlink" title="2. Moore 状态机"></a>2. Moore 状态机</h3><ul><li>摩尔状态机的模型如下图所示，对比米勒状态机的模型可以发现，其区别在于米勒状态机的输出由<strong>当前状态和输入条件决定</strong>的，而摩尔状态机的输出<strong>只取决于当前状态</strong>。</li></ul><p><img src="/2024/06/10/verilog-hdl/11.png"></p><h3 id="3-三段式状态机"><a href="#3-三段式状态机" class="headerlink" title="3. 三段式状态机"></a>3. 三段式状态机</h3><ul><li>根据状态机的实际写法，状态机还可以分为一段式、二段式和三段式状态机。 </li><li>三段式：使用三个 <code>always</code> 模块。<ul><li>第一个 <code>always</code> 模块采用<u>同步时序</u><strong>描述状态转移</strong>，</li><li>第二个 <code>always</code> 采用<u>组合逻辑判断状态转移条件</u>，<strong>描述状态转移规律</strong>，</li><li>第三个 <code>always</code> 模块<strong>描述状态输出</strong>(可以用组合电路输出，也可以时序电路输出)。</li></ul></li><li>实际应用中三段式状态机使用最多，因为三段式状态机将组合逻辑和时序分开，有利于综合器分析优化以及程序的维护；并且三段式状态机将状态转移与状态输出分开，使代码看上去更加清晰易懂，提高了代码的可读性</li></ul><ol><li><p>在开始编写状态机代码之前，一般先画出状态跳转图，这样在编写代码时思路会比较清晰，下面以一个 7 分频为例：<br><img src="/2024/06/10/verilog-hdl/9.png"></p></li><li><p>状态跳转图画完之后，接下来通过 <code>parameter</code> 来定义各个不同状态的参数，如下代码所示:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">parameter</span> S0 <span class="token operator">=</span> <span class="token number">7'b0000001</span><span class="token punctuation">;</span>     <span class="token comment">//独热码定义方式 </span><span class="token keyword">parameter</span> S1 <span class="token operator">=</span> <span class="token number">7'b0000010</span><span class="token punctuation">;</span> <span class="token keyword">parameter</span> S2 <span class="token operator">=</span> <span class="token number">7'b0000100</span><span class="token punctuation">;</span> <span class="token keyword">parameter</span> S3 <span class="token operator">=</span> <span class="token number">7'b0001000</span><span class="token punctuation">;</span> <span class="token keyword">parameter</span> S4 <span class="token operator">=</span> <span class="token number">7'b0010000</span><span class="token punctuation">;</span> <span class="token keyword">parameter</span> S5 <span class="token operator">=</span> <span class="token number">7'b0100000</span><span class="token punctuation">;</span> <span class="token keyword">parameter</span> S6 <span class="token operator">=</span> <span class="token number">7'b1000000</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义状态寄存器，如下代码所示：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   curr_st     <span class="token punctuation">;</span>     <span class="token comment">//当前状态 </span><span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   next_st     <span class="token punctuation">;</span>     <span class="token comment">//下一个状态 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接下来就可以使用三个 <code>always</code> 语句来开始编写状态机的代码，第一个 always 采用同步时序描述状态转移，第二个 <code>always</code> 采用组合逻辑判断状态转移条件，第三个 <code>always</code> 是描述状态输出，一个完整的三段式状态机的例子如下代码所示： </p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">1</span>  <span class="token keyword">module</span> divider7_fsm <span class="token punctuation">(</span>  <span class="token number">2</span>      <span class="token comment">//系统时钟与复位 </span><span class="token number">3</span>      <span class="token keyword">input</span>       sys_clk      <span class="token punctuation">,</span>  <span class="token number">4</span>      <span class="token keyword">input</span>       sys_rst_n    <span class="token punctuation">,</span> <span class="token number">5</span>   <span class="token number">6</span>      <span class="token comment">//输出时钟 </span><span class="token number">7</span>      <span class="token keyword">output</span> <span class="token keyword">reg</span>  clk_divide_7  <span class="token number">8</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">9</span>   <span class="token number">10</span> <span class="token comment">//parameter define  </span><span class="token number">11</span> <span class="token keyword">parameter</span> S0 <span class="token operator">=</span> <span class="token number">7'b0000001</span><span class="token punctuation">;</span>     <span class="token comment">//独热码定义方式 12 parameter S1 = 7'b0000010; </span><span class="token number">13</span> <span class="token keyword">parameter</span> S2 <span class="token operator">=</span> <span class="token number">7'b0000100</span><span class="token punctuation">;</span> <span class="token number">14</span> <span class="token keyword">parameter</span> S3 <span class="token operator">=</span> <span class="token number">7'b0001000</span><span class="token punctuation">;</span> <span class="token number">15</span> <span class="token keyword">parameter</span> S4 <span class="token operator">=</span> <span class="token number">7'b0010000</span><span class="token punctuation">;</span> <span class="token number">16</span> <span class="token keyword">parameter</span> S5 <span class="token operator">=</span> <span class="token number">7'b0100000</span><span class="token punctuation">;</span> <span class="token number">17</span> <span class="token keyword">parameter</span> S6 <span class="token operator">=</span> <span class="token number">7'b1000000</span><span class="token punctuation">;</span>     <span class="token number">18</span>      <span class="token number">19</span> <span class="token comment">//reg define  </span><span class="token number">20</span> <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   curr_st     <span class="token punctuation">;</span>     <span class="token comment">//当前状态 </span><span class="token number">21</span> <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   next_st     <span class="token punctuation">;</span>     <span class="token comment">//下一个状态 </span><span class="token number">22</span>  <span class="token number">23</span> <span class="token comment">//***************************************************** 24 //**                    main code </span><span class="token number">25</span> <span class="token comment">//*****************************************************  26  </span><span class="token number">27</span> <span class="token comment">//状态机的第一段采用同步时序描述状态转移 </span><span class="token number">28</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token number">29</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span> <span class="token number">30</span>             curr_st <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span> <span class="token number">31</span>         <span class="token keyword">else</span> <span class="token number">32</span>             curr_st <span class="token operator">&lt;=</span> next_st<span class="token punctuation">;</span> <span class="token number">33</span> <span class="token keyword">end</span> <span class="token number">34</span>  <span class="token number">35</span> <span class="token comment">//状态机的第二段采用组合逻辑判断状态转移条件 36 always @(*) begin  </span><span class="token number">37</span>     <span class="token keyword">case</span> <span class="token punctuation">(</span>curr_st<span class="token punctuation">)</span>  <span class="token number">38</span>         S0<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S1<span class="token punctuation">;</span> <span class="token number">39</span>         S1<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S2<span class="token punctuation">;</span> <span class="token number">40</span>         S2<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S3<span class="token punctuation">;</span> <span class="token number">41</span>         S3<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S4<span class="token punctuation">;</span> <span class="token number">42</span>         S4<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S5<span class="token punctuation">;</span> <span class="token number">43</span>         S5<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S6<span class="token punctuation">;</span> <span class="token number">44</span>         S6<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S0<span class="token punctuation">;</span> <span class="token number">45</span>         <span class="token keyword">default</span><span class="token punctuation">:</span> next_st <span class="token operator">=</span> S0<span class="token punctuation">;</span><span class="token number">46</span>     <span class="token keyword">endcase</span> <span class="token number">47</span> <span class="token keyword">end</span> <span class="token number">48</span>  <span class="token number">49</span> <span class="token comment">//状态机的第三段描述状态输出（这里采用时序电路输出） </span><span class="token number">50</span> <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>  <span class="token number">51</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span> <span class="token number">52</span>         clk_divide_7 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span> <span class="token number">53</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S0<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S1<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S2<span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S3<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">54</span>         clk_divide_7  <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span> <span class="token number">55</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S4<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S5<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S6<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token number">56</span>         clk_divide_7  <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token number">57</span>     <span class="token keyword">else</span> <span class="token number">58</span>         <span class="token punctuation">;</span>  <span class="token number">59</span> <span class="token keyword">end</span> <span class="token number">60</span>  <span class="token number">61</span> <span class="token keyword">endmodule</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>第一个 <code>always</code> 语句实现同步状态跳转（如代码的第 27 至第 33 行所示），在复位的时候，当前状态处在 S0 状态，否则将下一个状态赋值给当前状态</li><li>第二个 <code>always</code> 采用组合逻辑判断状态转移条件（如代码的第 35 行至第 47 行代码所示），这里每一个状态只保持一个时钟周期，也就是直接跳转到下一个状态，在实际应用中，一般根据输入的条件来判断是否跳转到其它状态或者停留在当前转态，最后在 <code>case</code> 语句后面增加一个 <code>default</code> 语句，来防止状态机处在异常的状态；</li><li>第三个 <code>always</code> 输出分频后的时钟（如代码的第 49 至第 59 行代码所示），状态机的第三段可以使用组合逻辑电路输出，也可以使用时序逻辑电路输出，一般推荐使用时序电路输出，因为状态机的设计和其它设计一样，最好使用同步时序方式设计，以提高设计的稳定性，消除毛刺。</li></ul><p><img src="/2024/06/10/verilog-hdl/12.png"></p><ul><li>三段式可以在组合逻辑后再<strong>增加一级寄存器</strong>来实现时序逻辑输出:<ol><li>可以有效地滤去组合逻辑输出的毛刺;</li><li>可以有效地进行时序计算与约束;</li><li>另外对于总线形式的输出信号来说，容易使总线数据对齐，从而减小总线数据间的偏移，减小接收端数据采样出错的频率。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之程序固化</title>
      <link href="/2024/06/05/program-the-fpga/"/>
      <url>/2024/06/05/program-the-fpga/</url>
      
        <content type="html"><![CDATA[<h1 id="Vivado程序固化"><a href="#Vivado程序固化" class="headerlink" title="Vivado程序固化"></a>Vivado程序固化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于FPGA开发者，都会遇到这样的一种情况，就是下载到板子中的FPGA程序会随着板子掉电而消失再次上电，又要重新编译下载程序。在程序调试阶段还可以接受，但在程序版本固定后使用起来就会非常不方便。这就需要用到固化程序这一操作，就是将FPGA的配置文件烧写到板载Flash中，实现上电自启动。</p><h3 id="bin-和-mcs文件"><a href="#bin-和-mcs文件" class="headerlink" title=".bin 和 .mcs文件"></a>.bin 和 .mcs文件</h3><p>在 Vivado 中，生成的 <code>.bin</code> 和 <code>.mcs</code> 文件都是用于 FPGA 的配置和编程的，但它们在用途和格式上有一些区别。以下是对这两个文件的详细解释：</p><ul><li><p><code>.bin</code> 文件</p><ol><li>格式：<ul><li><code>.bin</code> 文件是二进制格式文件，包含 FPGA 配置所需的原始二进制数据。</li></ul></li><li>用途：<ul><li><code>.bin</code> 文件通常用于直接配置 FPGA，尤其是在使用某些编程设备或工具时，如 JTAG 编程器。</li><li>也可以用于直接加载到 FPGA 中进行配置，尤其适用于在开发和调试阶段。</li></ul></li><li>生成：<ul><li>在 Vivado 中，可以通过生成比特流后选择适当的选项生成 .bin 文件。</li></ul></li></ol></li><li><p><code>.mcs</code> 文件</p><ol><li>格式：<ul><li><code>.mcs</code> 文件是 Memory Configuration File，用于非易失性存储器（如闪存）的配置。它采用 ASCII 文本格式，以 Intel HEX 格式存储数据。</li></ul></li><li>用途：<ul><li><code>.mcs</code> 文件通常用于将配置数据写入外部存储器（如 SPI Flash），这使得 FPGA 可以在上电时自动加载配置数据。</li><li>适用于需要非易失性存储的应用场景，确保 FPGA 在每次上电后都能加载相同的配置。</li></ul></li><li>生成：<ul><li>在 Vivado 中，可以通过生成比特流后选择适当的选项生成 .mcs 文件，通常是在“Generate Memory Configuration File”选项中选择生成。</li></ul></li></ol></li><li><p>区别总结</p><ul><li><p>格式：</p><ul><li>.bin 是二进制格式，直接包含原始配置数据。</li><li>.mcs 是 ASCII 文本格式，采用 Intel HEX 格式，用于外部存储器编程。</li></ul></li><li><p>用途：</p><ul><li>.bin 文件适用于直接配置 FPGA，特别是在开发和调试阶段。</li><li>.mcs 文件适用于将配置数据写入外部非易失性存储器，确保 FPGA 上电时能自动加载配置。</li></ul></li><li><p>应用场景：</p><ul><li>如果你需要频繁更新和测试 FPGA 配置，使用 .bin 文件更为方便。</li><li>如果你需要在生产环境中部署，且 FPGA 每次上电后都需要自动加载配置，使用 .mcs 文件更合适。</li></ul></li></ul></li></ul><h2 id="生成固化文件"><a href="#生成固化文件" class="headerlink" title="生成固化文件"></a>生成固化文件</h2><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><ul><li><p>在 FPGA 设计过程中，特别是在程序固化之前，确实需要在约束文件中添加一些特定的原语（属性设置）。这些原语主要用于配置比特流生成和 FPGA 配置的详细参数，确保生成的比特流文件能够正确加载并运行。</p></li><li><p>依据Flash器件信号原理图：<img src="/2024/06/05/program-the-fpga/1.png"></p></li><li><p>需要在程序约束文件中添加如下原语：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">set_property CFGBVS VCCO <span class="token punctuation">[</span>current_design<span class="token punctuation">]</span>set_property CONFIG_VOLTAGE <span class="token number">3.3</span> <span class="token punctuation">[</span>current_design<span class="token punctuation">]</span>set_property BITSTREAM<span class="token punctuation">.</span>GENERAL<span class="token punctuation">.</span>COMPRESS true <span class="token punctuation">[</span>current_design<span class="token punctuation">]</span>set_property BITSTREAM<span class="token punctuation">.</span>CONFIG<span class="token punctuation">.</span>CONFIGRATE <span class="token number">50</span> <span class="token punctuation">[</span>current_design<span class="token punctuation">]</span>set_property BITSTREAM<span class="token punctuation">.</span>CONFIG<span class="token punctuation">.</span>SPI_BUSWIDTH <span class="token number">4</span> <span class="token punctuation">[</span>current_design<span class="token punctuation">]</span>set_property BITSTREAM<span class="token punctuation">.</span>CONFIG<span class="token punctuation">.</span>SPI_FALL_EDGE Yes <span class="token punctuation">[</span>current_design<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>以下是对每个原语的详细解释：</p><ul><li><code>set_property CFGBVS VCCO [current_design]</code>：<ul><li>作用：设置配置引脚的电压源（CFGBVS, Configuration Bank Voltage Source）。VCCO 表示配置引脚使用 I&#x2F;O 电源电压。</li><li>原因：确保配置引脚使用正确的电压，以便在配置 FPGA 时避免电压不匹配的问题。</li></ul></li><li><code>set_property CONFIG_VOLTAGE 3.3 [current_design]</code>：<ul><li>作用：设置 FPGA 配置时所使用的电压。3.3 表示 3.3V。</li><li>原因：明确指定 FPGA 配置电压，以确保 FPGA 在配置期间的稳定性和兼容性。</li></ul></li><li><code>set_property BITSTREAM.GENERAL.COMPRESS true [current_design]</code>：<ul><li>作用：启用比特流压缩。</li><li>原因：压缩比特流文件可以减少文件大小，缩短配置时间，特别是在配置数据量较大的情况下。</li></ul></li><li><code>set_property BITSTREAM.CONFIG.CONFIGRATE 50 [current_design]</code>：<ul><li>作用：设置比特流配置速率，单位为 MHz。50 表示配置速率为 50 MHz。</li><li>原因：通过设置合适的配置速率，确保 FPGA 配置过程的稳定性和速度。速率过高可能会导致配置失败，速率过低会延长配置时间。</li></ul></li><li><code>set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design]</code>：<ul><li>作用：设置 SPI 总线宽度。4 表示使用 4 位宽度的 SPI 总线（即 Quad-SPI）。</li><li>原因：使用 Quad-SPI 可以加快配置速度，因为它能够同时传输 4 位数据，比单通道 SPI 速度更快。</li></ul></li><li><code>set_property BITSTREAM.CONFIG.SPI_FALL_EDGE Yes [current_design]</code>：<ul><li>作用：配置 SPI 接口在下降沿时采样数据。</li><li>原因：有些 SPI 器件在下降沿采样数据，这一设置确保 FPGA 和 SPI 存储器之间的时序兼容性，避免数据传输错误。</li></ul></li></ul></li></ul><h3 id="生成-mcs文件"><a href="#生成-mcs文件" class="headerlink" title="生成.mcs文件"></a>生成.mcs文件</h3><h4 id="用-Vivado-控制台生成-mcs-文件"><a href="#用-Vivado-控制台生成-mcs-文件" class="headerlink" title="用 Vivado 控制台生成.mcs 文件"></a>用 Vivado 控制台生成.mcs 文件</h4><ol><li><p>如下图所示首先在工具栏找到 <code>Tools</code>，打开扩展框然后点击 <code>Generate Memory Configuration File</code><br><img src="/2024/06/05/program-the-fpga/2.png"></p></li><li><p>之后会出现器件编辑选项框<code>Create a configuration file to program the device</code>如图所示：<img src="/2024/06/05/program-the-fpga/3.png"></p><ul><li>从图中我们可以看到一些配置选项，在此仅对我们需要用到的一些配置做简要介绍：<ul><li><code>Format</code>：指的生成文件的格式，这里我们选择生成 MCS 文件。</li><li><code>Custom Memory Size（MB）</code>：指的是所用 flash 的容量大小，这里选 128（根据 flash 手册决定）。</li><li><code>Filename</code>：这里编辑生成的 mcs 文件名称，右边的三个点按钮是选择 mcs 文件保存路径。</li><li><code>Interface</code>：指的是所用 flash 的通信方式，这里我们选 SPIx4（4bit 通信 flash，根据 flash 手册决定）。</li><li><code>Load bitstream files</code>：这个选项勾上，然后添加你要生成 mcs 文件的原文件（bit 流文件）。</li><li><code>Write checksum</code>：写校验。</li><li><code>Disable bit swapping</code>：禁止位交换。</li><li><code>Overwrite</code>：覆盖原文件。</li></ul></li></ul></li><li><p>配置选项完成后点击 <code>OK</code>，会出现下图提示信息，这就代表我们 <code>.mcs</code> 文件生成成功，点击 <code>OK</code> 就行。<img src="/2024/06/05/program-the-fpga/4.png"></p></li></ol><h4 id="使用-tcl-指令生成-mcs-文件"><a href="#使用-tcl-指令生成-mcs-文件" class="headerlink" title="使用 tcl 指令生成.mcs 文件"></a>使用 tcl 指令生成.mcs 文件</h4><ol><li><p>先在信息栏窗口找到  <code>Tcl Console</code> 如下图所示：<br><img src="/2024/06/05/program-the-fpga/5.png"></p></li><li><p>然后在指令栏中输入<code>write_cfgmem -format mcs -interface SPIx4 -size 128 -loadbit &#123;up 0x0 E:/led_twinkle/led_twinkle/led_twinkle.runs/impl_1/led_twinkle.bit&#125; -file E:/led_twinkle/led_twinkle/led_twinkle.runs/impl_1/led_twinkle.mcs</code>然后按回车键就可以生成 <code>.mcs </code>文件了，指令运行成功可以看到如图所示信息：<br><img src="/2024/06/05/program-the-fpga/6.png"></p><ul><li>该指令的含义：<ul><li><code>write_cfgmem</code>：命令头。 </li><li><code>-format mcs</code>：生成文件格式为 mcs。 </li><li><code>-interface SPIx4</code>：flash 的通信协议及位宽（QSPI 也写成 SPI）。 </li><li><code>-size 128</code>：flash 容量 128M。 </li><li><code>-loadbit&#123;up0x0 E:/led_twinkle/led_twinkle/led_twinkle.runs/impl_1/led_twinkle.bit &#125;</code> ：加载 bit 流文件的路径和 bit 流文件。 </li><li><code>-file E:/led_twinkle/led_twinkle/led_twinkle.runs/impl_1/led_twinkle.mcs</code>：生成的 mcs 文件及保存路径。 </li><li>建议读者将这条指令保存下来，下次使用只需要替换一下文件路径和源文件就可以直接使用了。</li></ul></li></ul></li></ol><h3 id="生成-bin文件"><a href="#生成-bin文件" class="headerlink" title="生成.bin文件"></a>生成.bin文件</h3><h4 id="使用-Vivado-生成-bin-文件"><a href="#使用-Vivado-生成-bin-文件" class="headerlink" title="使用 Vivado 生成.bin 文件"></a>使用 Vivado 生成.bin 文件</h4><ol><li><p>首先找到 <code>Flow Navigator</code> 栏，点击 <code>Settings</code> </p><div align="center"><img src="/2024/06/05/program-the-fpga/7.png" width="40%/"></div></li><li><p>出现如下图所示的选项栏。这个选项栏中先在左边 <code>Project Settings</code> 栏选中 <code>Bitstream</code>，然后在右边的选项栏中选择<code>-bin_file</code>，之后点击 <code>Apply</code> 等待 <code>Apply</code> 按钮变成灰色，再点击 <code>OK</code>。然后我们重新生成 bit 流文件，bin 文件会同时生成，并且和 bit 流在同一个路径下。 </p><div align="center"><img src="/2024/06/05/program-the-fpga/8.png" width="80%/"></div></li></ol><h3 id="添加-flash-器件及下载固化文件"><a href="#添加-flash-器件及下载固化文件" class="headerlink" title="添加 flash 器件及下载固化文件"></a>添加 flash 器件及下载固化文件</h3><ul><li>光有固化文件还不够，我们还要添加一个固化 flash 器件。</li></ul><h4 id="没有产生-mcs-文件的情况"><a href="#没有产生-mcs-文件的情况" class="headerlink" title="没有产生 mcs 文件的情况"></a>没有产生 mcs 文件的情况</h4><ol><li>将板子连接到 PC 端，连接完成后如下图所示：</li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/9.png" width="60%/"></div><ol start="2"><li>在硬件栏中我们选中器件 <code>xc7a35t_0(1)</code>，右击后点击选择 <code>Add Configuration Memory Device</code></li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/10.png" width="60%/"></div><ol start="3"><li>刚进入<code>Add Configuration Memory Device</code>界面的时候整个 <code>Filter</code> 栏四个筛选框应该是四个 <code>ALL</code>，我们将筛选条件改成下图所示。之后你会发现最底下器件栏只剩下两个了，我们选择 <code>mt25ql128-spi-x1_x2_x4</code>，然后点击 OK。</li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/11.png" width="80%/"></div><ol start="4"><li>出现下图所示的询问栏，继续点击 <code>OK</code></li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/12.png" width="60%/"></div><ol start="5"><li>出现下图所示的选项栏，按照下图所示添加对应的 <code>.mcs</code> 文件和对应的<code>.prm</code>文件，点击 <code>OK</code></li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/13.png" width="80%/"></div><ol start="6"><li>出现下载成功，最后点击<code>OK</code></li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/14.png" width="60%/"></div><h4 id="已经产生-mcs-文件的情况"><a href="#已经产生-mcs-文件的情况" class="headerlink" title="已经产生 mcs 文件的情况"></a>已经产生 mcs 文件的情况</h4><ul><li>在所选择的 flash 的型号上右击，出现右侧的扩展框，点击扩展框内红色的方框所框的选项，出现下图所示界面，然后按照上面的操作就可以将程序固化进开发板了。</li></ul><div align="center"><img src="/2024/06/05/program-the-fpga/15.png" width="70%/"></div><p><strong>PS</strong>：固化成功后，将开发板断电重启即可。而 <code>.bin</code> 文件的下载流程和 <code>.mcs</code> 一样</p><h3 id="擦除固化文件"><a href="#擦除固化文件" class="headerlink" title="擦除固化文件"></a>擦除固化文件</h3><ol><li>在所选择的 flash 的型号上右击，出现右侧的扩展框，点击扩展框内红色的方框所框的选项</li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/16.png" width="70%/"></div><ol start="2"><li>在弹出的界面内只勾选<code>Erase</code>擦除，点击 <code>OK</code></li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/17.png" width="70%/"></div><ol start="3"><li>弹出如下界面，即表示成功擦除板子原先存在的固化文件。</li></ol><div align="center"><img src="/2024/06/05/program-the-fpga/18.png" width="60%/"></div><ol start="4"><li>断电重启开发板，会发现原来的程序将不再执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之simulator的使用</title>
      <link href="/2024/06/04/simulator-use/"/>
      <url>/2024/06/04/simulator-use/</url>
      
        <content type="html"><![CDATA[<h1 id="simulator的使用"><a href="#simulator的使用" class="headerlink" title="simulator的使用"></a>simulator的使用</h1><h2 id="Vivado-Simulato介绍"><a href="#Vivado-Simulato介绍" class="headerlink" title="Vivado Simulato介绍"></a>Vivado Simulato介绍</h2><p>Simulato是Vivado的仿真模拟器，用于硬件调试和判断代码正确性。<br>Vivado 设计套件内部集成了仿真器Vivado Simulator，能够在设计流程的不同阶段运行设计的功能仿真和时序仿真，结果可以在Vivado IDE 集成的波形查看器中显示。Vivado 还支持与诸如ModelSim、Verilog Compiler Simulator (VCS)、Questa Advanced Simulator 等第三方仿真器的联合仿真。</p><h3 id="Vivado-Simulator-仿真的意义"><a href="#Vivado-Simulator-仿真的意义" class="headerlink" title="Vivado Simulator 仿真的意义"></a>Vivado Simulator 仿真的意义</h3><ol><li><p>验证设计正确性：</p><ul><li>在实际硬件实现之前，确保你的 HDL 代码按照预期工作，验证功能正确性。</li></ul></li><li><p>发现和修复错误：</p><ul><li>在仿真过程中可以发现设计中的逻辑错误和潜在问题，避免在硬件实现后才发现这些问题，从而减少调试时间和成本。</li></ul></li><li><p>性能分析：</p><ul><li>通过仿真可以进行时序分析和性能评估，确保设计满足时序要求。</li></ul></li><li><p>快速迭代：</p><ul><li>通过仿真工具，可以快速测试设计的不同修改和优化方案，而无需每次都进行硬件综合和实现，节省时间。</li></ul></li><li><p><font color="#dd0000">硬件调试与仿真的区别</font>：</p><ul><li>硬件调试需要连接开发板，还会消耗片上资源，所以很难观察一段时间内的变化，仿真则没有这些问题，但是需要编写输入激励文件(testbench文件)。</li></ul></li></ol><h3 id="FPGA-开发流程中的仿真步骤"><a href="#FPGA-开发流程中的仿真步骤" class="headerlink" title="FPGA 开发流程中的仿真步骤"></a>FPGA 开发流程中的仿真步骤</h3><ul><li>FPGA 开发流程中的主要步骤包括编写 HDL 代码、仿真、综合、实现、调试和最终部署。在这个流程中，仿真通常在以下阶段进行：</li></ul><ol><li><p>设计编写和单元测试：</p><ul><li>在编写和完成 HDL 代码后，进行模块级别（单元测试）的仿真。这是仿真的初始阶段，用于验证单个模块的功能和行为。</li></ul></li><li><p>集成和系统测试：</p><ul><li>当多个模块集成到一起形成系统设计后，进行系统级别的仿真。这一步用于验证整个系统的功能和交互行为。</li></ul></li><li><p>综合前仿真：</p><ul><li>在进行综合（Synthesis）之前，仿真设计的 RTL（Register Transfer Level）代码，确保设计逻辑正确。</li></ul></li><li><p>综合后仿真：</p><ul><li>综合后仿真是对综合生成的网表文件进行仿真，验证综合过程中是否引入了问题，并确保综合后的设计仍然符合预期。</li></ul></li><li><p>实现后仿真：</p><ul><li>在实现（Implementation）之后，可以进行时序仿真，验证实际布线后设计的时序和功能。</li></ul></li></ol><ul><li>上述五大仿真又可以分为两大类：<strong>RTL(功能)仿真</strong>和<strong>时序仿真</strong></li><li>FPGA设计流程如下图所示：<br><img src="/2024/06/04/simulator-use/1.png"></li><li><strong>RTL仿真</strong>：也叫功能仿真或行为仿真，它跟硬件没有关系，只是检查设计的输入有没有逻辑错误或是代码有没有错误。主旨在于验证电路的功能是否符合设计要求，其特点是不考虑电路门延迟与线延迟(硬件延迟)，主要是验证电路与理想情况是否一致。</li><li><strong>时序仿真</strong>：也称为布局布线后仿真，是指电路已经映射到特定的工艺环境以后，综合考虑电路的路径延迟与门延迟的影响，验证电路能否在一定时序条件下满足设计构想的过程，能较好地反映芯片的实际工作情况。时序仿真会考虑走线的延迟，真实情况下<u>一般进行RTL仿真，时序仿真很少使用</u>。时序满足与否一般在时序分析中进行。</li><li><strong>功能仿真</strong>与<strong>时序仿真</strong>的<strong>主要区别</strong>在于<u>是否考虑硬件延迟</u>。</li><li>本文主要讲述功能仿真</li></ul><h2 id="功能仿真-TB文件创建"><a href="#功能仿真-TB文件创建" class="headerlink" title="功能仿真 - TB文件创建"></a>功能仿真 - TB文件创建</h2><h3 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h3><ul><li>仿真文件创建步骤同前文《Vivado的使用》中源文件创建步骤几近相同</li></ul><ol><li><p>添加或创建一个仿真文件(<code>testbench</code>文件)<br><img src="/2024/06/04/simulator-use/2.png"></p></li><li><p>选择创建仿真文件，当然也可同源文件步骤一样，现在直接添加仿真文件<br><img src="/2024/06/04/simulator-use/3.png"></p></li><li><p>输入仿真文件名<code>tb_led_twinkle</code>。一般命名为<code>tb_</code>+<code>模块名</code>。点击<code>OK</code>后，会自动生成<code>tb_led_twinkle.v</code>文件。最后点击<code>Finish</code>。<br><img src="/2024/06/04/simulator-use/5.png"></p></li><li><p>完成仿真文件创建。在弹出的自动定义模块窗口中我们直接点击<code>OK</code> 即可。而后弹出的下图窗口提醒用户在定义模块和指定 I&#x2F;O 端口时，没有进行任何更改并确认是否要继续使用当前值。<br><img src="/2024/06/04/simulator-use/4.png"></p></li><li><p>此时，在工程目录下会生成<code>tb_led_twinkle.v</code>文件。点击该文件打开<br><img src="/2024/06/04/simulator-use/6.png"></p></li></ol><h3 id="TB文件简介"><a href="#TB文件简介" class="headerlink" title="TB文件简介"></a>TB文件简介</h3><ul><li><p>TB文件(testbench文件)结构：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span>  仿真单位<span class="token operator">/</span>仿真精度<span class="token keyword">module</span> <span class="token function">test_bench</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//通常testbench没有输入与输出端口</span><span class="token comment">//信号或变量定义声明，定义为wire或reg类型</span><span class="token comment">//使用initial或always语句产生激励波形</span><span class="token comment">//例化设计模块</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>若仿真单位&#x2F;仿真精度分别为：1ns&#x2F;1ps，则：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">#200</span> <span class="token comment">//取决于仿真单位，这里就是延迟200ns</span><span class="token number">#200</span><span class="token punctuation">.</span><span class="token number">123</span> <span class="token comment">//表示延迟200.123ns，因为其精度为ps，若精度改为1ns，这里就是延迟200ns</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>本次实验，<code>tb_led_twinkle.v</code>的内容如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns <span class="token operator">/</span> <span class="token number">1</span>ps<span class="token keyword">module</span> <span class="token function">tb_led_twinkle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> sys_clk<span class="token punctuation">;</span><span class="token keyword">reg</span> sys_rst_n<span class="token punctuation">;</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> led<span class="token punctuation">;</span> <span class="token comment">//初始化</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>sys_clk <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>sys_rst_n <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token number">#200</span> <span class="token comment">//延迟200ns</span>sys_rst_n <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span> <span class="token comment">//延迟200ns后拉高复位信号</span><span class="token keyword">end</span> <span class="token comment">//时钟生成</span><span class="token important">always</span> <span class="token number">#10</span> sys_clk <span class="token operator">=</span> <span class="token operator">~</span>sys_clk<span class="token punctuation">;</span> <span class="token comment">//时钟频率为50MHZ，周期为20ns，因此每延迟10ns，时钟翻转一次</span><span class="token comment">//例化模块，一般格式为：模块名_例化名，例化名一般为u_模块名</span>led_twinkle <span class="token function">u_led_twinkle</span><span class="token punctuation">(</span>    <span class="token punctuation">.</span>sys_clk <span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment">//系统时钟，命名自定义，可相同</span><span class="token punctuation">.</span>sys_rst_n <span class="token punctuation">(</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">//系统复位，低电平有效</span><span class="token punctuation">.</span>led <span class="token punctuation">(</span>led<span class="token punctuation">)</span>                 <span class="token comment">//LED灯</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="仿真具体步骤"><a href="#仿真具体步骤" class="headerlink" title="仿真具体步骤"></a>仿真具体步骤</h2><h3 id="仿真界面窗口介绍"><a href="#仿真界面窗口介绍" class="headerlink" title="仿真界面窗口介绍"></a>仿真界面窗口介绍</h3><p><img src="/2024/06/04/simulator-use/9.png"></p><ul><li><p>窗口1：<strong>Scope 窗口</strong></p><ul><li><code>Scope</code>（范围）是HDL 设计的层次划分。在<code>Scope</code>窗口中，您可以看到设计层次结构。</li><li>当您选择了一个Scope 层次结构中的作用域时，该作用域内的<strong>所有HDL 对象</strong>，包括reg、wire 等都会出现在<code>Objects</code>窗口中。</li><li><u>比如原本的在<code>Objects</code>窗口中，是没有<code>cnt</code>计数器对象的，而我们在<code>Scope</code> 窗口中选择<code>u_led_twinkle</code>，在<code>Objects</code>窗口中就会自动显示出<code>led_twinkle</code>模块中所有的对象。</u>如下图所示：</li><li><img src="/2024/06/04/simulator-use/11.png"></li></ul></li><li><p>窗口2：<strong>Object窗口</strong></p><ul><li><code>Objects</code>窗口会显示在<code>Scopes</code>窗口中选择的范围内的所有HDL 仿真对象。</li><li>若我们选择<code>tb_led_twinkle</code>，则<code>Objects</code>窗口中会显示<code>tb_led_twinkle</code>模块中的所有对象，如下图所示：</li><li><img src="/2024/06/04/simulator-use/12.png"></li><li>可以在<code>Objects</code>窗口中选择HDL 对象，并将它们添加到波形窗口中。</li><li><img src="/2024/06/04/simulator-use/10.png"></li></ul></li><li><p>窗口3：<strong>波形窗口</strong></p><ul><li>用于显示所要观察信号的波形。</li><li>若要添加信号，可通过<code>Objects</code>窗口选择信号，然后将其添加到波形窗口中。</li><li>基本功能与ILA调试窗口中类似，不再赘述。比起ILA调试窗口，波形窗口中多了如下功能：</li><li><img src="/2024/06/04/simulator-use/13.png"></li><li>如上图所示，可通过<strong>按键1</strong>添加蓝色的<strong>时间标识2、3</strong>。而最后会显示如<strong>位置4</strong>所示的两个时间标识的时间间隔，如图所示的20ns。</li></ul></li><li><p>界面4：仿真工具栏。</p><ul><li>仿真工具栏包含运行各个仿真动作的命令按钮，从左至右依次是：</li><li><img src="/2024/06/04/simulator-use/14.png"><ul><li><code>Restart</code>：将仿真时间重置为零，此时波形窗口中原有的波形都会被清除。下次执行仿真时，会从0时刻重新开始。</li><li><code>Run all</code>：运行仿真，直到其完成所有事件或遇到HDL语句中的<code>stop</code>或<code>finish</code>命令为止。注意，如果没有在TestBench语句中加入<code>stop</code>或<code>finish</code>命令，当点击<code>Run all</code>命令时，仿真器会无休止地一直仿真下去，除非用户点击仿真工具栏中的<code>Break</code>按钮来手动地结束仿真。但是，如果此时需要仿真的设计比较复杂，则仿真器在运行仿真时会耗费电脑大量的CPU和内存资源，此时有可能会造成电脑卡顿甚至死机的情况。所以，如果设计比较复杂，且没有在TestBench 语句中加入stop或finish命令，<font color="#dd0000">最好不要轻易点击Run all命令</font>。</li><li><code>Run For</code>：运行特定的一段时间。紧随在后面的两个文本框用于设定仿真时长的数值大小和时间单位。</li><li><code>Step</code>：按步运行仿真，每一步仿真一个HDL 语句。</li><li><code>Break</code>：暂停当前仿真。</li><li><code>Relaunch</code>：重新编译仿真源并重新启动仿真。在使用Vivado 仿真器来调试HDL 设计时，您可能会根据仿真结果来对您的HDL 源代码进行修改。在修改完HDL 源代码后，可以点击Relaunch 按钮来重新加载UUT 设计和TestBench，以重新对修改后的HDL 源代码进行仿真。此时就不需要再关闭并重新打开仿真器了</li></ul></li></ul></li></ul><h3 id="仿真前的实验准备"><a href="#仿真前的实验准备" class="headerlink" title="仿真前的实验准备"></a>仿真前的实验准备</h3><ul><li>在仿真时遇到类似于<code>cnt</code>计数器这类变量，以本次<code>led_twinkle</code>为例，需要将<code>cnt</code>变量数值可达50000000，若在仿真中达到该值需要过长的时间，不利于观察，所以需要将其量级降低。如图所示：<br><img src="/2024/06/04/simulator-use/8.png"></li><li>同时图中预留一个错误，使得<code>led</code>信号为<code>10</code>和<code>01</code>时间不相同。</li></ul><h3 id="仿真步骤"><a href="#仿真步骤" class="headerlink" title="仿真步骤"></a>仿真步骤</h3><ol><li><p>在<code>Flow Navigator</code>窗口中点击<code>Run Simulation</code>并选择<code>Run Behavioral Simulation</code><br><img src="/2024/06/04/simulator-use/7.png"></p><ul><li>其余几个选项：<ul><li><strong>Run Behavior Simulation</strong> <font color="#dd0000">功能仿真(主要使用的)</font></li><li>Run Post-Systhesis Functional Simulation 综合后的功能仿真</li><li>Run Post-Systhesis Timing Simulation 综合后的时序仿真</li><li>Run Post-Implementation Functional Simulation 实现后&#x2F;布局布线后的功能仿真</li><li>Run Post-Implementation Timing Simulation 实现后&#x2F;布局布线后的时序仿真</li></ul></li></ul></li><li><p>而后我们进入仿真窗口，具体窗口作用功能在前文《仿真界面窗口介绍》这一栏中提到，这里不在赘述。在<code>Scope</code> 窗口中选择<code>u_led_twinkle</code>，而后在<code>Objects</code>窗口中选择<code>sys_clk</code>、<code>sys_rst_n</code>、<code>led</code>和<code>cnt</code>信号，而后在波形窗口中添加这4个对象。<br><img src="/2024/06/04/simulator-use/15.png"></p></li><li><p>开始分析仿真波形，选择<code>led</code>信号为<code>10</code>的波形进行测量，添加蓝色时间标识，如下图所示：<br><img src="/2024/06/04/simulator-use/16.png"></p><ul><li>发现<code>led</code>信号为<code>10</code>的波形在仿真时，持续120ns，为6个时钟周期。</li><li>同理，对<code>led</code>信号为<code>10</code>的波形进行测量，发现其持续80ns，为4个时钟周期。</li><li>发现其时间不相同，查看代码中可发现<code>assign led = (cnt &lt; 26&#39;d4) ? 2&#39;b01:2&#39;b10;</code>该语句错误，应该改为<code>assign led = (cnt &lt; 26&#39;d5) ? 2&#39;b01:2&#39;b10;</code></li><li>在<code>led_twinkle.v</code>文件中修改后，重新编译仿真源文件，点击<code>Relaunch</code>按钮，重新加载UUT，如图所示修改成功</li><li><img src="/2024/06/04/simulator-use/17.png"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之ILA的使用</title>
      <link href="/2024/05/29/ila-use/"/>
      <url>/2024/05/29/ila-use/</url>
      
        <content type="html"><![CDATA[<h1 id="ILA的使用"><a href="#ILA的使用" class="headerlink" title="ILA的使用"></a>ILA的使用</h1><h2 id="何为ILA"><a href="#何为ILA" class="headerlink" title="何为ILA"></a>何为ILA</h2><p>Integrated Logic Analyzer (ILA) 是Xilinx Vivado工具套件中的一个强大调试工具，用于在FPGA设计中嵌入并调试内部信号。ILA允许你在不影响设计运行的情况下捕获和分析信号波形，是调试和验证FPGA设计的重要工具。</p><h3 id="ILA的功能"><a href="#ILA的功能" class="headerlink" title="ILA的功能"></a>ILA的功能</h3><ol><li><p><strong>实时数据捕获：</strong></p><ul><li>可以在设计运行时捕获内部信号的数据波形，帮助你理解和调试设计的行为。</li></ul></li><li><p><strong>复杂的触发条件：</strong></p><ul><li>支持设置复杂的触发条件，以捕获特定事件或信号状态。触发条件可以是信号的上升沿、下降沿或特定值。</li></ul></li><li><p><strong>多通道支持：</strong></p><ul><li>可以同时监控多个信号通道，每个通道可以设置不同的触发条件和采样深度。</li></ul></li><li><p><strong>信号分析：</strong></p><ul><li>捕获的数据波形可以在Vivado的波形窗口中进行详细分析，支持放大、缩小、测量时间间隔等功能。</li></ul></li></ol><h3 id="ILA的工作流程"><a href="#ILA的工作流程" class="headerlink" title="ILA的工作流程"></a>ILA的工作流程</h3><ol><li><p><strong>插入ILA IP核：</strong></p><ul><li>在设计中插入ILA IP核，并将需要监控的信号连接到ILA IP核的输入端口。</li></ul></li><li><p><strong>配置ILA IP核：</strong></p><ul><li>配置ILA的触发条件、采样深度、采样率等参数。可以在Vivado的IP Integrator<br>或在原理图中进行配置。</li></ul></li><li><p><strong>综合和实现设计：</strong></p><ul><li>对插入了ILA的设计进行综合、实现和生成比特流。</li></ul></li><li><p><strong>下载比特流到FPGA：</strong></p><ul><li>使用Vivado的硬件管理器将生成的比特流文件下载到FPGA。</li></ul></li><li><p><strong>设置触发条件并启动捕获：</strong></p><ul><li>在硬件管理器中设置触发条件并启动数据捕获。ILA会在触发条件满足时捕获信号数据，并将其传回Vivado。</li></ul></li><li><p><strong>分析数据波形：</strong></p><ul><li>捕获的数据波形会显示在Vivado的波形窗口中，供用户分析和调试。</li></ul></li></ol><h3 id="使用ILA的优势"><a href="#使用ILA的优势" class="headerlink" title="使用ILA的优势"></a>使用ILA的优势</h3><ol><li><p><strong>无需外部硬件：</strong></p><ul><li>不需要额外的逻辑分析仪硬件，直接利用FPGA内部资源进行调试，降低了成本和复杂度。</li></ul></li><li><p><strong>实时调试：</strong></p><ul><li>可以在设计运行的同时进行调试，捕获实际工作环境下的信号行为，提供更准确的调试信息。</li></ul></li><li><p><strong>深入内部信号：</strong></p><ul><li>可以监控并捕获FPGA内部信号，这些信号在外部是不可见的，提供了更深入的调试能力。</li></ul></li></ol><h2 id="配置ILA"><a href="#配置ILA" class="headerlink" title="配置ILA"></a>配置ILA</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>本次实验将前文的led灯交替闪烁的程序<code>led_twinkle</code>作为调试对象，将其修改为错误程序，具体如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">led_twinkle</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>   sys_clk<span class="token punctuation">,</span>    <span class="token comment">//系统时钟</span>    <span class="token keyword">input</span>   sys_rst_n<span class="token punctuation">,</span>    <span class="token comment">//N系统复位，低电平有效</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> led    <span class="token comment">//LEDT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">////////////////////reg define</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span>  <span class="token comment">//修改错误1</span><span class="token comment">/////////////////</span><span class="token comment">//      main code</span><span class="token comment">////////////////</span><span class="token comment">//对计数器的值进行判断，以输出LED的状态</span><span class="token keyword">assign</span> led <span class="token operator">=</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> <span class="token number">26'd2500_0000</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b01</span><span class="token punctuation">:</span><span class="token number">2'b10</span><span class="token punctuation">;</span><span class="token comment">//计数器在0“5000 000之间进行计数</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>sys_rst_n<span class="token punctuation">)</span>   <span class="token comment">//修改错误2</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">26'd0</span><span class="token punctuation">;</span><span class="token comment">//    else if(cnt &lt; (25'd2500_0000 - 25'd1))</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> <span class="token number">26'd5000_0000</span><span class="token punctuation">)</span>          cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">26'd0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体错误为：</p><ul><li>计数器<code>cnt</code>的定义由<code>reg [26:0] cnt;</code>改为<code>reg [8:0] cnt; </code></li><li>逻辑判断中，时钟复位信号<code>sys_rst_n</code>，由<code>if(!sys_rst_n) cnt &lt;= 26&#39;d0;</code>改为<code>if(sys_rst_n) cnt &lt;= 26&#39;d0;</code></li></ul><h3 id="方法一：使用IP核创建ILA调试环境"><a href="#方法一：使用IP核创建ILA调试环境" class="headerlink" title="方法一：使用IP核创建ILA调试环境"></a>方法一：使用IP核创建ILA调试环境</h3><ol><li>点击左侧<code>PROJECT MANAGER</code>栏 → <code>IP Catalog</code>或者菜单栏下<code>Window</code> → <code>IP Catalog</code>，然后在右侧出现的<code>IP Catalog</code>窗口下搜索<code>ILA</code>，双击选择<code>Debug</code>下的<code>ILA</code>进行IP配置，操作步骤如下图所示：</li></ol><div align="center"><img src="/2024/05/29/ila-use/11.png" width="100%/"></div><ol start="2"><li><p>ILA IP参数设置</p><div align="center"><img src="/2024/05/29/ila-use/12.png" width="70%/"></div></li><li><p><strong>Documentation</strong>：IP 相关文档入口，其中的<code>Product Guide</code> 是 IP 手册查看入口，<code>Change Log</code> 是 IP 版本更新记录，<code>Product Webpage</code>是 IP 相关介绍的网页版</p></li><li><p><strong>IP Location</strong>：设置 IP 的存放路径入口，<strong>点击出现如下图所示窗口</strong>，在窗口里可以通过点击<code>…</code>设置更换存放路径，默认是存放在工程路径下的<code>…&lt;工程名&gt;.srcs\ sources_1\ip</code>，这里我们就保持默认。</p></li><li><p><strong>Switch to Default</strong>：点击后所有的设置恢复到默认值。</p></li></ol><div align="center"><img src="/2024/05/29/ila-use/13.png" width="90%/"></div><ol start="4"><li><p><strong>Component Name</strong>：设置生成 IP Core 的名称，这里保持默认设置。</p></li><li><p>这里是一个提示，提示通过该界面设置最多可设置 64 个探针，如果想设置更多的探针需要使用 Tcl 脚本命令去设置，具体用法可以查询 IP 手册。</p></li><li><p><strong>ILA 探针接口类型设置</strong>  </p><ul><li>Native：常规普通接口模式</li><li>AXI：AXI 接口模式，用于调试 AXI 接口信号</li></ul></li><li><p><font color="#dd0000">Number of Probes</font>：探针数量设置，要观察3个信号，所以这里设置探针数量为3。</p></li><li><p><font color="#dd0000">Sample Data Depth</font>：采样数据深度，设置的数值越大，采样的数据越多，看到的波形数据越多，但是最终占用的资源也会越多，并不是设置的越大越好。从下拉框也能看出最大也只能设置为 131072，这个根据实际需求进行合适的设置即可，我们这里选择设置 4096。</p></li></ol><ul><li>PS：<strong>Number of Probes</strong>和<strong>Sample Data Depth</strong>是最重要的两个设置</li></ul><div align="center"><img src="/2024/05/29/ila-use/15.png" width="80%/"></div><ol start="9"><li><strong>Same Number of Comparators for All Probe Ports</strong>：这里是设置相同探针接口的 Comparators 的个数，不勾选，下面的 Number of Comparators 就会消失。如果默认勾选，后面的参数也保持默认，我们不勾选。</li><li><strong>Trigger Out Port</strong>：触发输出端口，可用于 ILA 模块的级联或一些高级功能，具体使用参考 IP 手册，这里保持默认不勾选。</li><li><strong>Trigger In Port</strong>：触发输入端口，可用于手工设置添加触发信号或进行 ILA模块的级联或一些高级功能，具体使用参考 IP 手册，这里保持默认不勾选。</li><li><strong>Input Pipe Stages</strong>：设置待探测信号打拍次数，如下图所示，可设置数值0~6，一般情况下，采样时钟和探测信号是一个时钟域下，这里可以默认设置为 0 即<br>可。</li><li><strong>Capture Control</strong>：这里勾选后可在调试查看波形窗口进行对 Capture mode的设置，如果不勾选后面有关 Capture mode 就不可修改，这里不勾选。</li><li><strong>Advanced Trigger</strong>：这里勾选后可在调试查看波形窗口进行对 Trigger mode的设置，如果不勾选后面有关 Trigger mode 就不可修改，这里不勾选。</li></ol><div align="center"><img src="/2024/05/29/ila-use/14.png" width="80%/"></div><ol start="15"><li><strong>Probe_Ports</strong>：这个选项卡用于配置ILA的探针端口。探针端口是用来连接和监控设计中内部信号的。</li><li><strong>Probe Width</strong>：探针数据信号的位宽设置，我们需要对一个 1bit，一个 2bit 和一个9bit信号进行在线观察，这里将<code>Probe0</code>位宽设置为 1，<code>Probe1</code>位宽设置为2和<code>Probe2</code>位宽设置为9。</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">input</span>   sys_rst_n；   <span class="token comment">//复位信号，1位</span><span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> led；    <span class="token comment">//led输出信号，2位</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span>        <span class="token comment">//计数器，9位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="17"><li><strong>Number of Comparators</strong>：如果已经勾选（9）处，这里就不可设置，如果没有勾选，这里就可以设置。保持默认即可</li><li><strong>Probe Trigger or Data</strong>：对探针设置触发器或数据，有3种选项：<br>-  DATA AND TRIGGER：既是数据又可作为触发条件；<br>-  DATA：仅作为数据，不可作为触发条件；<br>-  TRIGGER：仅可作为触发条件。</li></ol><p>设置完成后点击下方<code>OK</code> → <code>Generate</code>生成IP核</p><h3 id="方法二：使用-Debug-标记创建-ILA"><a href="#方法二：使用-Debug-标记创建-ILA" class="headerlink" title="方法二：使用 Debug 标记创建 ILA"></a>方法二：使用 Debug 标记创建 ILA</h3><ol><li>在左侧<code>SYNTHESIS</code>栏下展开<code>Open Synthesized Design</code>，然后点击<code>Schematic</code>，打开原理图，操作步骤如下图所示：</li></ol><div align="center"><img src="/2024/05/29/ila-use/16.png" width="70%/"></div><ol start="2"><li>调整窗口为Debug模式，点击右上角栏下的<code>Debug</code>：</li></ol><div align="center"><img src="/2024/05/29/ila-use/17.png" width="100%/"></div><ol start="3"><li>标记所需的调试信号，以<code>led_OBUF</code>为例，右键点击<code>led_OBUF</code>，在弹出的窗口中点击<code>Makr Debug</code>，如下图所示：</li></ol><div align="center"><img src="/2024/05/29/ila-use/20.png" width="60%/"></div><ul><li>选择<code>led_OBUF</code>而不是<code>led</code>信号的原因：由于<code>led</code>是输出端口不能直接添加标记，又因为该信号为输出信号，所以是<code>OBUF</code>，因此需要选择<code>led_OBUF</code>缓冲进行标记。</li><li>同理，<code>sys_rst_n_IBUF</code>作为输入端口，也需要进行标记</li><li>而选择不是输入输出端口的信号，如<code>cnt</code>等，则可以<strong>直接进行标记</strong>。但是由于其没有缓冲，Vivado在分析综合的时候，可能会对其优化，导致报错。<strong>为此需要在代码中对</strong><code>cnt</code><strong>定义添加一段语句：</strong><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">(</span><span class="token operator">*</span>mark_debug<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><font color="#dd0000">上面那一步最好在综合前完成</font></li><li>最后可在下方窗口查看到所添加的信号：</li></ul><ol start="4"><li>配置调试环境，可点击<code>Open Synthesized Design</code>栏下的<code>Set up Debug</code>，或者点击下方的<strong>小甲虫</strong>，如下图所示：</li></ol><div align="center"><img src="/2024/05/29/ila-use/18.png" width="100%/"></div><ol start="5"><li>出现向导框，点击<code>Next</code></li></ol><div align="center"><img src="/2024/05/29/ila-use/19.png" width="100%/"></div><ol start="6"><li>显示添加的信号，继续点击<code>Next</code></li></ol><div align="center"><img src="/2024/05/29/ila-use/21.png" width="100%/"></div><ol start="7"><li>同IP核创建ILA，继续点击<code>Next</code><ul><li>Sample Data Depth：采样数据深度，设置的数值越大，采样的数据越多，看到的波形数据越多，但是最终占用的资源也会</li><li>Input Pipe Stages：在FPGA设计中通常指输入管道级的数量。这是在信号进入一个模块或系统之前通过的寄存器级数。一般设置为2以上，本次实验简单，因此可设置为0.</li></ul></li></ol><div align="center"><img src="/2024/05/29/ila-use/23.png" width="100%/"></div><ol start="8"><li>点击<code>Finish</code>，完成添加ILA</li></ol><h2 id="ILA的调试"><a href="#ILA的调试" class="headerlink" title="ILA的调试"></a>ILA的调试</h2><h3 id="调试界面基本介绍"><a href="#调试界面基本介绍" class="headerlink" title="调试界面基本介绍"></a>调试界面基本介绍</h3><div align="center"><img src="/2024/05/29/ila-use/22.png" width="100%/"></div><ul><li><p>窗口1：波形显示窗口，可以通过点击➕添加想查看的波形的信号。在这里可查看的信号有 <code>cnt</code>、<code>led_OBUF</code>和<code>sys_rst_n_IBUF</code>。<br>当然，通常在下载完程序后，ILA 能够非常智能的识别出设计师期望观察的信号，同时，在右键菜单也可以找到删除观察信号的指令。这样，有限的窗口面积就可以被充分利用，自由调配和增减所需观察信号的条目。</p></li><li><p>窗口2：ILA Croe 的状态控制和显示窗口。<br><img src="/2024/05/29/ila-use/24.png"></p><ul><li>按钮①：设置采样执行过程为循环采样</li><li>按钮②：启动采样按钮。按下后将启动 ILA 采样。根据是单次采样还是循环采样，根据是有条件触发还是无条件触发，启动后会呈现 ILA 状态的周期性变化或等待触发条件的到来。</li><li>按钮③：无条件执行 ILA 采样。</li><li>按钮④：停止采样按钮。</li><li>状态栏⑤：状态栏⑤由 5 个空心圈组成，唯一的实心绿色点所处的位置表征ILA 的运行状态。</li><li>状态栏⑥：已采集的点数占总采集点数的关系。</li><li>状态栏⑦：以进度条的方式结合状态名称，标明当前所处的状态以及采样过程中执行状态的百分比。</li></ul></li><li><p>窗口3：添加触发信号窗口，如下图所示，点击窗口内➕ 添加产生触发条件的信号（两个地方的➕ 都可以进行信号的添加）。<br><img src="/2024/05/29/ila-use/25.png"></p><ul><li><p>点击按该钮在这里插入图片描述设置多个信号产生触发信号时的条件，与、或、同或、异或，还可以设置触发条件，如下图所示：<br>  <img src="/2024/05/29/ila-use/26.png"></p></li><li><p>基数（Radix），即选择数值表示的进制。<br>  <img src="/2024/05/29/ila-use/27.png"></p><ul><li>[B] (Binary)：二进制格式</li><li>[H] (Hexadecimal)：十六进制格式</li><li>[O] (Octal)：八进制格式</li><li>[U] (Unsigned Decimal)：无符号十进制格式</li><li>[S] (Signed Decimal)：有符号十进制格式</li></ul></li><li><p>触发值（Value），选择用于触发条件的具体值或条件<br>  <img src="/2024/05/29/ila-use/28.png"></p><ul><li><code>X (don&#39;t care)</code>：无所谓的值，表示忽略这个条件。</li><li><code>0 (logical zero)</code>：逻辑零。</li><li><code>1 (logical one)</code>：逻辑一。</li><li><code>R (0-to-1 transition)</code>：从0到1的跳变。</li><li><code>F (1-to-0 transition)</code>：从1到0的跳变。</li><li><code>B (both transitions)</code>：两种跳变（从0到1和从1到0）。</li><li><code>N (no transitions)</code>：没有跳变。</li></ul></li></ul></li></ul><h3 id="ILA具体调试步骤"><a href="#ILA具体调试步骤" class="headerlink" title="ILA具体调试步骤"></a>ILA具体调试步骤</h3><ol><li><strong>烧录程序</strong><ul><li>该步骤同前文的连接开发板验证</li><li>先点击左侧<code>PROGERAM AND DEBUG</code>栏下的<code>Generate Bitstream</code>，生成比特流文件，然后点击<code>Open Hardware Manager</code>。与前文不同的是，会将比特流文件和<strong>自动相关联的Debug文件</strong>一起烧录进板卡，如下所示：</li></ul></li></ol><div align="center"><img src="/2024/05/29/ila-use/1.png" width="70%/"></div><ol start="2"><li><strong>添加产生触发条件的信号</strong></li></ol><div align="center"><img src="/2024/05/29/ila-use/2.png" width="100%/"></div><ol start="3"><li><strong>点击运行</strong><code>Run</code><strong>，观察波形。</strong></li></ol><div align="center"><img src="/2024/05/29/ila-use/3.png" width="70%/"></div><ul><li>所查波形为下图所示：</li></ul><div align="center"><img src="/2024/05/29/ila-use/4.png" width="1000%/"></div><ul><li>可见，采样一次，计数器<code>cnt</code>为<code>0</code>没有计数，<code>led_OBUF</code>为<code>1</code>即<code>led0</code>灯亮。</li></ul><ol start="4"><li><strong>点击循环采样，运行</strong><code>Run</code><strong>，观察波形。</strong></li></ol><div align="center"><img src="/2024/05/29/ila-use/5.png" width="100%/"></div><ul><li>所查波形一般是为动态图，但由于本实验代码问题，与采样一次的波形一致。</li><li>可见，计数器<code>cnt</code>始终为<code>0</code>，<code>led_OBUF</code>始终为<code>1</code>，<code>sys_rst_n_IBUF</code>始终为高电平</li><li><strong>注意</strong>，在一般正常工作中，不能单单通过一次采样没有得到预想的数据就认为代码或者是硬件有问题。由于一些元器件初始化需要时间或是其他原因，可能正好采样到错误数据，需要多次采样才能确认。</li></ul><ol start="5"><li><strong>添加触发条件</strong></li></ol><ul><li><p>添加触发条件的原因：</p><ul><li>可能正确的值出现时间很短，无法在波形上直接观察到，需要添加触发条件。</li><li>添加触发条件可以大大提高调试效率。直接查看波形可能需要你手动筛选大量数据，以找到问题发生的时刻。而触发条件可以自动化这个过程，一旦条件满足就开始捕获，省去了大量手动查找的时间。</li><li>FPGA 内部的存储资源有限，ILA 的存储深度也有限。如果没有触发条件，ILA 会持续捕获数据，很快就会耗尽存储资源，可能错过关键事件</li></ul></li><li><p>可通过结果逆推，先由<code>led_OBUF</code>信号，反推到<code>cnt</code>计数器，再反推到<code>sys_rst_n_IBUF</code>复位信号。</p></li><li><p>添加<code>led_OBUF</code>的触发条件</p><div align="center"><img src="/2024/05/29/ila-use/6.png" width="100%/"></div></li><li><p>改触发条件进制为二进制，数值为二进制<code>10</code>，观察是否存在<code>led1</code>点亮的情况</p><div align="center"><img src="/2024/05/29/ila-use/7.png" width="80%/"></div></li><li><p>添加触发条件后，点击<code>Run</code>运行，观察波形。</p><div align="center"><img src="/2024/05/29/ila-use/8.png" width="100%/"></div></li><li><p>可见，<code>led_OBUF</code>不存在为<code>10</code>时刻。</p></li><li><p>由此反推至<code>cnt</code>计数器，观察其值。其数值始终为0，说明<code>cnt</code>没有计数，而<code>cut</code>又与<code>sys_rst_n_IBUF</code>有关。观察到<code>sys_rst_n_IBUF</code>始终为高电平，由此可尝试观察其为低电平时，<code>cnt</code>计数器情况</p></li></ul><ol start="6"><li><strong>根据情况调试</strong></li></ol><ul><li>由上一步可知，需要观察<code>sys_rst_n_IBUF</code>为低电平时，<code>cnt</code>计数器情况。</li><li>具体步骤：<ol><li>长按开发板的led灯复位键</li><li><code>Run</code>运行  </li><li>观察波形</li></ol></li></ul><div align="center"><img src="/2024/05/29/ila-use/9.png" width="80%/"></div><ul><li>可见，<code>sys_rst_n_IBUF</code>为低电平时，<code>cnt</code>计数器值出现变化，且经过多次采样，<code>cnt</code>计数器值开始逐渐增加。</li><li>由此发现 <strong><font color="#dd0000">第一个错误</font></strong> ，需要将时钟复位信号<code>sys_rst_n</code>，由<code>if(sys_rst_n) cnt &lt;= 26&#39;d0;</code>改为<code>if(!sys_rst_n) cnt &lt;= 26&#39;d0;</code></li></ul><ol start="7"><li><strong>继续添加触发条件</strong></li></ol><ul><li>添加<code>cnt</code>计数器的触发条件，观察其值。本次实验会使得<code>cnt</code>达到<code>25000000</code>，变化<code>led</code>的值，由此需要观察其是否能到达<code>25000000</code>。</li><li>由此添加<code>cnt</code>计数器的触发条件，改为十进制，数值为<code>25000000</code></li></ul><div align="center"><img src="/2024/05/29/ila-use/10.png" width="80%/"></div><ul><li>发现直接报错，发现0至8的位宽，<code>cnt</code>无法达到<code>25000000</code>。</li><li>由此发现 <strong><font color="#dd0000">第二个错误</font></strong> ，需要将计数器<code>cnt</code>的定义由<code>reg [26:0] cnt;</code>改为<code>reg [8:0] cnt; </code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习笔记之vivado使用</title>
      <link href="/2024/05/29/vivado-use/"/>
      <url>/2024/05/29/vivado-use/</url>
      
        <content type="html"><![CDATA[<h1 id="Vivado的使用"><a href="#Vivado的使用" class="headerlink" title="Vivado的使用"></a>Vivado的使用</h1><p>Vivado设计套件，是赛灵思(Xilinx)公司最新的为其产品定制的集成开发环境，支持Block Design、Verilog、VHDL等多种设计输入方式，内嵌综合器以及仿真器,可以完成从设计输入、综合适配、仿真到下载的完整FPGA设计流程。</p><p><strong>注意:本文使用的是Vivado的开发环境2018.3版本</strong></p><h2 id="Vivado-开发流程"><a href="#Vivado-开发流程" class="headerlink" title="Vivado 开发流程"></a>Vivado 开发流程</h2><div align="center"><img src="/2024/05/29/vivado-use/1.png" width="80%/"></div><h2 id="Vivado-新建工程"><a href="#Vivado-新建工程" class="headerlink" title="Vivado 新建工程"></a>Vivado 新建工程</h2><ol><li><p><strong>首次进入Vivado的界面：</strong></p><div align="center"><img src="/2024/05/29/vivado-use/2.png" width="100%/"></div></li><li><p><strong>创建新的一个项目：</strong></p><div align="center"><img src="/2024/05/29/vivado-use/5.png" width="100%/"></div></li><li><p><strong>输入项目名称：</strong></p><div align="center"><img src="/2024/05/29/vivado-use/3.png" width="100%/"></div></li><li><p><strong>选择项目的性质：</strong></p><div align="center"><img src="/2024/05/29/vivado-use/4.png" width="100%/"></div></li><li><p><strong>本文采用的是正点原子的达芬奇FPGA开发板，选择型号芯片</strong><code>xc7a35tfgg484-2</code><strong>型号芯片</strong></p></li></ol><div align="center"><img src="/2024/05/29/vivado-use/6.png" width="100%/"></div><ol start="6"><li><strong>点击</strong><code>Finish</code><strong>，完成项目创建。</strong></li></ol><div align="center"><img src="/2024/05/29/vivado-use/7.png" width="100%/"></div><h2 id="Vivado-设计输入"><a href="#Vivado-设计输入" class="headerlink" title="Vivado 设计输入"></a>Vivado 设计输入</h2><h3 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h3><div align="center"><img src="/2024/05/29/vivado-use/8.png" width="100%/"></div><ol><li><strong>Design Sources（设计源文件）</strong>：<br>这个文件夹包含你的设计文件，包括VHDL、Verilog或SystemVerilog的源代码。<br>这些文件定义了你的硬件设计的逻辑部分，是你设计的主要部分。</li><li><strong>Constraints（约束文件）</strong>：<br>这个文件夹包含约束文件，通常是XDC（Xilinx Design Constraints）文件。<br>约束文件用于定义设计的物理和时序约束，如引脚分配、时钟约束、时序要求等。</li><li><strong>Simulation Sources（仿真源文件）</strong>：<br>这个文件夹包含用于仿真的文件，如测试平台（testbenches）和其他仿真模型。<br>这些文件用于验证你的设计在仿真环境中的行为，确保设计逻辑按照预期工作。</li><li><strong>Utility Sources（实用工具源文件）</strong>：<br>这个文件夹通常包含一些辅助文件或脚本，可能包括TCL脚本或其他辅助设计和实现过程的文件。<br>这些文件有助于自动化某些任务或提供额外的功能和工具支持。</li></ol><h3 id="输入文件步骤"><a href="#输入文件步骤" class="headerlink" title="输入文件步骤"></a>输入文件步骤</h3><ol><li><strong>添加源文件：</strong></li></ol><div align="center"><img src="/2024/05/29/vivado-use/9.png" width="100%/"></div><ol start="2"><li><strong>创建新的文件：</strong></li></ol><div align="center"><img src="/2024/05/29/vivado-use/10.png" width="100%/"></div><ol start="3"><li><strong>输入</strong><code>led_twinkle</code><strong>为创建文件的名称：</strong></li></ol><div align="center"><img src="/2024/05/29/vivado-use/11.png" width="100%/"></div><ol start="4"><li><strong>创建完文件，点击finish：</strong></li></ol><div align="center"><img src="/2024/05/29/vivado-use/12.png" width="100%/"></div><ol start="5"><li><strong>输入</strong><code>led_twinkle.v</code><strong>文件内容：</strong><br>在源代码部分输入以下源代码，这是一段led灯交替闪烁的代码：</li></ol><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">led_twinkle</span><span class="token punctuation">(</span>    <span class="token keyword">input</span>   sys_clk<span class="token punctuation">,</span>    <span class="token comment">//系统时钟</span>    <span class="token keyword">input</span>   sys_rst_n<span class="token punctuation">,</span>    <span class="token comment">//N系统复位，低电平有效</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> led    <span class="token comment">//LEDT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">////////////////////reg define</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt<span class="token punctuation">;</span><span class="token comment">/////////////////</span><span class="token comment">//      main code</span><span class="token comment">////////////////</span><span class="token comment">//对计数器的值进行判断，以输出LED的状态</span><span class="token keyword">assign</span> led <span class="token operator">=</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> <span class="token number">26'd2500_0000</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b01</span><span class="token punctuation">:</span><span class="token number">2'b10</span><span class="token punctuation">;</span><span class="token comment">//计数器在0“5000 000之间进行计数</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">26'd0</span><span class="token punctuation">;</span><span class="token comment">//    else if(cnt &lt; (25'd2500_0000 - 25'd1))</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> <span class="token number">26'd5000_0000</span><span class="token punctuation">)</span>          cnt <span class="token operator">&lt;=</span> cnt <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        cnt <span class="token operator">&lt;=</span> <span class="token number">26'd0</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Vivado-分析与综合"><a href="#Vivado-分析与综合" class="headerlink" title="Vivado 分析与综合"></a>Vivado 分析与综合</h2><h3 id="何为代码综合"><a href="#何为代码综合" class="headerlink" title="何为代码综合"></a>何为代码综合</h3><p>在Vivado开发流程中，代码综合（Synthesis）是一个关键步骤。综合的主要目的是将高层次的硬件描述语言（HDL）代码转换为门级网表（gate-level netlist），即由逻辑门和触发器等基本单元构成的电路描述。具体来说，代码综合要完成以下任务：</p><ol><li><p><strong>代码分析和优化：</strong></p><ul><li>Vivado会首先分析你的VHDL、Verilog或SystemVerilog代码，检查语法和语义，确保代码是正确的。</li><li>在分析过程中，Vivado可能会进行一些初步的代码优化，如常量传播（constant propagation）、死代码消除（dead code elimination）等。</li></ul></li><li><p><strong>逻辑综合：</strong></p><ul><li>将HDL代码中的高级逻辑结构（如if-else语句、case语句、循环等）转换为基本的逻辑门和触发器。</li><li>Vivado会根据目标FPGA的架构，选择适当的基本单元来实现你的设计。</li></ul></li><li><p><strong>优化与映射：</strong></p><ul><li>在生成初步的门级网表后，Vivado会对该网表进行优化，以提高性能或减少资源使用。</li><li>优化包括时序优化（提高时钟频率）、面积优化（减少逻辑单元的使用）等。<br>最后，优化后的门级网表会被映射到目标FPGA的具体资源上，如查找表（LUT）、触发器、块RAM等。</li></ul></li><li><p><strong>生成综合报告：</strong></p><ul><li>综合过程结束后，Vivado会生成一份综合报告，包含关于逻辑单元使用、时序约束满足情况、功耗估计等信息。</li><li>这份报告可以帮助设计者评估综合结果，了解设计在目标FPGA上的资源使用情况和性能指标。</li></ul></li></ol><h3 id="综合步骤"><a href="#综合步骤" class="headerlink" title="综合步骤"></a>综合步骤</h3><ol><li><p><strong>点击</strong><code>Run Synthesis</code>：</p><div align="center"><img src="/2024/05/29/vivado-use/13.png" width="100%/"></div></li><li><p><strong>开始综合</strong></p><div align="center"><img src="/2024/05/29/vivado-use/15.png" width="100%/"></div></li><li><p><strong>综合进行中：</strong></p><div align="center"><img src="/2024/05/29/vivado-use/14.png" width="100%/"></div></li><li><p><strong>综合完成：</strong></p><div align="center"><img src="/2024/05/29/vivado-use/16.png" width="100%/"></div></li></ol><h2 id="Vivado-约束输入"><a href="#Vivado-约束输入" class="headerlink" title="Vivado 约束输入"></a>Vivado 约束输入</h2><h3 id="何为约束"><a href="#何为约束" class="headerlink" title="何为约束"></a>何为约束</h3><p>在Vivado开发流程中，约束输入（constraints input）是指对设计施加的各种限制条件和要求，以确保设计在硬件上能够正确运行并满足特定性能指标。约束输入通常包括以下几种类型：</p><ol><li><strong>时序约束（Timing Constraints）</strong>：<ul><li>定义设计中各种时序要求，如时钟周期、建立时间（setup time）、保持时间（hold time）等。</li><li>常用的时序约束文件格式是XDC（Xilinx Design Constraints），其中包括定义时钟信号（create_clock）、设置输入和输出延迟（set_input_delay、set_output_delay）、多周期路径（multicycle paths）等。</li><li>这些约束用于指导综合和布局布线工具进行优化，以确保设计能够在指定的时钟频率下可靠运行。</li></ul></li><li><strong>物理约束（Physical Constraints）</strong>：<ul><li>指定设计中各种信号的物理位置要求，如引脚分配（pin assignment）、区域约束（area constraints）等。</li><li>物理约束可以确保设计中的关键信号和模块放置在适当的位置，以满足性能和信号完整性的要求。</li><li>例如，通过约束将某些信号分配到特定的FPGA引脚，可以满足板级布局和连接的需求。</li></ul></li><li><strong>I&#x2F;O 标准约束（I&#x2F;O Standard Constraints）</strong>：<ul><li>定义输入输出信号的电气特性，如电压标准（LVTTL、LVCMOS等）、驱动强度（drive strength）、上拉&#x2F;下拉配置等。</li><li>这些约束确保FPGA的I&#x2F;O端口与其他外部设备正确兼容，并满足电气规格。</li></ul></li><li><strong>功耗约束（Power Constraints）</strong>：<ul><li>用于优化设计的功耗，通过指定功耗目标和策略，指导综合和布局布线工具在满足性能要求的同时尽量降低功耗。</li><li>功耗约束可以帮助设计者在能耗敏感的应用中优化设计，例如便携设备或电池供电系统。</li></ul></li><li><strong>其他约束（Miscellaneous Constraints）</strong>：<ul><li>可能还包括一些特定应用的特殊约束，如时钟域交叉（clock domain crossing）、异步信号处理等。</li><li>这些约束有助于处理设计中的复杂情况和特殊需求。</li></ul></li></ol><h3 id="约束文件步骤-以创建物理约束，即管脚约束为例"><a href="#约束文件步骤-以创建物理约束，即管脚约束为例" class="headerlink" title="约束文件步骤(以创建物理约束，即管脚约束为例)"></a>约束文件步骤(以创建物理约束，即管脚约束为例)</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><ol><li><p><strong>点击</strong><code>Schematic</code></p><div align="center"><img src="/2024/05/29/vivado-use/17.png" width="100%/"></div></li><li><p><strong>等待后，选择右上角的</strong><code>I/O Planning</code></p><div align="center"><img src="/2024/05/29/vivado-use/18.png" width="100%/"></div></li><li><p><strong>设计管脚约束</strong><br>可搜索开发板的引脚图</p><div align="center"><img src="/2024/05/29/vivado-use/19.png" width="100%/"></div></li><li><p><strong>保存后输入文件名，可在Constraints（约束文件）文件夹中，找到相关的XDC文件</strong></p><div align="center"><img src="/2024/05/29/vivado-use/20.png" width="100%/"></div></li></ol><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><ol><li><p><strong>添加约束文件：</strong></p><div align="center"><img src="/2024/05/29/vivado-use/21.png" width="100%/"></div></li><li><p><strong>之后的步骤与添加源文件相类似</strong></p></li></ol><h2 id="Vivado-生成和下载比特流"><a href="#Vivado-生成和下载比特流" class="headerlink" title="Vivado 生成和下载比特流"></a>Vivado 生成和下载比特流</h2><ol><li><strong>点击</strong><code>Generate Bitstream</code></li></ol><div align="center"><img src="/2024/05/29/vivado-use/32.png" width="80%/"></div><ol start="2"><li><strong>点击</strong><code>OK</code></li></ol><div align="center"><img src="/2024/05/29/vivado-use/31.png" width="100%/"></div><ol start="3"><li><strong>等待生成，点击</strong><code>Project Summary</code><strong>，查看生成情况</strong></li></ol><div align="center"><img src="/2024/05/29/vivado-use/33.png" width="100%/"></div><ol start="4"><li><strong>生成成功</strong></li></ol><div align="center"><img src="/2024/05/29/vivado-use/34.png" width="100%/"></div><ul><li><p>该窗口介绍：</p><ol><li><p><strong>Open Implemented Design</strong><br>  选择这个选项会打开实现后的设计布局，包括布线和放置信息。你可以查看设计在FPGA中的具体实现情况。这对于检查布线和放置是否符合预期，以及调试设计问题非常有用。</p></li><li><p><strong>View Reports</strong><br>  选择这个选项可以查看各种报告，如利用率报告、时序报告、功耗报告等。这些报告提供了关于设计实现的详细信息，可以帮助你检查设计是否满足所有约束和性能要求。</p></li><li><p><strong>Open Hardware Manager</strong><br>  选择这个选项会打开硬件管理器。硬件管理器允许你将生成的比特流文件下载到FPGA设备中，并进行在线调试和验证。这一步通常在你准备好对实际硬件进行编程和调试时使用。</p></li></ol></li><li><p>本次实验点击<code>Cancel</code>即可</p></li></ul><h2 id="连接开发板验证"><a href="#连接开发板验证" class="headerlink" title="连接开发板验证"></a>连接开发板验证</h2><ol><li><p><strong>点击</strong><code>Open Hardware Manager</code></p><div align="center"><img src="/2024/05/29/vivado-use/22.png" width="100%/"></div></li><li><p><strong>点击自动连接</strong> <code>Auto Connect</code></p><div align="center"><img src="/2024/05/29/vivado-use/27.png" width="100%/"></div></li><li><p><strong>等待连接成功</strong></p><div align="center"><img src="/2024/05/29/vivado-use/28.png" width="100%/"></div></li><li><p><strong>连接成功后，点击</strong><code>Program Device</code></p><div align="center"><img src="/2024/05/29/vivado-use/29.png" width="100%/"></div></li><li><p><strong>点击</strong><code>Program</code></p><div align="center"><img src="/2024/05/29/vivado-use/30.png" width="100%/"></div></li><li><p><strong>等待下载完成，可在板子上看到LED闪烁</strong></p><div align="center"><img src="/2024/05/29/vivado-use/31.jpg" width="100%/"></div></li></ol>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> vivado </tag>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像异常检测研究现状概括</title>
      <link href="/2024/04/18/review-of-image-anomaly-detection/"/>
      <url>/2024/04/18/review-of-image-anomaly-detection/</url>
      
        <content type="html"><![CDATA[<h1 id="图像异常检测研究现状概括"><a href="#图像异常检测研究现状概括" class="headerlink" title="图像异常检测研究现状概括"></a>图像异常检测研究现状概括</h1><p><strong>PS</strong>：吕承侃, 沈飞, 张正涛, 张峰. 图像异常检测研究现状综述. 自动化学报, 2021, 47(x): 1−27。本文为该篇综述的概括总结，更倾向于对技术和行业前景的介绍，具体技术原理请看原文。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="图像异常检测的意义"><a href="#图像异常检测的意义" class="headerlink" title="图像异常检测的意义"></a>图像异常检测的意义</h3><p>在数字化时代中，图像异常检测成为了计算机视觉领域中的一项至关重要的技术。它的目标是识别那些与正常模式显著不匹配的图像数据，诸如图像中不规则的物体或者行为。这不仅仅对于自动化监控、工业质量控制至关重要，也在医疗影像分析中扮演着不可或缺的角色，如发现潜在的病理改变。随着技术的发展，图像异常检测在自动驾驶车辆的安全系统、内容监测以及农业生产等其他许多领域都已经成为一个不能忽视的研究重点。</p><h3 id="在计算机视觉领域的应用与重要性"><a href="#在计算机视觉领域的应用与重要性" class="headerlink" title="在计算机视觉领域的应用与重要性"></a>在计算机视觉领域的应用与重要性</h3><p>本文通过原文试图深入解析图像异常检测技术的核心，总结与比较各种传统和现代方法的发展阶段、实际应用场景及其相应的优劣。此外，将探讨面向未来的研究方向，旨在增强图像异常检测技术在各种复杂环境下的适用性和精确性。为此，将首先界定图像异常检测的标准定义，从而确定研究的出发点。进一步，本研究将揭示图像异常检测在现代计算机视觉中扮演的角色，并述说其背后的理论与实践意义，展现其跨学科的应用价值和挑战。最后，界定了综述的范围，从技术演变的历史视角出发，评估每种方法在现实世界的具体应用场景以及未来发展的可能性。</p><h3 id="综述研究目的与范围"><a href="#综述研究目的与范围" class="headerlink" title="综述研究目的与范围"></a>综述研究目的与范围</h3><p>这项综述的目标是为学者们提供一个清晰的，经过筛选的知识库，让他们在未来的研究工作中能够立足于坚实的基础之上，面对图像异常检测领域中日益增长的异质性及其带来的挑战。通过多维度剖析各技术的应用背景和潜在影响，原作者期望为这一领域的进一步研究与创新铺平道路，并为将来可能出现的新问题和挑战提供应对策略。</p><h2 id="图像异常检测的研究现状"><a href="#图像异常检测的研究现状" class="headerlink" title="图像异常检测的研究现状"></a>图像异常检测的研究现状</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><h4 id="模板匹配方法："><a href="#模板匹配方法：" class="headerlink" title="模板匹配方法："></a>模板匹配方法：</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li>基于模板匹配的异常检测方法是一种传统的图像异常检测技术，其原理在于使用预定义或预先选定的模板与待检测的图像进行比较。通过计算待检测图像与模板之间的相似度，当相似度低于某个阈值时，即认为发生了异常。</li></ul><h5 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h5><ul><li>这种方法在某些特定领域，如工业产品质量控制、面部识别以及交通监控等领域，因其简单直接而被广泛应用。例如，制造业中用于检测产品是否存在缺陷或者是否符合标准形状。</li></ul><h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><ul><li>基于模板匹配的方法也存在一定的局限性。首先，它强烈依赖于模板的准确性和代表性，如果模板不能充分代表所有正常的变体，那么该方法的检测能力就会大打折扣。其次，在处理具有高度变异性的图像时，如天气变化导致的光照条件改变，或是角度、尺度的变化，这种方法的适应能力较弱，容易产生误判。此外，对于一些复杂或未知的异常模式，基于模板匹配的方法也难以有效检测，限制了其在更广泛场景下的应用。</li><li>原综述中有提到对于其局限性的解决方法。</li></ul><h4 id="统计模型："><a href="#统计模型：" class="headerlink" title="统计模型："></a>统计模型：</h4><h5 id="不同类型的统计模型"><a href="#不同类型的统计模型" class="headerlink" title="不同类型的统计模型"></a>不同类型的统计模型</h5><ul><li>传统的图像异常检测方法中，基于统计模型的异常检测技术是通过构建数据的统计分布模型来识别异常。这类方法涉及多种统计模型，主要包括高斯模型、核密度估计、以及马尔科夫随机场等。这些统计模型通过拟合图像数据的正常分布特征，异常则被视为偏离这种分布的实例。</li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>不同类型的统计模型适用于不同的场景。例如，高斯模型适用于符合正态分布的数据，而核密度估计则更适合处理有复杂分布的数据集。马尔科夫随机场主要用于考虑像素之间依赖关系的图像数据。</li></ul><h5 id="效果比较"><a href="#效果比较" class="headerlink" title="效果比较"></a>效果比较</h5><ul><li>在效果比较方面，尽管这些方法在一些特定场合下取得了良好的效果，如医疗影像分析和工业检测中的异常识别，但它们通常假设数据符合某种特定的统计分布，这在现实世界中并不总是成立。此外，统计模型方法通常需要一个较大的正常数据集来训练模型，在数据集有限或噪声干扰严重的条件下可能不够鲁棒。因此，在实际应用中，研究人员往往需要根据具体场景的特点选择或设计合适的统计模型。</li></ul><h4 id="图像分解技术："><a href="#图像分解技术：" class="headerlink" title="图像分解技术："></a>图像分解技术：</h4><h5 id="图像分解的方法"><a href="#图像分解的方法" class="headerlink" title="图像分解的方法"></a>图像分解的方法</h5><ul><li>传统图像异常检测方法中，基于图像分解的方法主要通过分解图像来识别异常部分。图像分解的技术主要包括奇异值分解（SVD）、主成分分析（PCA）以及非负矩阵分解（NMF）等。这些方法通过将图像分解为多个具有代表性的小部分或特征，通过分析这些分解后的组件来检测异常。</li><li>奇异值分解（SVD）是一种强大的图像分解技术，它可以将图像分解为一系列的奇异值和奇异向量，这些奇异值反映了图像的主要特征。主成分分析（PCA）则通过减少数据的维度，将数据转换到由最主要的成分组成的新的坐标系统中，从而突出异常部分。非负矩阵分解（NMF）通过限制分解后的矩阵元素为非负值，寻找数据的这种稀疏表示，以便更容易识别出异常。</li></ul><h5 id="优点与实际应用"><a href="#优点与实际应用" class="headerlink" title="优点与实际应用"></a>优点与实际应用</h5><ul><li><p>基于图像分解的异常检测方法的主要优点在于其能够有效地处理高维数据，并且通过提取图像的主要特征，可以有效地识别出异常模式，尤其是在数据维度较高时。此外，这种方法也有助于降低噪声的影响，提高异常检测的准确性。</p></li><li><p>在实际应用中，基于图像分解的异常检测方法已经被广泛应用于多个领域，例如工业制品的缺陷检测、医疗成像分析（如X光片和MRI的异常识别）以及高光谱图像处理等。在工业缺陷检测中，可以通过分析各个分解后的特征找出产品表面或内部的裂纹、划痕等缺陷。在医疗影像分析中，可以识别出图像中的肿瘤、异常组织等。通过这些技术，我们能够更加准确和高效地进行异常检测，为各个行业的质量控制和疾病诊断提供了有力的工具。</p></li></ul><h4 id="频域分析："><a href="#频域分析：" class="headerlink" title="频域分析："></a>频域分析：</h4><h5 id="频域特征的利用"><a href="#频域特征的利用" class="headerlink" title="频域特征的利用"></a>频域特征的利用</h5><ul><li>基于频域分析的异常检测方法是传统图像异常检测技术中的一种，它通过将图像从时域转换到频域，利用图像的频域特征来进行异常检测。这种方法的核心在于应用傅里叶变换或者小波变换等数学工具，将图像分解成不同频率的成分，从而分析图像的频率特征。在频域中，图像的边缘、纹理等特征会以特定频率的形式表现出来，异常区域往往会引起频域特征的显著变化，因此通过频域分析可以有效地检测出异常。</li></ul><h5 id="时域分析的比较"><a href="#时域分析的比较" class="headerlink" title="时域分析的比较"></a>时域分析的比较</h5><ul><li>与时域分析相比，基于频域分析的方法的一个重要优势是它可以更直观地反映图像的局部特征和全局特征。在时域中，图像数据通常是按照像素排列的，对于图像的整体特征或局部区域的细节特征不容易直接观察。而在频域中，图像的全局特征和局部特征会根据频率的不同被分离开来，使得它们更容易被区分和分析。此外，频域分析通常对噪声更加鲁棒，能够有效地抑制或分离噪声，提高异常检测的准确度。</li></ul><h5 id="面临的挑战和适用场景"><a href="#面临的挑战和适用场景" class="headerlink" title="面临的挑战和适用场景"></a>面临的挑战和适用场景</h5><ul><li>基于频域分析的异常检测方法也面临着一些挑战，例如在进行傅里叶变换时，对于非周期性或频率变化复杂的图像，可能难以准确捕捉到所有重要的频域特征。此外，在实际应用中，选择合适的频域特征和转换方法对于检测结果有着重要影响，这需要针对具体的应用场景进行仔细设计和选择。</li><li>总体来说，基于频域分析的异常检测方法在图像处理领域内提供了一种有效的工具，尤其是对于包含丰富纹理或边缘信息的图像数据，这种方法能够提供较好的异常检测效果。然而这也需要结合实际应用场景，灵活选择和调整分析方法。</li></ul><h4 id="稀疏编码："><a href="#稀疏编码：" class="headerlink" title="稀疏编码："></a>稀疏编码：</h4><h5 id="稀疏表示的概念"><a href="#稀疏表示的概念" class="headerlink" title="稀疏表示的概念"></a>稀疏表示的概念</h5><ul><li>基于稀疏编码的异常检测方法是利用稀疏表示理论来识别图像中的异常。稀疏表示是指在适当的字典基下，一个信号或图像可以由少量的非零系数表示。具体到图像处理，稀疏编码方法试图找到一个最合适的字典，使得大部分图像能够用尽可能少的基元素组合来重构，同时对于异常部分则难以用这套基元素来充分表示。</li><li>在异常检测中实施稀疏编码，首先需要通过训练样本学习出一个字典，这个字典包含了正常图像数据的关键特征。测试图像通过这个字典进行稀疏表示，如果无法用较少的非零系数进行有效重构，那么该图像很可能含有异常。实际操作中，通过设置一个重构误差阈值，超过该阈值的图像区域被认定为异常。</li></ul><h5 id="在异常检测中的实现与挑战"><a href="#在异常检测中的实现与挑战" class="headerlink" title="在异常检测中的实现与挑战"></a>在异常检测中的实现与挑战</h5><ul><li>基于稀疏编码的方法的挑战在于，首先，字典的学习过程既复杂又费时，对于大规模数据集尤其如此。其次，字典选择对检测结果有很高的敏感度，不恰当的字典可能会导致高误报或漏报。此外，这种方法对训练集的依赖性较强，如果训练集没有很好地覆盖所有正常模式，那么新的正常模式有可能被误判为异常。而且，在面对动态变化的图像数据时，维护和更新字典也是一大挑战。</li><li>尽管存在这些挑战，基于稀疏编码的方法在许多应用中显示出强大的异常检测能力，尤其是在图像重构质量要求较高的领域，如医疗图像分析等。该方法依赖于先进的数学理论，为异常检测提供了一种新的视角和工具。</li></ul><h4 id="分类面构建：分类面理论、不同方法的对比与应用"><a href="#分类面构建：分类面理论、不同方法的对比与应用" class="headerlink" title="分类面构建：分类面理论、不同方法的对比与应用"></a>分类面构建：分类面理论、不同方法的对比与应用</h4><h5 id="分类面理论"><a href="#分类面理论" class="headerlink" title="分类面理论"></a>分类面理论</h5><ul><li>基于分类面构建的异常检测方法，在传统图像异常检测技术中占有重要地位。该方法的核心在于定义一个分类面（或称决策边界）来区分正常图像与异常图像。分类面的构建通常依赖于监督学习算法，如支持向量机（SVM）、决策树、随机森林等，这些算法通过学习正常与异常图像的特征，构建一个能够最大化地区分两者的分类面。</li><li>分类面理论基于找到一个最优的决策边界，这个边界能够使得正常样本和异常样本在某种度量下尽可能分开。在支持向量机（SVM）中，这通过构建一个超平面实现，该超平面能够最大化正常样本和异常样本之间的间隔。在决策树和随机森林中，通过构建多个决策边界，来划分不同的特征空间，从而实现对正常与异常样本的分类。</li></ul><h5 id="不同方法的对比与应用"><a href="#不同方法的对比与应用" class="headerlink" title="不同方法的对比与应用"></a>不同方法的对比与应用</h5><ul><li>与其他方法对比，基于分类面构建的异常检测方法具有明显的优势。首先，它能够提供明确的决策依据，即通过分类面可以直观地看到哪些特征对区分正常和异常样本更为重要。其次，该方法在处理高维数据时表现出较好的性能，尤其是当正常与异常样本之间的差异较小，或者异常样本较少时。此外，通过选择合适的机器学习算法，可以提升分类准确度，使得该方法在多种应用场景中都有着较好的表现。</li><li>在实际应用中，基于分类面构建的异常检测方法被广泛应用于工业缺陷检测、医疗影像分析、网络安全等多个领域。在工业缺陷检测中，能够精准识别出产品中的微小裂纹或瑕疵；在医疗影像分析中，帮助诊断疾病，如识别肿瘤等异常组织；在网络安全领域，用于识别异常访问模式，提高系统的安全性。</li><li>然而，该方法也面临着挑战，尤其是在异常样本稀缺或异常模式多样化时，分类面的构建会变得复杂，可能导致过拟合或泛化能力下降。因此，在实际应用中，选择合适的机器学习算法和调整分类模型参数，以及采用适当的特征选择和数据预处理策略，都是提高检测准确度和减少误报的关键。</li></ul><h4 id="传统方法间的对比分析：综合比较传统方法的优缺点与适用范围"><a href="#传统方法间的对比分析：综合比较传统方法的优缺点与适用范围" class="headerlink" title="传统方法间的对比分析：综合比较传统方法的优缺点与适用范围"></a>传统方法间的对比分析：综合比较传统方法的优缺点与适用范围</h4><ul><li><p>基于<strong>模板匹配</strong>的方法适合工业生产这类环境可控且目标高度一致的场景，实现了较高的检测精度，但不适用于采集环境多变或者正常图像间存在较大差异的场景。</p></li><li><p>基于<strong>统计模型</strong>的方法速度很快，但需要一定的训练样本来评估背景模型的参数。</p></li><li><p>基于<strong>图像分解</strong>的方法适合训练样本稀缺的场合，可以直接在待测样本上检测异常区域，但速度较慢。</p></li><li><p>基于<strong>频域分析</strong>的方法兼顾了检测速度和对训练样本的低依赖性，但通用性较差。</p></li><li><p>基于<strong>稀疏编码</strong>和<strong>分类面构建</strong>的方法适用于各种类型的图像，具有更高的通用性，但也存在一些问题，如稀疏编码方法在重构阶段耗时，</p></li><li><p><strong>分类面构建</strong>方法面临参数选择困难和定位精度问题。</p></li><li><p>引用原文的表格</p><div align="center"><img src="/2024/04/18/review-of-image-anomaly-detection/1.png" width="100%/"></div></li></ul><h3 id="基于深度学习的方法"><a href="#基于深度学习的方法" class="headerlink" title="基于深度学习的方法"></a>基于深度学习的方法</h3><h4 id="基于距离度量：度量学习在异常检测中的应用与案例"><a href="#基于距离度量：度量学习在异常检测中的应用与案例" class="headerlink" title="基于距离度量：度量学习在异常检测中的应用与案例"></a>基于距离度量：度量学习在异常检测中的应用与案例</h4><ul><li>基于距离度量的异常检测方法是深度学习在图像异常检测领域中的重要应用之一。这种方法的核心在于使用度量学习（metric learning）来寻找表示数据的最佳距离度量，使得相似的数据点（在这里是指正常的图像样本）之间的距离小，而不同的数据点（即异常图像样本）之间的距离大。</li><li>在深度学习的背景下，度量学习通常利用神经网络来学习数据的嵌入表示，使得在新的特征空间中，可以用简单的距离度量（如欧氏距离）来判别样本是否异常。其中一个典型的方法是孪生网络（Siamese Network），它通过比较一对输入样本，输出它们的相似度评分，并在训练过程中使得正常样本对的评分高于异常样本对的评分。</li><li>度量学习的关键在于定义一个损失函数，如三元组损失（Triplet Loss），该损失函数会同时考虑正样本对和负样本对，训练时旨在最小化正样本对之间的距离，同时最大化与每个负样本对之间的距离。通过这种方式，网络学习将异常映射到点的表示空间的很远的地方。<br>举个应用案例，如在工业制造中的缺陷检测，可以采用基于距离度量的方法来区分正常工件和包含缺陷的工件图像。另外，在医学影像分析中，比如用于乳腺癌筛查，通过度量学习可以提取乳腺组织的特征，并将含有潜在病变的图像与正常图像区分开。</li><li>进一步地，一些研究还结合传统方法与度量学习，例如利用传统的图像处理方法预处理数据，然后使用深度度量学习对特征空间进行优化。这种结合方法可以更好地利用两种方法的优势，提高异常检测的整体性能。</li><li>然而，基于距离度量的方法也面临挑战，例如在需要海量标记数据进行训练的情境中，标注工作量过大或标记数据不足都可能成为瓶颈。此外，度量学习的模型很可能复杂且计算资源密集，尤其在需要实时检测的场景中，可能难以满足实时性的要求。因此，未来的研究需要在增强模型泛化能力、减少计算成本以及优化数据利用率等方面做进一步的工作。</li></ul><h4 id="基于分类面构建："><a href="#基于分类面构建：" class="headerlink" title="基于分类面构建："></a>基于分类面构建：</h4><h5 id="深度网络如何构建高效的分类面"><a href="#深度网络如何构建高效的分类面" class="headerlink" title="深度网络如何构建高效的分类面"></a>深度网络如何构建高效的分类面</h5><ul><li>深度网络通过层叠的神经元网络结构自动地从数据中学习到了高层次的特征表示。通过端到端的训练，它能够学习到如何将复杂的、高维的输入数据（如图像）映射到一个新的空间，在这个空间中，类别间的区分度更高，进而可以用一个简单的层（如softmax或者sigmoid层）来划分分类面。深度卷积神经网络（CNNs）尤其擅长于提取图像数据的层次特征，使得分类问题变得更加简化。通过训练，CNN可以将正常图像和异常图像映射到高维特征空间的不同区域，从而有效地确定分类面。</li></ul><h5 id="对比传统方法的优势"><a href="#对比传统方法的优势" class="headerlink" title="对比传统方法的优势"></a>对比传统方法的优势</h5><ul><li>与传统方法相比，基于深度学习的分类面构建方法有几个显著优势。首先，深度学习模型不依赖于人工设计的特征，它能够自动从大量数据中学习到抽象和区分性的特征。其次，深度学习模型具有很高的自适应性，可以透过数据驱动的方式自动调整模型结构，以适应不同任务的需求。再次，深度学习模型在处理复杂和高维数据时表现出色，能够捕获数据中的非线性关系，这对于图像这种高复杂度的数据尤其重要。最后，随着深度学习技术的发展和计算力的提升，基于深度学习的方法在速度和准确性上持续取得突破，尤其是在具有丰富层次结构的数据分析任务中。</li></ul><h5 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h5><ul><li>深度学习方法也有其挑战。例如，这类方法对大量标记数据的需求，以及计算上的高成本。不过，研究者们已经在通过生成对抗网络（GAN）生成辅助数据、迁移学习利用预训练模型以及半监督学习等方式来解决这些问题。</li><li>总结来说，基于深度学习的图像异常检测方法中的分类面构建技术通过深度网络有效地提取复杂图像数据的深层特征，并在高维空间中构建分类面，相较于传统方法具有更好的泛化能力和更高的检测性能。这使得这些方法不仅可以适用于传统领域，如工业产品缺陷检测、医疗影像分析，也为新领域的异常检测问题，如大规模视频监控异常检测，提供了新的解决方案。随着技术的不断进步，可以预见这类方法将在图像异常检测领域发挥更大的作用。</li></ul><h4 id="基于图像重构："><a href="#基于图像重构：" class="headerlink" title="基于图像重构："></a>基于图像重构：</h4><h5 id="自编码器等深度网络如何进行图像重构"><a href="#自编码器等深度网络如何进行图像重构" class="headerlink" title="自编码器等深度网络如何进行图像重构"></a>自编码器等深度网络如何进行图像重构</h5><ul><li>在基于深度学习的图像异常检测方法中，基于图像重构的方法是一种重要的手段。这类方法借助深度网络，尤其是自编码器，来进行图像的重构学习，以此作为异常检测的依据。在接下来的内容中，我将详细探讨自编码器进行图像重构的过程及其在异常检测中的应用。</li><li>自编码器是一种神经网络，它被设计来学习数据的有效编码。结构上，自编码器包含输入层、一个或多个隐藏层，以及一个输出层。它通过压缩数据流到一个低维隐空间（编码阶段），再从这个空间重构数据（解码阶段）。在训练过程中，自编码器的目的是最小化输入图像和输出图像（重构图像）之间的差异，这通常通过损失函数如均方误差来衡量。</li><li>在自编码器的基础上，还发展了许多变种，如变分自编码器（VAE）、稀疏自编码器和去噪自编码器（DAE）。变分自编码器通过引入概率分布的角度来进行图像重构，提高了模型生成样本的多样性和鲁棒性。稀疏自编码器通过引入稀疏性约束，迫使模型捕捉到数据中更加重要的特征。而去噪自编码器通过在训练时加入噪声干扰，使模型更加专注于数据的本质特征，从而在测试阶段对异常检测更为敏感。</li></ul><h5 id="在异常检测中的应用"><a href="#在异常检测中的应用" class="headerlink" title="在异常检测中的应用"></a>在异常检测中的应用</h5><ul><li>具体到图像重构在异常检测中的应用，其基本理论是，自编码器在训练时只暴露于正常图像数据。因此，网络学会了只重构“正常”的图像特征，当遇到异常图像时，由于其特征与训练数据不同，自编码器将无法准确地进行重构，从而导致重构误差明显增大。通过设置阈值，可以利用这个重构误差来判定图像是否含有异常。</li><li>例如，在工业制造中进行产品缺陷检测，可以利用自编码器学习产品的正常外观。测试阶段，当产品图像与训练集上的正常图像存在差异时（如有裂纹、变色等），自编码器重构的图像会与输入图像存在较大差异，此时可以根据重构误差判断产品是否合格。同理，在医学图像分析领域，自编码器可以用于学习正常的医疗图像（如健康组织的MRI扫描），而在遇到异常组织（如肿瘤）时，重构误差会增大，利用此特点可帮助医生进行诊断。</li><li>总之，基于图像重构的深度学习异常检测方法通过自编码器等深度网络从输入图像中学习其正常特征的表示，然后使用重构误差来区分异常。这种方法在工业缺陷检测、医学图像分析等多个领域有着广泛的应用，它不仅能够有效从复杂数据中提取特征，而且在处理未见过的异常类型时表现出显著的优势。随着计算能力的提升和模型结构的不断创新，基于图像重构的异常检测方法在未来有望进一步提高其准确性和应用范围。</li></ul><h4 id="深度学习方法与传统方法的结合："><a href="#深度学习方法与传统方法的结合：" class="headerlink" title="深度学习方法与传统方法的结合："></a>深度学习方法与传统方法的结合：</h4><h5 id="探讨两者结合的可能性与实际案例"><a href="#探讨两者结合的可能性与实际案例" class="headerlink" title="探讨两者结合的可能性与实际案例"></a>探讨两者结合的可能性与实际案例</h5><p>基于深度学习的图像异常检测方法与传统方法的结合在近年来成为了一个研究热点，这种融合方法结合了两种技术的优势，旨在提升异常检测的精度与效率。传统方法，如模板匹配、统计模型、图像分解等，依赖于特定假设或手工设计的特征提取器，这在处理复杂数据时可能限制了它们的性能。而深度学习方法能够从大量数据中自动学习复杂的特征，但可能需要大量的标记数据，且模型可解释性较差。</p><ul><li>结合深度学习和传统方法的策略可能包括先使用传统方法进行预处理或特征提取，然后应用深度学习模型进行进一步的分析和决策，或者在深度学习框架中嵌入传统算法的理念，以增加模型的可解释性和减少对标记数据的依赖。</li><li>实践案例之一是在工业缺陷检测领域的应用。例如，可以首先使用图像分解方法从复杂背景中提取潜在的缺陷特征，然后用深度学习模型，如卷积神经网络（CNN）对这些特征进行分类，以高精度区分正常和有缺陷的产品。这种方法结合了图像分解的有效性和深度学习的高性能，实现了更为准确的缺陷检测。</li><li>另一个案例是在医疗图像分析中的应用，比如乳腺癌筛查。传统的统计模型可用于初步筛选可能的异常区域，然后运用深度学习方法，特别是基于图像重构的自编码器进行进一步分析。这种方式可以更精确地识别出异常组织，从而帮助早期诊断。</li><li>这种深度学习与传统方法的结合不仅提高了异常检测的准确性，也减轻了深度学习模型对大量标记数据的依赖，同时加强了模型的适应性和泛化能力。未来，随着更多创新方法的出现，这种结合方式有望在更广泛的场景中得到应用，并推动图像异常检测领域的进一步发展。</li></ul><h4 id="综合深度学习方法的比较：从检测精度、通用性、速度等方面比较不同深度学习方法"><a href="#综合深度学习方法的比较：从检测精度、通用性、速度等方面比较不同深度学习方法" class="headerlink" title="综合深度学习方法的比较：从检测精度、通用性、速度等方面比较不同深度学习方法"></a>综合深度学习方法的比较：从检测精度、通用性、速度等方面比较不同深度学习方法</h4><ul><li>基于<strong>距离度量</strong>的方法具有模型结构简单、适用范围广的优点，但可能出现模型退化并无法准确定位异常区域。</li><li>基于<strong>分类面构建</strong>的方法训练较为简单，具有较高的异常检测精度，但在某些场景下几何变换操作并不适用。</li><li>基于<strong>图像重构</strong>的方法在训练阶段无需额外样本，应用场景广泛且速度较快，但重构结果可能较模糊。</li><li><strong>结合传统方法</strong>的方法相比传统方法具有更高的精度和通用性，速度也较快，但在检测精度上略有不足。</li><li>综合比较这四种方法的优缺点和适用场景，可以根据具体需求和场景特点选择合适的深度学习方法进行图像异常检测。</li><li>引用原文的表格<div align="center"><img src="/2024/04/18/review-of-image-anomaly-detection/2.png" width="100%/"></div></li></ul><h2 id="图像异常检测数据集"><a href="#图像异常检测数据集" class="headerlink" title="图像异常检测数据集"></a>图像异常检测数据集</h2><p>该综述介绍了在不同领域内用于图像异常检测的各种数据集，这些领域包括工业表面缺陷检测、医疗图像分析以及高光谱图像处理等。其中，一些常用的数据集包括：</p><ul><li>TILDA（纺织纹理数据库）</li><li>PFID（带图案的织物图像数据库）</li><li>MT（磁砖缺陷数据集）</li><li>RSDDs（铁路表面离散缺陷数据集）</li><li>NEU（东北大学表面缺陷数据库）</li><li>NanoTWICE（纳米复合纤维用于空气和水的处理，这是一种工业概念的电纺丝）</li><li>MVTec AD（MVTec异常检测数据集）</li><li>BraTS（脑瘤图像分割基准）</li><li>AMD（与年龄相关的黄斑变性）</li><li>AVIRIS（机载可见红外成像光谱仪）</li><li>ABU（机场-海滩-城市）</li></ul><p>这些数据集提供了丰富的图像样本，用于训练和测试异常检测算法。它们覆盖了从基本的表面缺陷检测到复杂的医疗图像分析等多个领域，为研究人员提供了宝贵的资源，帮助他们在图像异常检测领域内进行算法的开发和性能评估。</p><h2 id="图像异常检测的挑战与未来研究方向"><a href="#图像异常检测的挑战与未来研究方向" class="headerlink" title="图像异常检测的挑战与未来研究方向"></a>图像异常检测的挑战与未来研究方向</h2><h3 id="目前图像异常检测面临的技术挑战"><a href="#目前图像异常检测面临的技术挑战" class="headerlink" title="目前图像异常检测面临的技术挑战"></a>目前图像异常检测面临的技术挑战</h3><p>图像异常检测作为计算机视觉中一项极其复杂的任务，尽管在过去几十年已经取得显著的进展，但仍存在一系列的技术挑战和研究空白。这些挑战主要涵盖了算法的泛化能力、处理大规模数据集的效率、抗干扰能力、以及对少数类样本的敏感度等方面。</p><p>众所周知，算法的泛化能力对于图像异常检测至关重要。然而，现有方法在面对新的或未曾见过的异常类型时，仍然容易出现误报或漏报。这要求研究者不断探索新的模型结构和训练策略，以提高模型的鲁棒性和泛化能力。</p><p>与此同时，图像异常检测通常需要处理规模庞大的数据集。现有的许多算法在面对这种情况时，处理速度会大幅度降低，导致无法满足实时性的需求。此外，数据集的不平衡性也是一个难题，异常样本往往远少于正常样本，这可能导致算法在训练时过于偏向于识别常见模式，忽视异常。</p><p>另一个挑战是抗干扰能力。在真实世界的应用场景中，图像数据常常伴有各种噪声和干扰，如光照变化、遮挡等。这要求算法不仅要具备准确识别异常的能力，还要有效地抵抗这些干扰因素的影响。</p><p>针对少数类样本的敏感度也是一个重要问题。传统方法通常需依赖大量的正常样本进行模型训练，而深度学习方法虽然能在一定程度上缓解这个问题，但依旧需要大量的标注数据来实现精确检测。</p><h3 id="研究趋势和技术进展"><a href="#研究趋势和技术进展" class="headerlink" title="研究趋势和技术进展"></a>研究趋势和技术进展</h3><p>往后看，图像异常检测的研究趋势和技术进展可能会集中在以下几个方面。首先是无监督或半监督学习技术的进一步发展。因为在实际应用中，获得大量标注数据异常昂贵且耗时，利用无监督学习或半监督学习技术，能够更有效地从未标注数据中学习，这可能成为一个重要研究方向。</p><p>另外，生成模型，如变分自编码器（VAEs）和生成对抗网络（GANs），在异常检测领域也展现出了很大的潜力。它们能够生成正常样本的分布，进而帮助识别数据中的异常。这些方法能够从根本上解决数据不平衡问题，是未来值得关注的研究点。</p><p>此外，多任务学习和元学习的方法也逐渐成为热点。这些方法能够使得算法在处理多种类型的异常时具有更好的泛化能力，甚至能够适应在训练过程中未曾遇到的新型异常。</p><h3 id="综合应用深度学习与传统技术的可能性和预期效果"><a href="#综合应用深度学习与传统技术的可能性和预期效果" class="headerlink" title="综合应用深度学习与传统技术的可能性和预期效果"></a>综合应用深度学习与传统技术的可能性和预期效果</h3><p>结合深度学习的强大特征学习能力与传统方法的特性，能够产生更加强大和鲁棒的检测系统。例如，利用深度网络对图像进行特征提取，再结合统计模型或分类器进行最终的异常检测，这种方式可以兼得深度学习和传统方法的优势。</p><p>另一种可能性是，利用深度学习方法进行初步的异常检测，再通过传统方法进行后处理，改善误差率和减少假阳性。这一策略可以使得整体系统变得更加可靠，特别是在对误报要求严格的应用领域中。</p><p>未来的研究还可能集中在深度网络结构的优化上，通过设计更加高效的网络架构，以便快速处理大规模图像数据集。同时，也将涉及到深度强化学习等先进技术，用于进一步提升检测系统的自适应能力和鲁棒性。</p><p>综上所述，虽然图像异常检测仍面临着诸多挑战，但随着新技术的不断涌现和旧技术的不断完善，我们有理由期待这些挑战会被逐步克服，未来的图像异常检测技术将会更加智能、高效和精准。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像异常检测 </tag>
            
            <tag> 综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础笔记</title>
      <link href="/2024/03/13/deep-learning/"/>
      <url>/2024/03/13/deep-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习基础笔记"><a href="#深度学习基础笔记" class="headerlink" title="深度学习基础笔记"></a>深度学习基础笔记</h1><hr><h2 id="深度学习简介"><a href="#深度学习简介" class="headerlink" title="深度学习简介"></a>深度学习简介</h2><ul><li><strong>深度学习</strong>，是一种基于无监督特征学习和特征层次结构学习的模型，在计算机视觉，语音识别，自然语言处理等领域有着突出的优势。</li></ul><h3 id="传统机器学习与深度学习"><a href="#传统机器学习与深度学习" class="headerlink" title="传统机器学习与深度学习"></a>传统机器学习与深度学习</h3><h4 id="传统机器学习与深度学习对比"><a href="#传统机器学习与深度学习对比" class="headerlink" title="传统机器学习与深度学习对比"></a>传统机器学习与深度学习对比</h4><table><thead><tr><th align="left">传统机器学习</th><th align="left">深度学习</th></tr></thead><tbody><tr><td align="left">对计算机<strong>硬件需求较小</strong>：计算量级别有限，一般不需配用GPU显卡做并行运算</td><td align="left">对硬件有一定要求：大量数据需进行大量的矩阵运算，<strong>需配用GPU</strong>做并行运算</td></tr><tr><td align="left">适合<strong>小数据量</strong>训练，再增加数据量难以提升性能</td><td align="left"><strong>高维的权重参数</strong>，海量的训练数据下可以获得高性能</td></tr><tr><td align="left">需要将问题逐层分解</td><td align="left">“端到端”的学习</td></tr><tr><td align="left">人工进行特征选择</td><td align="left">利用算法自动提取特征</td></tr><tr><td align="left">特征可解释性强</td><td align="left">特征可解释性弱</td></tr></tbody></table><h4 id="传统机器学习一般流程"><a href="#传统机器学习一般流程" class="headerlink" title="传统机器学习一般流程"></a>传统机器学习一般流程</h4><div align="center"><img src="/2024/03/13/deep-learning/1.png" width="70%/"></div><ul><li>在深度学习中，特征工程往往由算法自动完成</li></ul><h4 id="深度学习介绍"><a href="#深度学习介绍" class="headerlink" title="深度学习介绍"></a>深度学习介绍</h4><ul><li>深度学习一般指深度神经网络，深度指神经网络的层数（多层）。<div align="center"><img src="/2024/03/13/deep-learning/2.png" width="100%/"></div></li></ul><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h4 id="神经网络介绍"><a href="#神经网络介绍" class="headerlink" title="神经网络介绍"></a>神经网络介绍</h4><ul><li>目前，关于神经网络的定义尚不统一，按美国神经网络学家Hecht Nielsen的观点，神经网络的定义是：“神经网络是由多个非常简单的处理单元彼此按某种方式相互连接而形成的计算机系统，该系统靠其状态对外部输入信息的动态响应来处理信息”。</li><li>综合神经网络的来源、特点和各种解释，它可简单地表述为：<strong>人工神经网络是一种旨在模仿人脑结构及其功能的信息处理系统</strong>。</li><li><strong>人工神经网络（简称神经网络）</strong>：是由人工神经元互连组成的网络，它是从微观结构和功能上对人脑的抽象、简化，是模拟人类智能的一条重要途径，反映了人脑功能的若干基本特征，如并行信息处理、学习、联想、模式分类记忆等。</li></ul><h4 id="神经网络发展历程"><a href="#神经网络发展历程" class="headerlink" title="神经网络发展历程"></a>神经网络发展历程</h4><div align="center"><img src="/2024/03/13/deep-learning/3.png" width="100%/"></div><h3 id="单层感知机"><a href="#单层感知机" class="headerlink" title="单层感知机"></a>单层感知机</h3><h4 id="单层感知机原理"><a href="#单层感知机原理" class="headerlink" title="单层感知机原理"></a>单层感知机原理</h4><ul><li><p>感知机 ( perceptron )是Frank Rosenblatt在1957年所发明的一种最简单的人工神经网络。单层感知机本质上是一个二分类器。</p></li><li><p>输入向量：$X&#x3D;[x_0,x_1,…x_n]^T$</p></li><li><p>权值：$W&#x3D;[w_0,w_1,…,w_n]^T$，其中$w_0$称之为<strong>偏置</strong></p></li><li><p>激活函数：$O&#x3D;sign(net)&#x3D;1,net&gt;0&#x2F;-1,otherwise$</p><div align="center"><img src="/2024/03/13/deep-learning/4.png" width="70%/"></div></li><li><p>上面的感知器，相当于一个分类器，它使用高维$X$向量做输入，在高维空间对输入的样本进行二分类:当$W^TX&gt; 0$时，$O&#x3D;1$，相当于样本被归类为其中一类。否则，$O &#x3D; —1$，相当于样本被归类为另一类。这两类的边界在哪里呢?就是$W^TX&#x3D; 0$，这是一个高维的超平面。</p><div align="center"><img src="/2024/03/13/deep-learning/5.png" width="70%/"></div></li></ul><h4 id="单层感知机所遇障碍-XOR问题"><a href="#单层感知机所遇障碍-XOR问题" class="headerlink" title="单层感知机所遇障碍 - XOR问题"></a>单层感知机所遇障碍 - XOR问题</h4><ul><li>1969年，美国数学家及人工智能先驱Minsky在其著作中证明了感知器本质上是一种线性模型，只能处理线性分类问题，<strong>无法处理非线性数据</strong>。<div align="center"><img src="/2024/03/13/deep-learning/6.png" width="70%/"></div></li></ul><h3 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h3><h4 id="前馈神经网络结构原理"><a href="#前馈神经网络结构原理" class="headerlink" title="前馈神经网络结构原理"></a>前馈神经网络结构原理</h4><div align="center"><img src="/2024/03/13/deep-learning/7.png" width="70%/"></div><ul><li>计算功能的神经元都在隐含层，隐含层中有激活函数，这些激活函数通过计算传递到下一层。同样同一层的神经元之间并不存在相互的联系，层与层之间的信息只沿着一个方向。</li></ul><h4 id="解决异或问题"><a href="#解决异或问题" class="headerlink" title="解决异或问题"></a>解决异或问题</h4><div align="center"><img src="/2024/03/13/deep-learning/8.png" width="90%/"></div><h4 id="隐藏层数对神经网络的影响"><a href="#隐藏层数对神经网络的影响" class="headerlink" title="隐藏层数对神经网络的影响"></a>隐藏层数对神经网络的影响</h4><div align="center"><img src="/2024/03/13/deep-learning/9.png" width="90%/"></div><ul><li>隐含层数越多，神经网络的分辨能力越强</li></ul><hr><h2 id="训练法则"><a href="#训练法则" class="headerlink" title="训练法则"></a>训练法则</h2><h3 id="向前传播"><a href="#向前传播" class="headerlink" title="向前传播"></a>向前传播</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>输入信号从输入层传输到输出层</li><li>对于每个神经元︰<ul><li>计算上层输入的加权平均值: $\theta’&#x3D;WX +b$</li><li>计算激活函数值：$\theta &#x3D; f(\theta’)$</li></ul></li><li>最后输出：模型预测值$f(x,\overline{\theta})$<div align="center"><img src="/2024/03/13/deep-learning/10.png" width="80%/"></div></li></ul><h3 id="梯度下降与损失函数"><a href="#梯度下降与损失函数" class="headerlink" title="梯度下降与损失函数"></a>梯度下降与损失函数</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li>对于多元函数 $o &#x3D; f(x) &#x3D; f(x_0,x_1,…,x_n)$ ，其在 $x’&#x3D; [x_0’ ,x_1 ‘,…,x_n’]^T$ 处的梯度为:$$\nabla f(x_0’ ,x_1 ‘,…,x_n’)&#x3D; [\frac{\partial f}{\partial x_0},\frac{\partial f}{\partial x_1},…,\frac{\partial f}{\partial x_n}]^T|X&#x3D;X’$$<br><strong>梯度向量的方向，指向函数增长最快的方向</strong>。因此，负梯度向量$-\nabla f$ ,则指向函数下降最快的方向。</li><li>在训练深度学习网络的时候，我们要首先要参数化描述目标分类的错误，这就是<strong>损失函数</strong>（误差函数），它反映了感知器目标输出和实际输出之间的误差。最常用的误差函数为<strong>均方误差</strong>：$$E(W)&#x3D;\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$$ 其中，$d$ 为训练样例，$D$ 为训练样例集，$t_d$ 为目标输出，$o_d$ 为实际输出。</li><li>梯度下降法的思想是让损失函数沿着负梯度的方向进行搜索，不断迭代更新参数，最终使得损失函数最小化。</li></ul><h4 id="损失函数极值"><a href="#损失函数极值" class="headerlink" title="损失函数极值"></a>损失函数极值</h4><ul><li><strong>目的</strong>：损失函数$E(W)$是定义在权值空间上的函数。我们的目的是搜索使得$E(W)$<strong>最小</strong>的权值向量$W$。</li><li><strong>限制</strong>：$E(W)&#x3D;\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$ 的复杂高维曲面，<strong>在数学上，尚没有求极值解有效方法。</strong></li><li><strong>解决思路</strong>：负梯度方向是函数下降最快的方向，那我们可以从某个点开始，沿着 $-\nabla E(W)$ 方向一路前行，期望最终可以找到 $E(W)$ 的极小值点，这就是梯度下降法的核心思想。<div align="center"><img src="/2024/03/13/deep-learning/11.png" width="50%/"></div></li></ul><h4 id="深度学习中常用的损失函数"><a href="#深度学习中常用的损失函数" class="headerlink" title="深度学习中常用的损失函数"></a>深度学习中常用的损失函数</h4><ul><li>均方误差：$$E(W)&#x3D;\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$$</li><li>交叉熵误差：$$E(W)&#x3D;\frac{1}{n}\sum_{d\in D}(t_d \ln{o_d}+(1-t_d) \ln({1-o_d}))^2$$</li><li>交叉嫡误差刻画了两个概率分布之间的距离，是分类问题中使用较多的一种损失函数。</li><li>一般均方误差更多得用于<strong>回归问题</strong>，而交叉嫡误差更多的用于<strong>分类问题</strong>。</li></ul><h4 id="批量梯度下降-BGD"><a href="#批量梯度下降-BGD" class="headerlink" title="批量梯度下降(BGD)"></a>批量梯度下降(BGD)</h4><ul><li>对于训练样例集$D$中的每一个样例记为 $&lt;X,t &gt;$ ，$X$ 是输入值向量，$t$  为目标输出，$o$ 为实际输出，$\eta$ 是学习率。<ul><li>初始化每个 $w_i$ ，为绝对值较小的随机值</li><li>遇到终止条件前，<strong>do</strong>：<ul><li>初始化每个 $\triangle w_i$ 为零</li><li>对于 $D$ 中每个 $&lt;X,t &gt;$，<strong>do</strong>：<ul><li>将 $X$ 输入此单元，计算输出$o$</li><li>对于此单元的每个 $w_i$，<strong>do</strong>：$\triangle w_i+&#x3D; \eta(t-o) x_i$</li></ul></li><li>·对于此单元的每个 $w$ ,，<strong>do</strong>：$w_i+&#x3D;\triangle w_i$</li></ul></li></ul></li><li>这个版本的梯度下降算法，实际上并不常用，它的主要问题是：<ul><li>收敛过程非常慢，因为每次更新权值都需要计算所有的训练样例;</li></ul></li></ul><h4 id="随机梯度下降-SGD"><a href="#随机梯度下降-SGD" class="headerlink" title="随机梯度下降(SGD)"></a>随机梯度下降(SGD)</h4><ul><li>针对原始梯度下降算法的弊端，一个常见的变体称为增量梯度下降( Incremental GradientDescent)，亦即<strong>随机梯度下降</strong>（SGD: Stochastic Gradient Descent ）。其中一种实现称为在线学习( online Learning )，它根据每一个样例来更新梯度：$$\triangle w_i&#x3D;\eta \sum_{d\in D}(t_d-o_d)x_{id} \Rightarrow \triangle w_i&#x3D;\eta (t_d-o_d)x_{id}$$</li><li>ONLINE-GRADIENT-DESCENT $(D, \eta)$<ul><li>初始化每个 $w_i$ 为绝对值较小的随机值。</li><li>遇到终止条件前，<strong>do</strong>：</li><li>在 $D$ 中随机出一个 $&lt;X, t&gt;$ ，<strong>do</strong>:<ul><li>将x输入此单元，计算输出 $o$</li><li>对于此单元的每个 $w_i$ ， <strong>do</strong>: $w_i +&#x3D; \eta(t-o)x_i$</li></ul></li></ul></li></ul><h4 id="小批量梯度下降-MBGD"><a href="#小批量梯度下降-MBGD" class="headerlink" title="小批量梯度下降(MBGD)"></a>小批量梯度下降(MBGD)</h4><ul><li>针对上两种梯度下降算法的弊端，提出了一个实际工作中<strong>最常用的梯度下降算法</strong>，即 <strong>Mini-BatchSGD</strong>。它的思想是每次使用一小批固定尺寸（BS: Batch Size）的样例来计算 $\triangle w_i$ ，然后更新权值。</li><li>BATCH-GRADIENT-DESCENT $(D,\eta,BS)$<ul><li>初始化每个 $w_i$ 为绝对值较小的随机值</li><li>遇到终止条件前，<strong>do</strong>:<ul><li>初始化每个 $\triangle w_i$ 为零</li><li>从 $D$ 中下一批(BS个)样例，对这批样例中的每一个 $&lt;X,t &gt;$，<strong>do</strong>:<ul><li>将 $X$ 输入此单元，计算输出 $o$</li><li>对于此单元的每个 $w_i$ ，<strong>do</strong>: $\triangle w_i +&#x3D; \eta(t-o)x_i$</li></ul></li><li>对于此单元的每个 $w_i$ ，<strong>do</strong>: $w_i+&#x3D;\triangle w_i$</li><li>如果已经是最后一批，打乱训练样例的顺序。</li></ul></li></ul></li></ul><h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul><li><p><strong>误差反向传播算法</strong>（Error Back Propagation）是神经网络的重要算法。它使用链式求导法则将输出层的误差反向传回给网络，使神经网络的权重有了较简单的梯度计算实现方法。</p></li><li><p>信号正向传播，误差反向传播</p></li><li><p>对于训练样例集 $D$ 中的每一个样例记为 $&lt;X,t&gt;$ ，$X$ 是输入值向量，$t$ 为目标输出，$o$ 为实际输出，$w$ 为权重系数</p></li><li><p>损失函数：$$E(W)&#x3D;\frac{1}{2}\sum_{d\in D}(t_d-o_d)^2$$</p></li><li><p>步骤:</p><ul><li>从最后一层开始，计算误差对于该层节点参数的梯度</li><li>基于上一层的梯度值，对当前层参数的梯度值进行计算，重复该步骤，将参数传播至第一层</li></ul></li></ul><div align="center"><img src="/2024/03/13/deep-learning/12.png" width="50%/"></div><hr><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><h3 id="激活函数介绍"><a href="#激活函数介绍" class="headerlink" title="激活函数介绍"></a>激活函数介绍</h3><ul><li><strong>激活函数</strong>（Activation functions）对于神经网络模型去学习、理<strong>解非常复杂和非线性的函数</strong>来说具有十分重要的作用，激活函数的存在将<strong>非线性特性</strong>引入到我们的网络中。</li><li>如果我们不运用激活函数，则输出信号将仅仅是一个简单的线性函数。线性函数的复杂性有限，从数据中学习复杂函数映射的能力更小。<div align="center"><img src="/2024/03/13/deep-learning/13.png" width="70%/"></div></li></ul><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><div align="center"><img src="/2024/03/13/deep-learning/14.png" width="70%/"></div><ul><li>会出现<strong>梯度消失问题</strong></li><li><strong>梯度消失问题</strong>：激活函数在某些输入范围内(往往是远离中心点)的导数趋近于零，反向传播中的梯度也会变得非常小，从而导致梯度消失问题</li></ul><h3 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h3><div align="center"><img src="/2024/03/13/deep-learning/15.png" width="70%/"></div><ul><li>会出现<strong>梯度消失问题</strong></li></ul><h3 id="Softsign函数"><a href="#Softsign函数" class="headerlink" title="Softsign函数"></a>Softsign函数</h3><div align="center"><img src="/2024/03/13/deep-learning/16.png" width="70%/"></div><ul><li>会出现<strong>梯度消失问题</strong>，但比起Sigmoid和tanh要好，在一定程度上缓解了梯度消失问题</li></ul><h3 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h3><div align="center"><img src="/2024/03/13/deep-learning/17.png" width="70%/"></div><ul><li><strong>优点</strong>：<strong>计算量小</strong>，同时进行了<strong>特征选择</strong>，也减缓了梯度消失问题</li><li><strong>缺点</strong>：由于 $x&#x3D;0$ 这个拐角，在分析某些问题时，不能将数据蕴含的一些信息表达出来，尤其是<strong>回归问题</strong>，无法更好地预测</li></ul><h3 id="Softplus函数"><a href="#Softplus函数" class="headerlink" title="Softplus函数"></a>Softplus函数</h3><div align="center"><img src="/2024/03/13/deep-learning/18.png" width="70%/"></div><ul><li>对ReLU函数的更新，计算量有所增加，但可更好地解决回归问题</li></ul><h3 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h3><ul><li>Softmax函数体：$$\sigma(z)_j&#x3D;\frac{e^{Z_j}}{\sum_k e^{Z_k}}$$</li><li>Softmax函数的功能就是将一个 $K$ 维的任意实数向量映射成另一个 $K$ 维的实数向量，其中向量中的每个元素取值都介于 $(0，1)$ 之间。新的向量所有维度模长之和为1。</li><li>Softmax函数经常用作<strong>多分类任务</strong>的输出层。</li></ul><hr><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><h3 id="正则化介绍"><a href="#正则化介绍" class="headerlink" title="正则化介绍"></a>正则化介绍</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>正则化是机器学习中非常重要并且非常有效的减少泛化误差的技术，特别是在深度学习模型中，由于其模型参数非常多非常容易产生过拟合。因此研究者也提出很多有效的技术防止过拟合，比较常用的技术包括:<ul><li>参数添加约束，例如$L_1$、$L_2$范数等。</li><li>训练集合扩充，例如添加噪声、数据变换等。</li><li>Dropout</li><li>提前停止</li></ul></li></ul><h4 id="参数惩罚"><a href="#参数惩罚" class="headerlink" title="参数惩罚"></a>参数惩罚</h4><ul><li>许多正则化方法通过对目标函数 $J$ 添加一个参数惩罚 $\Omega(\theta)$ ,限制模型的学习能力。我们将正则化后的目标函数记为 $\tilde{J}$。$$\tilde{J}(\theta;X,y)&#x3D;J(\theta;X,y)+\alpha\Omega(\theta)$$ 其中 $\alpha \in[0, \infty)$ 是权衡范数惩罚项 $\Omega$ 和标准目标函数 $J(X;\theta)$ 相对贡献的超参数。将 $\alpha$ 设为0表示没有正则化。 $\alpha$ 越大，对应正则化惩罚越大。</li></ul><h3 id="L-1-与-L-2-正则"><a href="#L-1-与-L-2-正则" class="headerlink" title="$L_1$与$L_2$正则"></a>$L_1$与$L_2$正则</h3><h4 id="L-1-正则"><a href="#L-1-正则" class="headerlink" title="$L_1$正则"></a>$L_1$正则</h4><ul><li>对模型参数添加 $L_1$ 范数约束，即：$$\tilde{J}(w;X,y)&#x3D;J(w;X,y)+\alpha ||w||_1$$，</li><li>如果通过梯度方法进行求解时，参数梯度为：$$\nabla \tilde{J}(w)&#x3D;\propto sign(w)+\nabla J(w)$$</li></ul><h4 id="L-2-正则"><a href="#L-2-正则" class="headerlink" title="$L_2$正则"></a>$L_2$正则</h4><ul><li>参数约束添加 $L_2$ 范数惩罚项，该技术<strong>防止过拟合</strong> $$\tilde{J}(w;X,y)&#x3D;J(w;X,y)+\frac{1}{2}\alpha ||w||^2$$，</li><li>通过最优化技术，例如梯度相关方法可以很快推导出，参数优化方式为：$$w &#x3D; (1 - \varepsilon \alpha)\omega - \varepsilon \nabla J(w)$$  其中 $\varepsilon$ 为学习率，相对于正常的梯度优化公式，对参数乘上一个缩减因子。</li></ul><h4 id="L-1-vs-L-2"><a href="#L-1-vs-L-2" class="headerlink" title="$L_1$ vs $L_2$"></a>$L_1$ vs $L_2$</h4><ul><li>Lz与 $L_1$ 的主要区别如下:<ul><li>通过上面的分析，$L_1$ 相对于 $L_2$ 能够产生 ，即当 $L_1$ 正则在参数 $w$ 比较小的情况下，能够直接缩减至0，因此可以起到特征选择的作用。</li><li>如果从概率角度进行分析，很多范数约束相当于对参数添加先验分布，其中 $L_2$范数相当于参数服从<strong>高斯先验分布</strong>; $L_1$ 范数相当于<strong>拉普拉斯分布</strong>。<div align="center"><img src="/2024/03/13/deep-learning/19.png" width="70%/"></div></li></ul></li></ul><h3 id="数据集合扩充"><a href="#数据集合扩充" class="headerlink" title="数据集合扩充"></a>数据集合扩充</h3><ul><li>防止过拟合最有效的方法是增加训练集合，<strong>训练集合越大过拟合概率越小</strong>。数据集合扩充是一个省时有效的方法，但是在不同领域方法不太通用<ul><li>在目标识别领域常用的方法是将图片进行旋转、缩放等（图片变换的前提是通过变换不能改变图片所属类别，例如手写数字识别，类别6和9进行旋转后容易改变类目）。</li><li>语音识别中对输入数据添加随机噪声。</li><li>NLP中常用思路是进行近义词替换。</li><li>噪声注入，可以对输入添加噪声，也可以对隐藏层或者输出层添加噪声。例如对于softmax分类问题可以通过Label Smoothing技术添加噪声，对于类目0-1添加噪声，则对应概率变成 $\frac{\varepsilon}{k}$，$1-\frac{k-1}{k} \varepsilon$</li></ul></li></ul><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><ul><li><p>Dropout是一类通用并且计算简洁的正则化方法，在2014年被提出后广泛的使用。简单的说，Dropout在训练过程中，随机的丢弃一部分输入，此时丢弃部分对应的参数不会更新。相当于Dropout是一个集成方法，将所有子网络结果进行合并，如图通过随机丢弃输入可以得到各种子网络。如图：</p><div align="center"><img src="/2024/03/13/deep-learning/20.png" width="60%/"></div></li><li><p>Dropout工作流程：</p><div align="center"><img src="/2024/03/13/deep-learning/21.png" width="100%/"></div></li><li><p><strong>Dropout的作用</strong>（为什么可以解决过拟合）：</p><ul><li>取平均的作用。</li><li>减少神经元之间复杂的共适应关系。</li><li>Dropout类似于性别在生物进化中的角色。</li></ul></li></ul><h3 id="提前停止训练"><a href="#提前停止训练" class="headerlink" title="提前停止训练"></a>提前停止训练</h3><ul><li>在训练过程中，插入对验证集数据的测试。当发现验证集数据的Loss上升时，提前停止训练。<div align="center"><img src="/2024/03/13/deep-learning/22.png" width="60%/"></div></li></ul><h3 id="随机池化-卷积网络"><a href="#随机池化-卷积网络" class="headerlink" title="随机池化(卷积网络)"></a>随机池化(卷积网络)</h3><h4 id="池化的意义"><a href="#池化的意义" class="headerlink" title="池化的意义"></a>池化的意义</h4><ul><li>既对数据进行降采样操作，又可以用 $p$ 范数作非线性映射的“卷积”:$$||A||<em>p&#x3D;(\sum</em>{i&#x3D;1} ^m \sum_{j&#x3D;1} ^n |a_{ij}|^p)^{\frac{1}{p}}$$</li><li>具体作用为：<ul><li>特征不变性：使模型更关注包含一定的自由度，能容忍特征微小的位移;</li><li>特征降维：降采样使得后续操作的计算量得到减少</li><li>一定程度防止过拟合。</li></ul></li><li>池化层的常见操作∶最大值池化，均值池化，随机池化，中值池化，组合池化等</li></ul><h4 id="最大池化和均值池化"><a href="#最大池化和均值池化" class="headerlink" title="最大池化和均值池化"></a>最大池化和均值池化</h4><ul><li><p><strong>最大池化</strong>：最大值池化的优点在于它能学习到图像的边缘和纹理结构。</p><div align="center"><img src="/2024/03/13/deep-learning/23.png" width="60%/"></div></li><li><p><strong>均值池化</strong>：均值池化的优点在于可以减小估计均值的偏移，提升模型的鲁棒性。</p><div align="center"><img src="/2024/03/13/deep-learning/24.png" width="60%/"></div></li></ul><h4 id="随机池化"><a href="#随机池化" class="headerlink" title="随机池化"></a>随机池化</h4><ul><li><strong>随机池化</strong>：按一定概率随机选取其中一个元素，介于平均池化和最大池化之间，并且受dropout启发，具有更好的正则化效果；可以看作是，在输入图片的许多副本（有一些小的局部变形）上进行标准的最大池化操作。<div align="center"><img src="/2024/03/13/deep-learning/25.png" width="70%/"></div></li></ul><hr><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><h3 id="优化器基本介绍"><a href="#优化器基本介绍" class="headerlink" title="优化器基本介绍"></a>优化器基本介绍</h3><ul><li>在梯度下降算法中，有各种不同的改进版本。在面向对象的语言实现中，往往把不同的梯度下降算法封装成一个对象，称为<strong>优化器</strong>。</li><li>算法改进的目的，包括但不限于:<ul><li>加快算法收敛速度;</li><li>尽量避过或冲过局部极值;</li><li>减小手工参数的设置难度，主要是Learning Rate ( LR)。</li></ul></li><li>常见的优化器如︰普通GD优化器、动量优化器、Nesterov、<strong>Adagrad</strong>、Adadelta、<strong>RMSprop</strong>、<strong>Adam</strong>、AdaMax、Nadam。</li></ul><h3 id="动量优化器"><a href="#动量优化器" class="headerlink" title="动量优化器"></a>动量优化器</h3><h4 id="动量优化器原理"><a href="#动量优化器原理" class="headerlink" title="动量优化器原理"></a>动量优化器原理</h4><ul><li>一个最基本的改进，是为 $\Delta w_{ji}(n)$ 增加动量项。记第 $n$ 次迭代时的权值修正量为 $\Delta w_{ji}(n)$ ，则权值修正法则变为：$$\Delta w_{ji}(n) &#x3D; \eta \delta_j x_{ji}+\alpha \Delta w_{ji}(n-1)$$<br>其中，$\delta_j$ 为惯性的大小，$0\leq a&lt;1$ 是一个常数，称为<strong>动量</strong>(Momentum) 。$\alpha\Delta w_{ji}(n-1)$ 称为动量项。</li><li>想象一个小球，从一个随机的点开始，沿着误差曲面滚下。动量项的引入相当于赋予了小球惯性:<div align="center"><img src="/2024/03/13/deep-learning/26.png" width="60%/"></div></li></ul><h4 id="动量优化器优缺点"><a href="#动量优化器优缺点" class="headerlink" title="动量优化器优缺点"></a>动量优化器优缺点</h4><ul><li>动量优化器的优点是:<ul><li>增加了梯度修正方向的稳定性，减小突变。</li><li>在梯度方向比较稳定的区域，小球滚动会越来越快（当然，因为 $\alpha &lt;1$，其有一个速度上限），这有助于小球快速冲过平坦区域，加快收敛。</li><li>带有惯性的小球更容易滚过一些狭窄的局部极值。</li></ul></li><li>动量优化器的缺点是:<ul><li>学习率 $\eta$ 以及动量 $\alpha$ 仍需手动设置，这往往需要较多的实验来确定合适的值</li></ul></li></ul><h3 id="Adagrad优化器"><a href="#Adagrad优化器" class="headerlink" title="Adagrad优化器"></a>Adagrad优化器</h3><h4 id="Adagrad优化器原理"><a href="#Adagrad优化器原理" class="headerlink" title="Adagrad优化器原理"></a>Adagrad优化器原理</h4><ul><li>随机梯度下降算法(SGD )、小批量梯度下降算法（MBGD）、动量优化器的共同特点是：对于每一个参数都用相同的学习率进行更新。</li><li>Adagrad的思想则是应该为不同的参数设置不同的学习率<br>$$g_t \leftarrow + \frac{1}{m} \nabla_\theta \sum_i L(f(x_i;w),y_i)  ，计算梯度$$ $$r \leftarrow r+g_t^2，累积平方梯度$$ $$\Delta w&#x3D;-\frac{\eta}{\varepsilon +\sqrt{r}}g_t，计算更新$$ $$w \leftarrow w+ \Delta w，应用更新$$<ul><li>$g_t$ 为第 $t$ 次的梯度，$r$ 为梯度累积变量，$r$ 的初始值为 $0$，会一直递增。$\eta$ 为全局学习率，需要手动设置。$\varepsilon$ 为小常数，为了数值稳定大约设置为 $10^{-7}$。</li></ul></li></ul><h4 id="Adagrad优化器优缺点"><a href="#Adagrad优化器优缺点" class="headerlink" title="Adagrad优化器优缺点"></a>Adagrad优化器优缺点</h4><ul><li>从Adagrad优化算法中可以看出，随着算法不断迭代，$r$ 会越来越大，整体的学习率会越来越小。这样做的原因是随着更新次数的增大，我们希望学习率越来越慢。因为我们认为在学习率的最初阶段，我们距离损失函数最优解还很远，随着更新次数的增加，越来越接近最优解，所以学习率也随之变慢。</li><li>优点：<ul><li>学习率自动更新，随着更新次数增加，学习率随之变慢。</li></ul></li><li>缺点：<ul><li>分母会不断累积，这样学习率就会后所并最终变得非常小（可能会提前停止），算法会失去效用。</li></ul></li></ul><h3 id="RMSprop优化器"><a href="#RMSprop优化器" class="headerlink" title="RMSprop优化器"></a>RMSprop优化器</h3><ul><li>RMSprop优化器是一种改进的Adagrad优化器，通过引入一个衰减系数，让 $r$ 每回合都衰减一定的比例。</li><li>RMSprop优化器很好的解决了Adagrad优化器过早结束的问题，很合适处理<strong>非平稳目标</strong>，对于<strong>RNN网络</strong>效果很好。<br>$$g_t \leftarrow + \frac{1}{m} \nabla_\theta \sum_i L(f(x_i;w),y_i)  ，计算梯度$$ $$r \leftarrow \beta r+(1-\beta)g_t^2，累积平方梯度$$ $$\Delta w&#x3D;-\frac{\eta}{\varepsilon +\sqrt{r}}g_t，计算更新$$ $$w \leftarrow w+ \Delta w，应用更新$$<ul><li>$g_t$ 为第 $t$ 次的梯度，$r$ 为梯度累积变量，$r$ 的初始值为 $0$，<strong>未必递增，通过参数调节</strong>。$\beta$ 为<strong>衰减因子</strong>，$\eta$ 为全局学习率，需要手动设置。$\varepsilon$ 为小常数，为了数值稳定大约设置为 $10^{-7}$。</li></ul></li></ul><h3 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h3><ul><li>Adam ( Adaptive Moment Estimation )︰是从Adagrad、Adadelta上发展而来，Adam为每个待训练的变量，维护了两个附加的变量 $m_t$ 和 $v_t$：$$m_t&#x3D;\beta_1m_{t-1}+(1-\beta_1)g_t$$ $$v_t&#x3D;\beta_2v_{t-1}+(1-\beta_2)g_t^2$$</li><li>其中 $t$ 表示第 $t$ 次迭代，$g_t$ 是本次计算出的梯度，从形式上来看 $m_t$ 和 $v_t$ 分别是梯度和梯度平方的移动均值。从统计意义上看，$m_t$ 和 $v_t$ 是梯度的一阶矩(均值）和二阶矩（非中心方差)的估计，因此而得名。</li><li>如果以 $0$ 向量来初始化 $m_t$ 和 $v_t$ ，在开始的一些迭代，尤其是当 $\beta_1$ 和 $\beta_2$ ，接近于 $1$ 的时候， $m_t$ 和 $v_t$ 将非常接近于 $0$，为了解决这个问题，我们实际使用的是 $\widehat{m_t}$ 和 $\widehat{v_t}$：$$\widehat{m_t}&#x3D;\frac{m_t}{1-\beta_1^t}$$ $$\widehat{v_t}&#x3D;\frac{v_t}{1-\beta_2^t}$$</li><li>而Adam的权值更新法则是：$$w_{t+1}&#x3D;w_t-\frac{\eta}{\sqrt{\widehat{v_t}}+\epsilon}\widehat{m_t}$$</li><li>虽然上面的法则中依然存在人工设置 $\eta$ 、$\beta_1$ 、$\beta_2$ ，但他们的设置难度大大降低。根据实验，一般取 $\beta_1&#x3D;0.9$，$\beta_2&#x3D;0.999$，$\epsilon &#x3D; 10^{-8}$，$\eta&#x3D;0.001$。在实际使用过程中，Adam将迅速收敛，当收敛到饱和的时候，可以适当降低，一般降低几次之后，即会收敛到满意的（局部）极值。其他参数一般不必调整。</li></ul><h3 id="优化器性能比较"><a href="#优化器性能比较" class="headerlink" title="优化器性能比较"></a>优化器性能比较</h3><div align="center"><img src="/2024/03/13/deep-learning/27.png" width="100%/"></div><hr><h2 id="神经网络类型"><a href="#神经网络类型" class="headerlink" title="神经网络类型"></a>神经网络类型</h2><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><h4 id="卷积神经网络基本介绍"><a href="#卷积神经网络基本介绍" class="headerlink" title="卷积神经网络基本介绍"></a>卷积神经网络基本介绍</h4><ul><li><strong>卷积神经网络</strong>(Convolutional Neural Network,<strong>CNN</strong>)是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于<strong>图像处理</strong>有出色表现。它包括<strong>卷积层</strong>(convolutional layer)，<strong>池化层</strong>(pooling layer)和<strong>全连接层</strong>(fully_connected layer)。</li><li>20世纪60年代，Hubel和wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络(ConvolutionalNeural Networks-简称CNN)。</li><li>现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。</li></ul><h4 id="卷积神经网络核心思想"><a href="#卷积神经网络核心思想" class="headerlink" title="卷积神经网络核心思想"></a>卷积神经网络核心思想</h4><ul><li><strong>局部感知</strong>：一般认为，人对外界的认知是从局部到全局的，而<strong>图像的空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱</strong>。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。</li><li><strong>参数共享</strong>：对输入的图片，用一个或者多个卷积核扫描照片，卷积核自带的参数就是权重，在同一个卷积核扫描的图层当中，每个卷积核使用同样的参数进行加权计算。<strong>权值共享意味着每一个卷积核在遍历整个图像的时候，卷积核的参数是固定不变的。</strong></li></ul><h4 id="卷积神经网络架构"><a href="#卷积神经网络架构" class="headerlink" title="卷积神经网络架构"></a>卷积神经网络架构</h4><div align="center"><img src="/2024/03/13/deep-learning/28.png" width="100%/"></div><h4 id="单卷积核计算"><a href="#单卷积核计算" class="headerlink" title="单卷积核计算"></a>单卷积核计算</h4><ul><li><strong>卷积计算描述</strong><div align="center"><img src="/2024/03/13/deep-learning/29.png" width="100%/"></div></li></ul><div align="center"><img src="/2024/03/13/deep-learning/30.png" width="60%/"></div><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><ul><li>卷积神经网络的基本结构，就是多通道卷积（由多个单卷积构成)。上一层的输出（或者第一层的原始图像），作为本层的输入，然后和本层的卷积核卷积，作为本层输出。而各层的卷积核，就是要学习的权值。和FCN类似，卷积完成后，输入下一层之前，也需要经过偏置和通过激活函数进行激活。<div align="center"><img src="/2024/03/13/deep-learning/31.png" width="90%/"></div></li></ul><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><ul><li>池化(Pooling)，它合并了附近的单元，减小了下层输入的尺寸，起到<strong>降维</strong>的作用。常用的池化有最大池化(Max Pooling)和平均池化(Average Pooling)，顾名思义，最大池化选择一小片正方形区域中最大的那个值作为这片小区域的代表，而平均池化则使用这篇小区域的均值代表之。这片小区域的边长为池化窗口尺寸。下图演示了池化窗口尺寸为2的一般最大池化操作。<div align="center"><img src="/2024/03/13/deep-learning/32.png" width="90%/"></div></li></ul><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><ul><li>全连接层实质上就是一个分类器，将前面经过卷积层与池化层所提取的特征，拉直后放到全连接层中，输出结果并分类。</li><li>通常我们使用Softmax函数作为最后全连接输出层的激活函数，把所有局部特征结合变成全局特征，用来计算最后每一类的得分。<br>$$\sigma(z)_j&#x3D;\frac{e^{Z_j}}{\sum_k e^{Z_k}}$$</li></ul><h3 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h3><h4 id="循环神经网络基本介绍"><a href="#循环神经网络基本介绍" class="headerlink" title="循环神经网络基本介绍"></a>循环神经网络基本介绍</h4><ul><li><strong>循环神经网络</strong>（Recurrent neural networks，简称<strong>RNN</strong>）是一种通过隐藏层节点周期性的连接，来<strong>捕捉序列化数据中动态信息的神经网络</strong>，可以对序列化的数据进行分类。</li><li>和其他前向神经网络不同，RNN可以保存一种<strong>上下文</strong>的状态，甚至能够在任意长的上下文窗口中存储、学习、表达相关信息，而且不再局限于传统神经网络在空间上的边界，可以在<strong>时间序列上有延拓</strong>，直观上讲，就是本时间的隐藏层和下一时刻的隐藏层之间的节点间有边。</li><li>RNN广泛应用在和序列有关的场景，如如一帧帧图像组成的视频，一个个片段组成的音频，和一个个词汇组成的句子。</li></ul><h4 id="循环神经网络架构"><a href="#循环神经网络架构" class="headerlink" title="循环神经网络架构"></a>循环神经网络架构</h4><div align="center"><img src="/2024/03/13/deep-learning/33.png" width="90%/"></div><div align="center"><img src="/2024/03/13/deep-learning/34.png" width="90%/"></div><h4 id="循环神经网络类型"><a href="#循环神经网络类型" class="headerlink" title="循环神经网络类型"></a>循环神经网络类型</h4><div align="center"><img src="/2024/03/13/deep-learning/35.png" width="90%/"></div><h4 id="时序反向传播-BPTT"><a href="#时序反向传播-BPTT" class="headerlink" title="时序反向传播(BPTT)"></a>时序反向传播(BPTT)</h4><ul><li>时序反向传播(BPTT):<ul><li>传统反向传播(BP)在时间序列上的拓展</li><li>t 时刻的梯度是前 t -1 时刻所有梯度的累积</li><li>时间越长，梯度消失越明显</li></ul></li><li>BPTT的三个步骤:<ul><li>前向计算每个神经元的输出值</li><li>反向计算每个神经元的误差值 $\delta_j$</li><li>计算每个权重的梯度</li></ul></li><li>最后使用随机梯度下降算法更新权重。</li></ul><h4 id="循环神经网络问题"><a href="#循环神经网络问题" class="headerlink" title="循环神经网络问题"></a>循环神经网络问题</h4><ul><li>标准RNN结构解决了信息记忆的问题，但是对<strong>长时间记忆的信息会衰减</strong>。</li><li>很多任务需要保存长时间的记忆信息，如推理小说开头埋下的伏笔，可能到结尾时候才解答。</li><li>在记忆单元容量有限的情况下，RNN会丢失长时间间隔的信息。</li><li>我们希望记忆单元能够选择性记住重点信息。</li></ul><h4 id="长短记忆性网络"><a href="#长短记忆性网络" class="headerlink" title="长短记忆性网络"></a>长短记忆性网络</h4><div align="center"><img src="/2024/03/13/deep-learning/36.png" width="90%/"></div><h5 id="Gated-Recurrent-Unit-GRU"><a href="#Gated-Recurrent-Unit-GRU" class="headerlink" title="Gated Recurrent Unit ( GRU )"></a>Gated Recurrent Unit ( GRU )</h5><div align="center"><img src="/2024/03/13/deep-learning/37.png" width="90%/"></div><h3 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h3><h4 id="生成对抗网络基本介绍"><a href="#生成对抗网络基本介绍" class="headerlink" title="生成对抗网络基本介绍"></a>生成对抗网络基本介绍</h4><ul><li>生成对抗网络(Generative Adversarial Nets)是一种<strong>框架</strong>，通过对抗过程，通过训练生成器G和判别器D。两者进行的博弈，最终使判别器无法区分样本是来自生成器伪造的样本还是真实样本。训练GAN框架采用成熟的BP算法。</li></ul><ol><li>生成器G：输入“噪声”z（z服从一个人为选取的先验概率分布，如均匀分布、高斯分布等）。采用多层感知机的网络结构，用最大似然估计(MLP)的参数来表示可导映射G(z)，将输入空间映射到样本空间。</li><li>判别器D：输入为真实样本x和伪造样本G(z)，并分别带有标签real和fake。判别器网络可以用带有参数多层感知机。输出为判别样本是否为真实样本数据的概率D(G(z))。</li></ol><ul><li>生成对抗网络可应用于<strong>图像生成</strong>、<strong>语义分割</strong>、<strong>文字生成</strong>、<strong>数据增强</strong>、<strong>聊天机器人和信息检索</strong>，排序等场景。</li></ul><h4 id="生成对抗网络架构"><a href="#生成对抗网络架构" class="headerlink" title="生成对抗网络架构"></a>生成对抗网络架构</h4><ul><li>生成器( Generator)&#x2F;判别器( Discriminator )<div align="center"><img src="/2024/03/13/deep-learning/38.png" width="90%/"></div></li></ul><h4 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h4><div align="center"><img src="/2024/03/13/deep-learning/39.png" width="100%/"></div><h4 id="生成对抗网络训练法则"><a href="#生成对抗网络训练法则" class="headerlink" title="生成对抗网络训练法则"></a>生成对抗网络训练法则</h4><ul><li>优化目标：<ul><li>价值函数(Value Function) $$min_{G} max_{D}V (D,G)&#x3D;E_{x\sim p_{data}(x)}[logD(x)]+E_{z\sim p_{z}(z)}[log(1-D(G(z)))]$$</li><li>训练初期，当 $G$ 的生成效果很差时，$D$ 会以高置信度来判别生成样本为假，因为它们与训练数据明显不同此时，$log(1-D(G(z)))$ 饱和（即梯度为 $0$，无法迭代）。因此我们选择只通过最小化 $[-log(D(G(z)))]$ 来训练 $G$。</li></ul></li></ul><hr><h2 id="深度学习的常见问题"><a href="#深度学习的常见问题" class="headerlink" title="深度学习的常见问题"></a>深度学习的常见问题</h2><h3 id="数据不平衡问题"><a href="#数据不平衡问题" class="headerlink" title="数据不平衡问题"></a>数据不平衡问题</h3><ul><li><p><strong>问题描述</strong>：在分类任务的数据集中，各个类别的样本数目不均衡，出现巨大的差异，预测的类别里有一个或者多个类别的样本量非常少。</p></li><li><p>比如：图像识别实验中，在4251个训练图片中，有超过2000个类别中只有一张图片。还有一些类中有2-5个图片。</p></li><li><p>导致问题:</p><ul><li>对于不平衡类别，我们不能得到实时的最优结果，因为模型&#x2F;算法从来没有充分地考察隐含类。</li><li>它对验证和测试样本的获取造成了一个问题，因为在一些类观测极少的情况下，很难在类中有代表性。</li></ul></li><li><p><strong>解决办法</strong>：</p><ul><li>随机欠采样<ul><li>删除样本中多的样本</li><li>优点：运行或训练模型的时间比较少，减少存储</li><li>缺点：一些有潜在价值的信息可能被删除，存在偏差，导致结果不精确</li></ul></li><li>随机过采样<ul><li>拷贝样本</li><li>优点：不会导致偏差，结果要优于欠采样</li><li>缺点：加大过拟合的可能性</li></ul></li><li>合成采样<ul><li>提取样本</li><li>合成样本      </li><li>优点：缓解过拟合问题，也不会导致有价值的信息被删除</li><li>缺点：类重叠性增加，引入额外的噪音，导致模型效果差，不适用于高维数据</li></ul></li></ul></li></ul><h3 id="梯度消失问题"><a href="#梯度消失问题" class="headerlink" title="梯度消失问题"></a>梯度消失问题</h3><ul><li><p><strong>梯度消失</strong>：当网络层数越多时，进行反向传播求导值越小，导致梯度消失。</p></li><li><p><strong>梯度爆炸</strong>：当网络层数越多时，进行反向传播求导值越大，导致梯度爆炸。</p></li><li><p>导致原因：$$y_i&#x3D;\sigma(z_i)&#x3D;\sigma (w_ix_i+b_i)，其中\sigma为sigmoid函数$$</p><div align="center"><img src="/2024/03/13/deep-learning/40.png" width="60%/"></div></li><li><p>$\sigma’(x)$ 的最大值为 $\frac{1}{4}$</p><div align="center"><img src="/2024/03/13/deep-learning/41.png" width="65%/"></div></li><li><p>而网络权值 $|w|$ 通常都小于 $1$ ，因此$|\sigma’(z)w|≤\frac{1}{4}$，因此对于上面的链式求导，层数越多，求导结果 $\frac{\partial C}{\partial b_1}$ 越小，因而导致梯度消失的情况出现。</p></li><li><p>当网络权值 $|w|$ 比较大时，导致 $|\sigma’(z)w| &gt;1$，出现梯度爆炸。</p></li><li><p><strong>解决方法</strong>：梯度剪切、正则、ReLU激活函数、LSTM神经网络等。</p></li></ul><h3 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h3><ul><li><strong>问题描述</strong>：模型在训练集表现优异，但在测试集上表现较差。</li><li>根本原因：特征维度过多，模型假设过于复杂，参数过多，训练数据过少，噪声过多，导致拟合的函数完美的预测训练集，但对新数据的测试集预测结果差。过度的拟合了训练数据，而没有考虑到泛化能力。</li><li><strong>解决方法</strong>:<ol><li>数据增强;</li><li>正则化，降低参数值;</li><li>限制训练时间;</li><li>Dropout。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础笔记</title>
      <link href="/2024/03/13/machine-learning/"/>
      <url>/2024/03/13/machine-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习基础笔记"><a href="#机器学习基础笔记" class="headerlink" title="机器学习基础笔记"></a>机器学习基础笔记</h1><hr><h2 id="机器学习介绍"><a href="#机器学习介绍" class="headerlink" title="机器学习介绍"></a>机器学习介绍</h2><h3 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h3><ul><li>机器学习（包括深度学习分支）是研究“学习算法”的一门学问</li><li>所谓“学习”是指:对于某类任务T和性能度量P，一个计算机程序在T上以P衡量的性能随着经验E而自我完善，那么我们称这个计算机程序在从经验E学习。<br><img src="/2024/03/13/machine-learning/1.png"></li><li>人类学习与机器学习<div align="center"><img src="/2024/03/13/machine-learning/2.png"></div></li></ul><h3 id="机器学习算法与传统基于规则的区别"><a href="#机器学习算法与传统基于规则的区别" class="headerlink" title="机器学习算法与传统基于规则的区别"></a>机器学习算法与传统基于规则的区别</h3><p><img src="/2024/03/13/machine-learning/3.png"></p><h3 id="什么时候该使用机器学习"><a href="#什么时候该使用机器学习" class="headerlink" title="什么时候该使用机器学习"></a>什么时候该使用机器学习</h3><ul><li>问题的解决方案很复杂，或者问题可能涉及到大量的数据却没有明确的数据分布函数</li><li>遇到如下情况，可以考虑使用机器学习:<br><img src="/2024/03/13/machine-learning/4.png"></li></ul><h3 id="机器学习算法的理性认识"><a href="#机器学习算法的理性认识" class="headerlink" title="机器学习算法的理性认识"></a>机器学习算法的理性认识</h3><p><img src="/2024/03/13/machine-learning/5.png"></p><ul><li>目标函数$f$未知，学习算法无法得到一个完美的函数$f$</li><li>假设函数$g$逼近函数$f$，但是可能和函数$f$不同</li></ul><h3 id="机器学习解决的主要问题"><a href="#机器学习解决的主要问题" class="headerlink" title="机器学习解决的主要问题"></a>机器学习解决的主要问题</h3><ul><li>机器学习可以解决多种类型的任务，下面列出最典型的常见的三种:<ul><li><strong>分类</strong>：计算机程序需要指定输入属于$k$ 类中的哪一类。为了完成这个任务，学习算法通常会输出一个函数$f$ : $R^n→(1,2. … k.)$。比如计算机视觉中的图像分类算法解决的就是一个分类任务。</li><li><strong>回归</strong>：这类任务中，计算机程序会对给定输入预测输出数值。学习算法通常会输出一个函数$f$ : $R^n →R$，这类任务的一个示例是预测投保人的索赔金额（用于设置保险费），或者预测证券未来的价格。</li><li><strong>聚类</strong>：对大量<strong>未知标注</strong>（也是与分类的最大区别）的数据集，按数据的内在相似性，将数据划分为多个类别，是类别内的数据相似度较大，而类别间的相似性比较小。可以被运用在图片检索，用户画像等场景中</li></ul></li><li>分类和回归是预测问题的两种主要类型，占到80%-90%，分类的输出是离散的类别值，而回归的输出是连续数值。</li></ul><hr><h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><h3 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h3><ul><li>几十年来，研究发表的机器学习的方法种类很多，根据强调侧面的不同可以有多种分类方法。</li><li>常见分类方法如下：<ul><li>基于学习策略的分类；</li><li>基于学习方法的分类；</li><li>基于学习方式的分类；</li><li>基于数据形式的分类；</li><li>基于学习目标的分类</li></ul></li><li>本文介绍最为常见的分类方式———<strong>基于学习方式的分类</strong></li></ul><h3 id="基于学习方式的分类"><a href="#基于学习方式的分类" class="headerlink" title="基于学习方式的分类"></a>基于学习方式的分类</h3><ul><li><strong>监督学习</strong>：利用已知类别(<strong>即有标签</strong>)的样本，训练学习得到一个最优模型，使其达到所要求性能，再利用这个训练所得模型，将所有的输入映射为相应的输出，对输出进行简单的判断，从而实现分类的目的，即可以对未知数据进行分类。</li><li><strong>无监督学习</strong>：对于没有标记(<strong>即无标签</strong>)的样本，学习算法直接对输入数据集进行建模，例如<strong>聚类</strong>，即“物以类聚，人以群分”。我们只需要把相似度高的东西放在一起，对于新来的样本，计算相似度后，按照相似程度进行归类就好。</li><li><strong>半监督学习</strong>：试图让学习器自动地对大量未标记数据进行利用以辅助少量有标记数据进行学习。</li><li><strong>强化学习</strong>：学习系统从环境到行为<strong>映射</strong>的学习，以使奖励信号(强化信号)函数值最大，强化学习不同于连接主义学习中的监督学习，主要表现在教师信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价(通常为标量信号)，而不是告诉强化学习系统如何去产生正确的动作。</li></ul><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p><img src="/2024/03/13/machine-learning/6.png"></p><h4 id="监督学习-回归问题"><a href="#监督学习-回归问题" class="headerlink" title="监督学习 - 回归问题"></a>监督学习 - 回归问题</h4><ul><li>回归：反映了样本数据集中样本的属性值的特性通过函数表达样本映射的关系来发现属性值之间的依赖关系。<ul><li>下周股票能给我带来多少收益?</li><li>周二的温度会是多少摄氏度?</li></ul></li><li>回归问题的关键在于，试图找到最适合的一条线拟合数据点</li><li>如图所示:<br><img src="/2024/03/13/machine-learning/7.png"></li></ul><h4 id="监督学习-分类问题"><a href="#监督学习-分类问题" class="headerlink" title="监督学习 - 分类问题"></a>监督学习 - 分类问题</h4><ul><li>分类：分类问题属于有监督学习，通过分类模型，将样本数据集中的样本映射到某个给定的类别中。<ul><li>明天早高峰时间段xx路上会堵车吗?</li><li>哪种手段更吸引顾客：5元代金券or打75折</li></ul></li></ul><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p><img src="/2024/03/13/machine-learning/8.png"></p><h4 id="无监督学习-聚类问题"><a href="#无监督学习-聚类问题" class="headerlink" title="无监督学习 - 聚类问题"></a>无监督学习 - 聚类问题</h4><ul><li>聚类：通过聚类模型，将样本数据集中的样本分为几个类别，属于同一类别的样本相似性比较大。<ul><li>哪些观众喜欢看同一题材的电影?</li><li>这些零部件中哪些破损的方式是相似的?<div align="center"><img src="/2024/03/13/machine-learning/9.png" width="60%/"><img src="/2024/03/13/machine-learning/10.png" width="60%/"></div></li></ul></li></ul><h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p><img src="/2024/03/13/machine-learning/11.png"></p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><ul><li>模型感知环境，做出行动，根据状态与奖惩做出调整和选择<br><img src="/2024/03/13/machine-learning/12.png"></li></ul><h4 id="强化学习-最佳行为"><a href="#强化学习-最佳行为" class="headerlink" title="强化学习 - 最佳行为"></a>强化学习 - 最佳行为</h4><ul><li>强化学习：强化学习总是在寻找什么样的行动才是最佳的?强化学习针对的对象是机器或者机器人。<ul><li>自动驾驶汽车:黄灯开始闪了，是刹车还是加速通过?</li><li>对于一个吸尘机器人，是继续吸尘还是回去充电?</li></ul></li></ul><hr><h2 id="机器学习整体流程"><a href="#机器学习整体流程" class="headerlink" title="机器学习整体流程"></a>机器学习整体流程</h2><p><img src="/2024/03/13/machine-learning/13.png"></p><h3 id="机器学习基本概念-数据集"><a href="#机器学习基本概念-数据集" class="headerlink" title="机器学习基本概念 - 数据集"></a>机器学习基本概念 - 数据集</h3><ul><li><strong>数据集</strong>：在机器学习任务中使用的一组数据，其中的每一个数据称为一个样本。反映样本在某方面的表现或性质的事项或属性称为特征。</li><li><strong>训练集</strong>：训练过程中使用的数据集，其中每个训练样本称为训练样本。从数据中学得模型的过程称为学习(训练)。</li><li><strong>测试集</strong>：学得模型后，使用其进行预测的过程称为测试，使用的数据集称为测风果，母个样本称为测试样本。</li><li>典型的数据集样式：<br><img src="/2024/03/13/machine-learning/14.png"></li><li>数据对于模型来说就是至关重要的，是<strong>模型能力的天花板</strong>，没有好的数据，就没有好的模型。因此<strong>数据预处理</strong>也就是重中之重。</li></ul><h3 id="数据预处理-数据清洗"><a href="#数据预处理-数据清洗" class="headerlink" title="数据预处理(数据清洗)"></a>数据预处理(数据清洗)</h3><p><img src="/2024/03/13/machine-learning/15.png"></p><h4 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h4><ul><li><p>数据清理的工作量</p><div align="center"><img src="/2024/03/13/machine-learning/16.png" width="70%/"></div></li><li><p>大部分的机器学习模型所处理的都是特征，特征通常是输入变量所对应的可用于模型的数值表示。</p></li><li><p>大部分情况下，收集得到的数据需要经过预处理后才能够为算法所使用，预处理的操作主要包括以下几个部分:</p><ul><li>数据过滤</li><li>处理数据缺失</li><li>处理可能的异常、错误或者异常值- 合并多个数据源数据</li><li>数据汇总</li></ul></li></ul><h4 id="“脏”数据"><a href="#“脏”数据" class="headerlink" title="“脏”数据"></a>“脏”数据</h4><ul><li>真实的数据中通常会出现一些数据质量问题:<ul><li>不完整:数据中缺少属性或者包含一些确实的值。</li><li>多噪音:数据包含错误的记录或者异常点。</li><li>不一致:数据中存在矛盾的、有差异的记录。<br><img src="/2024/03/13/machine-learning/17.png"></li></ul></li></ul><h3 id="数据的转换（特征提取与选择）"><a href="#数据的转换（特征提取与选择）" class="headerlink" title="数据的转换（特征提取与选择）"></a>数据的转换（特征提取与选择）</h3><ul><li>对数据进行初步的预处理后，需要将其转换为一种适合机器学习模型的表示形式，以下是一些常见的数据转化的形式。<ul><li>在分类问题中，将类别数据编码成为对应的数值表示(哑编码)</li><li>数值数据转换为类别数据以减少变量的值(对年龄分段)</li><li>其他数据<ul><li>从文本数据中提取有用的数据(一般使用词袋法、TF-IDF或者word2vec)</li><li>处理图像数据(颜色空间，灰度化，几何变化，haar特征等，图像增强)</li></ul></li><li>特征工程<ul><li>对特征进行归一化、标准化，以保证同一模型的不同输入变量的值域相同</li><li>特征扩充:对现有变量进行组合或转换以生成新特征，比如平均数</li></ul></li></ul></li></ul><h4 id="特征选择的必要性"><a href="#特征选择的必要性" class="headerlink" title="特征选择的必要性"></a>特征选择的必要性</h4><ul><li>通常情况下，一个数据集当中存在很多种不同的特征，其中一些可能是多余的或者与我们要预测的值无关的。</li><li>特征选择技术的必要性体现在:<ul><li>简化模型，是模型个容易被使用者所解释</li><li>减少训练的时间</li><li>避免维度爆炸的问题</li><li>提升模型泛化性，避免过拟合</li></ul></li></ul><h4 id="特征选择的方法-Filter"><a href="#特征选择的方法-Filter" class="headerlink" title="特征选择的方法 - Filter"></a>特征选择的方法 - Filter</h4><ul><li><p><strong>过滤法(filter)</strong> 在选择特征的时候是独立的，与模型本身无关。</p></li><li><p><strong>Filter过程</strong>：</p><div align="center"><img src="/2024/03/13/machine-learning/18.png" width="70%/"></div></li><li><p>通过评估每个特征和目标属性之间的<strong>相关性</strong>，这些方法应用一个统计度量来为每个特征赋值。然后根据分数对这些特性进行排序，这可以用来帮助保留或消除特定特征</p></li><li><p>常见的方法</p><ul><li>皮尔逊相关系数</li><li>卡方系数</li><li>互信息</li></ul></li><li><p>过滤法的局限</p><ul><li>过滤方法倾向于选择<strong>冗余的变量</strong>，因为它们没有考虑特征之间的关系。</li></ul></li></ul><h4 id="特征选择的方法-wapper"><a href="#特征选择的方法-wapper" class="headerlink" title="特征选择的方法 - wapper"></a>特征选择的方法 - wapper</h4><ul><li><p><strong>包装器(wapper)</strong> 方法使用一个预测模型来对对特征子集进行评分。</p></li><li><p><strong>wapper过程</strong>：</p><div align="center"><img src="/2024/03/13/machine-learning/19.png" width="70%/"></div></li><li><p>包装器方法将特征选择问题视为一个搜索问题，在这个问题中，将评估和比较不同的组合。在这里，预测模型用于评估特征的组合的工具，根据模型的准确性进行评分</p></li><li><p>常见的方法</p><ul><li>特征递归消除法</li></ul></li><li><p>包装法的局限</p><ul><li>因为包装器方法为每个子集训练一个新模型时，所以它们的计算量非常大。</li><li>其特征选择的方法通常为特定类型的模型提供了性能最好的特性集。</li></ul></li></ul><h4 id="特征选择的方法-Embedded"><a href="#特征选择的方法-Embedded" class="headerlink" title="特征选择的方法 - Embedded"></a>特征选择的方法 - Embedded</h4><ul><li><p><strong>嵌入法(Embedded)</strong> 的方法将特征选择作为模型构建的一部分。</p></li><li><p><strong>Embedded过程</strong>：</p><div align="center"><img src="/2024/03/13/machine-learning/20.png" width="70%/"></div></li><li><p>最常见的嵌入式特征选择方法是<strong>正则化方法</strong>。正则化方法也称为惩罚方法，它在优化预测算法时引入额外的约束，使模型的复杂度降低，也就是减少了特征的数量。</p></li><li><p>常见的方法</p><ul><li>LASSO回归</li><li>RIDGE回归</li></ul></li></ul><h3 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h3><h4 id="模型构建项目整体流程"><a href="#模型构建项目整体流程" class="headerlink" title="模型构建项目整体流程"></a>模型构建项目整体流程</h4><p><img src="/2024/03/13/machine-learning/21.png"></p><ul><li>接下来将以有监督学习为例，讲解各阶段</li></ul><h4 id="有监督学习实例-学习阶段"><a href="#有监督学习实例-学习阶段" class="headerlink" title="有监督学习实例 - 学习阶段"></a>有监督学习实例 - 学习阶段</h4><ul><li>使用分类模型来判断，在特定特征下这个人是否是要更换供货商。<br><img src="/2024/03/13/machine-learning/22.png"></li></ul><h4 id="有监督学习实例-预测阶段"><a href="#有监督学习实例-预测阶段" class="headerlink" title="有监督学习实例 - 预测阶段"></a>有监督学习实例 - 预测阶段</h4><p><img src="/2024/03/13/machine-learning/23.png"></p><h4 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h4><ul><li><strong><font color="#dd0000">泛化能力</font></strong><ul><li>能否在实际的业务数据也能预测准确</li></ul></li><li><strong>可解释性</strong><ul><li>预测的结果是否容易被解释</li></ul></li><li><strong>预测速率</strong><ul><li>每一条数据的预测需要多长时间</li></ul></li><li><strong>可塑性</strong><ul><li>实际业务过程中数据量可能很大，随着业务量增大，预测的速率是否仍然可以接受</li></ul></li></ul><h5 id="模型的有效性（即泛化能力）"><a href="#模型的有效性（即泛化能力）" class="headerlink" title="模型的有效性（即泛化能力）"></a>模型的有效性（即泛化能力）</h5><ul><li><strong>泛化能力</strong>：机器学习的目标是使学得的模型能够很好的适用于新的样本，而不是仅仅在训练样本上工作的很好，学得的模型适用于新样本的能力称为泛化能力，也称为鲁棒性。</li><li><strong>误差</strong>：学习到的模型在样本上的预测结果与样本的真实结果之间的差。<ul><li><strong>训练误差</strong>：模型在训练集上的误差。</li><li><strong>泛化误差</strong>：在新样本上的误差。显然，我们更希望得到泛化误差小的模型。</li></ul></li><li><strong>欠拟合</strong>：如果训练误差很大的现象。</li><li><strong>过拟合</strong>：如果学得的模型的训练误差很小，而泛化能力较弱即泛化误差较大的现象。</li><li><strong>模型的容量</strong>：指其拟合各种函数的能力，也称为模型的复杂度。<ul><li>容量适合于执行任务的复杂度和所提供训练数据的数量时，算法效果通常会最佳;</li><li><strong>容量不足</strong>的模型不能解决复杂任务，可能出现<strong>欠拟合</strong>;</li><li><strong>容量高</strong>的模型能够解决复杂的任务，但是其容量高于任务所需时，有可能会<strong>过拟合</strong>。<br><img src="/2024/03/13/machine-learning/24.png"></li></ul></li></ul><h5 id="过拟合的原因-误差"><a href="#过拟合的原因-误差" class="headerlink" title="过拟合的原因 - 误差"></a>过拟合的原因 - 误差</h5><ul><li>最终预测的<strong>总误差</strong> &#x3D; 偏差$^2$＋方差＋不可消解的误差</li><li>预测误差总的来说可以被拆解出两种主要的我们需要关注的子形式:<ul><li>来源于“偏差”的误差</li><li>来源于“方差”的误差</li></ul></li><li><strong>方差(Variance)</strong>:<ul><li>模型的预测结果在均值附近的偏移的幅度</li><li>来源于模型在训练集上对小波动的敏感性的误差·</li></ul></li><li><strong>偏差(Bias)</strong>:<ul><li>模型的预期(或平均)预测值与我们试图预测的正确值之间的差异。<div align="center"><img src="/2024/03/13/machine-learning/25.png" width="40%/"></div></li></ul></li></ul><h5 id="方差与偏差"><a href="#方差与偏差" class="headerlink" title="方差与偏差"></a>方差与偏差</h5><ul><li><p>以下四种形式表示了方差与偏差不同组合方式:</p><ul><li>低偏差&amp;低方差→<strong>好模型</strong></li><li>低偏差&amp;高方差</li><li>高偏差&amp;低方差</li><li>高偏差&amp;高方差→不良模型<div align="center"><img src="/2024/03/13/machine-learning/26.png" width="60%/"></div></li></ul></li><li><p>理想状态下，我们想要选择一个模型，它既能准确地捕获训练数据中的规律，又能很好地概括不可见数据(即新数据)。但是，通常我们不可能同时完成这两件事.</p></li></ul><h5 id="模型的复杂度与误差"><a href="#模型的复杂度与误差" class="headerlink" title="模型的复杂度与误差"></a>模型的复杂度与误差</h5><ul><li>随着模型复杂度上升的增加，训练误差逐渐减小。</li><li>同时，测试误差会随着复杂的增大而减小到某一点，继而反向增大，形成一条凸曲线。<br><img src="/2024/03/13/machine-learning/27.png"></li></ul><h4 id="机器学习其他性能评估指标-回归"><a href="#机器学习其他性能评估指标-回归" class="headerlink" title="机器学习其他性能评估指标 - 回归"></a>机器学习其他性能评估指标 - 回归</h4><ul><li><strong>MAE(Mean Absolute Error)平均绝对误差</strong>，越趋近于0表示模型越拟合训练数据。$$MAE&#x3D;\frac{1}{m} \sum^m_{i&#x3D;1} |y_i-\hat{y_i}|$$</li><li><strong>MSE(Mean Square Error)</strong> $$MSE&#x3D;\frac{1}{m} \sum^m_{i&#x3D;1} (y_i-\hat{y_i})^2$$</li><li>$R^2$取值范围$($负无穷,$1]$，值越大表示模型越拟合训练数据其中TSS表示样本之间的差异情况，RSS表示预测值与样本值之间的差异情况<br>$$R^2&#x3D;1-\frac{RSS}{TSS}&#x3D;1-\frac{\sum^m_{i&#x3D;1}(y_i-\hat{y_i})^2}{\sum^m_{i&#x3D;1}(y_i-\bar{y_i})^2}$$</li></ul><h4 id="机器学习其他性能评估指标-分类"><a href="#机器学习其他性能评估指标-分类" class="headerlink" title="机器学习其他性能评估指标 - 分类"></a>机器学习其他性能评估指标 - 分类</h4><ul><li>术语:<ul><li>$P$：正元组，感兴趣的主要类的元组。</li><li>$N$：负元组，其他元组。</li><li>$TP$：真正例，被分类器正确分类的正元组。</li><li>$TN$：真负例，被分类器正确分类的负元组。</li><li>$FP$：假正例，被错误地标记为正元组的负元组。</li><li>$FN$：假负例，被错误的标记为负元组的正元组。</li></ul></li><li>混淆矩阵:是一个至少为$m ×m$的表。前$m$行和$m$列的表目$CM_{i,j}$指出类 $i$ 的元组被分类器标记为 $j$ 的个数。</li><li>理想的，对于高准确率的分类器，大部分元组应该被混淆矩阵从$CM_{1,1}$到$CM_{m,m}$的对角线上的表目表示，而其他表目为0或者接近于0。即$FP$和$FN$接近0。</li></ul><div align="center"><img src="/2024/03/13/machine-learning/28.png" width="60%/"></div><div align="center"><img src="/2024/03/13/machine-learning/29.png" width="80%/"></div><ul><li><strong>实例</strong><ul><li>训练了一个机器学习的模型用来识别图片中是不是一只猫,现在用200张图片来验证下模型的性能指标。这200张图片中，170张是猫，30张不是猫。模型的识别结果为160张是猫，40张不是猫。<ul><li>精度：$P&#x3D;\frac{TP}{TP+FP}&#x3D;\frac{140}{140+20}&#x3D;87.5% $</li><li>召回率：$R&#x3D;\frac{TP}{P}&#x3D;\frac{140}{170}&#x3D;82.4%$</li><li>准确率：$ACC&#x3D;\frac{TP+TN}{P+N}&#x3D;\frac{140+10}{170+30}&#x3D;75%$<div align="center"><img src="/2024/03/13/machine-learning/30.png" width="50%/"></div></li></ul></li></ul></li></ul><hr><h2 id="其他机器学习重要方法"><a href="#其他机器学习重要方法" class="headerlink" title="其他机器学习重要方法"></a>其他机器学习重要方法</h2><h3 id="机器学习训练方法-梯度下降"><a href="#机器学习训练方法-梯度下降" class="headerlink" title="机器学习训练方法 - 梯度下降"></a>机器学习训练方法 - 梯度下降</h3><h4 id="梯度下降介绍"><a href="#梯度下降介绍" class="headerlink" title="梯度下降介绍"></a>梯度下降介绍</h4><ul><li><p>梯度下降法的优化思想是用当前位置<strong>负梯度</strong>方向作为搜索方向，该方向为当前位置最快下降方向，梯度下降中越接近目标值，变化量越小，公式如下:$$w_{k+1}&#x3D;w_k-\eta\nabla f_{w_k}(x^i)$$</p></li><li><p>其中$\eta$成为学习率，$i$表示第$i$条数据。权重参数$w$每次迭代变化的大小。</p></li><li><p><strong>收敛</strong>：目标函数的值变化非常小或达到最大迭代次数。</p><div align="center"><img src="/2024/03/13/machine-learning/31.png" width="70%/"></div></li><li><p>存在的问题：梯度下降法容易陷入一个局部最低点，而不是全局最低点</p></li><li></li></ul><h4 id="常见梯度下降法"><a href="#常见梯度下降法" class="headerlink" title="常见梯度下降法"></a>常见梯度下降法</h4><ul><li><p><strong>批量梯度下降(BGD)</strong> ：使用<strong>所有</strong>数据集中的样本（共m个样本）在当前点的度之和来对权重参数进行更新操作。$$w_{k+1}&#x3D;w_k-\eta \frac{1}{m}\sum^m_{i&#x3D;1} \nabla f_{w_k}x^i$$</p></li><li><p><strong>随机梯度下降(SGD)</strong> ：随机选取<strong>一个</strong>数据集中的样本在当前的梯度来对权重参数进行更新操作。$$w_{k+1}&#x3D;w_k-\eta\nabla f_{w_k}x^i$$</p></li><li><p><strong>小批量梯度下降(MBGD)</strong> ：结合BGD与SGD的特性，每次选择数据集中 <strong>n个</strong>样本的梯度来对权重参数进行更新操作。$Batch$为其重要的超参数，规定选择样本的数量。 $$w_{k+1}&#x3D;w_k-\eta \frac{1}{n}\sum_{i&#x3D;t} ^{t+n-1} \nabla f_{w_k}x^i$$</p></li><li><p>三种梯度下降法的比较</p><ul><li>SGD中，因为每次训练选取的样本是随机的，这本身就带来了<strong>不稳定性</strong>，会导致损失函数在下降到最低点的过程中，产生动荡甚至反向的位移。</li><li>BGD最稳定，但是<strong>过于消耗运算资源</strong>，MBGD是SGD与BGD平衡之后的方法。<br><img src="/2024/03/13/machine-learning/32.png"></li></ul></li></ul><h3 id="模型中的参数与超参数"><a href="#模型中的参数与超参数" class="headerlink" title="模型中的参数与超参数"></a>模型中的参数与超参数</h3><ul><li>模型中不但有参数，还有超参数的存在。其目的是为了让模型能够学习到最佳的参数<ul><li><strong>参数</strong>有模型<strong>自动学习</strong></li><li><strong>超参数</strong>由<strong>人工手动设定</strong><div align="left"><img src="/2024/03/13/machine-learning/33.png" width="60%/"></div></li></ul></li></ul><h3 id="模型的超参数"><a href="#模型的超参数" class="headerlink" title="模型的超参数"></a>模型的超参数</h3><h4 id="模型的超参数是模型外部的配置"><a href="#模型的超参数是模型外部的配置" class="headerlink" title="模型的超参数是模型外部的配置"></a>模型的超参数是模型外部的配置</h4><ul><li>模型超参数常应用于估计模型参数的过程中。</li><li>模型超参数通常由实践者直接指定。模型超参数通常可以使用启发式方法来设置。</li><li>模型超参数通常根据给定的预测建模问题而调整。</li></ul><h4 id="常见的模型超参数"><a href="#常见的模型超参数" class="headerlink" title="常见的模型超参数"></a>常见的模型超参数</h4><ul><li>Lasso&#x2F;Ridge回归当中的 $\lambda$</li><li>训练神经网络的学习速率，迭代次数，批次大小，激活函数，神经元的数量。</li><li>支持向量机的 $C$ 和 $\sigma$ 超参数。</li><li>KNN中的 $K$。</li><li>随机森林当中的树的棵数</li></ul><h4 id="超参数的搜索过程及方法"><a href="#超参数的搜索过程及方法" class="headerlink" title="超参数的搜索过程及方法"></a>超参数的搜索过程及方法</h4><p><img src="/2024/03/13/machine-learning/34.png"></p><h4 id="超参数的调节方法-网格搜索"><a href="#超参数的调节方法-网格搜索" class="headerlink" title="超参数的调节方法 - 网格搜索"></a>超参数的调节方法 - 网格搜索</h4><ul><li><p>网格搜索尝试穷举搜索所有可能的超参数组合形成超参数值网格。</p></li><li><p>在实践中，人工指定的范围和步骤之间的值。</p> <div align="center"><img src="/2024/03/13/machine-learning/35.png" width="50%/"></div> </li><li><p>网格搜索是一种<strong>昂贵且耗时</strong>的方法。</p><ul><li>这种方法在超参数数目相对较少的情况下工作良好。因此一般机器学习算法中可行，但在神经网络等情况下就行不通了（见深度学习部分）。</li></ul></li></ul><h4 id="超参数的调节方法-随机搜索"><a href="#超参数的调节方法-随机搜索" class="headerlink" title="超参数的调节方法 - 随机搜索"></a>超参数的调节方法 - 随机搜索</h4><ul><li>在超参数搜索空间较大的情况下，采用随机搜索，会优于网格搜索的效果</li><li>随机搜索实现了对超参数的随机搜索，其中每个设置都是从可能的参数值的分布中进行取样，试图找出最佳的超参数子集</li><li>注意:<ul><li>首先在一个粗范围内搜索，然后根据最佳结果出现的位置，缩小范围。</li><li>某些超参数比其他的更加重要，随机搜索过程中会影响搜索的偏向。 <div align="center"><img src="/2024/03/13/machine-learning/36.png" width="50%/"></div></li></ul></li></ul><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><ul><li><strong>交叉验证</strong>：是用来验证分类器的性能一种统计分析方法，基本思想是把在某种意义下将原始数据进行分组，一部分作为<strong>训练集</strong>，另一部分作为<strong>验证集</strong>，首先用训练集对分类器进行训练，再利用验证集来测试训练得到的模型，以此来做为评价分类器的性能指标。<strong>用于调节超参数</strong>。</li><li>$k$-折交叉验证 ( $K -  CV$ ) :<ul><li>将原始数据分成k组(一般是均分)。</li><li>将每个子集数据分别做一次验证集，其余的$k –1$组子集数据作为训练集，这样会得到$k$个模型。</li><li>用这$k$个模型最终的验证集的分类准确率的平均数作为此 $K -CV$ 下分类器的性能指标。 <div align="center"><img src="/2024/03/13/machine-learning/37.png" width="90%/"></div></li></ul></li></ul><hr><h2 id="机器学习常见算法"><a href="#机器学习常见算法" class="headerlink" title="机器学习常见算法"></a>机器学习常见算法</h2><h3 id="机器学习算法总览"><a href="#机器学习算法总览" class="headerlink" title="机器学习算法总览"></a>机器学习算法总览</h3> <div align="center"><img src="/2024/03/13/machine-learning/38.png"></div> <h3 id="有监督学习-线性回归"><a href="#有监督学习-线性回归" class="headerlink" title="有监督学习 - 线性回归"></a>有监督学习 - 线性回归</h3><h4 id="基础线性回归"><a href="#基础线性回归" class="headerlink" title="基础线性回归"></a>基础线性回归</h4><ul><li><p>**线性回归( Linear regression )**：线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。</p></li><li><p>线性回归是一种<strong>有监督学习</strong>。</p> <div align="center"><img src="/2024/03/13/machine-learning/39.png"></div> </li><li><p>线性回归的<strong>模型函数</strong>如下。其中$w$为权重参数，$b$为偏置，$x$表示样本。<br>$$h_w(x)&#x3D;w^tx+b$$</p></li><li><p><strong>模型预测与真实值的关系</strong>如下。其中$y$表示真实值，$\varepsilon$表示误差。<br>$$y&#x3D;w^tx+\varepsilon$$</p></li><li><p>误差$\varepsilon$受到众多因素独立影响，根据中心极限定律，误差$\varepsilon$服从正态分布。根据正态分布函数与最大似然估计，可以求出线性回归的<strong>损失函数</strong>为:<br>$$J(w)&#x3D;\frac{1}{2m}\sum (h_w(x)-y)^2$$</p></li><li><p>我们想要预测值与真实值最接近，就是求损失值最小。可以使用梯度下降的方法求出当损失函数达到最小的时候的权重参数$w$，继而完成模型构建。</p></li></ul><h4 id="线性回归扩展-多项式回归"><a href="#线性回归扩展-多项式回归" class="headerlink" title="线性回归扩展 - 多项式回归"></a>线性回归扩展 - 多项式回归</h4><ul><li>多项式回归，是线性回归的拓展，通常数据集的复杂度会超过用一条直线来拟合的可能性，也就是使用原始的线性回归模型会明显欠拟合。解决的办法就是使用多项式回归。$$h_w(x)&#x3D;w_1x+w_2x^2+L+w_nx^n+b，L表示中间多个式子$$</li><li>这里的n次方就是多项式回归维度(degree)</li><li>多项式回归仍然是线性回归的一种，是因为其<strong>非线性</strong>体现在<strong>特征的维度</strong>上，而其权重参数w之间的关系仍然是<strong>线性的</strong>。 <div align="center"><img src="/2024/03/13/machine-learning/40.png" width="60%/"></div></li></ul><h4 id="线性回归与防止过拟合"><a href="#线性回归与防止过拟合" class="headerlink" title="线性回归与防止过拟合"></a>线性回归与防止过拟合</h4><ul><li>正则项有助于减少过拟合，$w$值在样本空间中不能过大&#x2F;过小，可以在目标函数之上增加一个<strong>平方和损失</strong></li><li><strong>正则项(norm)<strong>︰这里这个正则项叫做</strong>L2-norm</strong>，这个使用这个损失函数的，线性回归也叫<strong>Ridge回归</strong>。<br> $$J(w)&#x3D;\frac{1}{2}\sum (h_w(x)-y)^2+\lambda\sum w^2$$</li><li>追加了绝对值损失的线性回归叫做<strong>Lasso回归</strong>。<br>$$J(w)&#x3D;\frac{1}{2}\sum (h_w(x)-y)^2+\lambda\sum |w|$$</li></ul><h3 id="有监督学习-逻辑回归"><a href="#有监督学习-逻辑回归" class="headerlink" title="有监督学习 - 逻辑回归"></a>有监督学习 - 逻辑回归</h3><h4 id="基础逻辑回归"><a href="#基础逻辑回归" class="headerlink" title="基础逻辑回归"></a>基础逻辑回归</h4><ul><li><p><strong>逻辑回归</strong>：逻辑回归模型是一种<strong>分类模型</strong>，用来解决分类问题。模型的定义:$$P(Y&#x3D;1|X)&#x3D;\frac{e^{wx}+b}{1+e^{wx}+b}$$ $$P(Y&#x3D;0|X)&#x3D;\frac{1}{1+e^{wx}+b}$$<br> 其中 $w$ 称为权重，$b$ 称为偏置，其中的 $wx+ b$ 看成对 $x$ 的线性函数。然后对比上面两个概率值，概率值大的就是 $x$ 对应的类。</p> <div align="center"><img src="/2024/03/13/machine-learning/41.png" width="60%/"></div> </li><li><p>逻辑回归与线性回归都是广义线性模型。逻辑回归在线性回归的基础上引入了非线性因素(<strong>Sigmoid函数</strong>)，并设定了阈值，因此可以处理二分类问题。</p></li><li><p>根据逻辑回归的模型函数，可以通过<strong>最大似然估计</strong>计算出逻辑回归的<strong>损失函数</strong>为:<br>$$J(w)&#x3D;\frac{1}{m}\sum \big(y\log h_w(x)+(1-y)\log (1-h_w(x))\big)$$<br>其中 $w$ 为权重参数， $m$ 为样本个数，$x$ 表示样本，$y$ 表示真实值。同样可以通过梯度下降算法求得所有权重参数w的值。</p></li></ul><h4 id="逻辑回归扩展-Softmax函数"><a href="#逻辑回归扩展-Softmax函数" class="headerlink" title="逻辑回归扩展 - Softmax函数"></a>逻辑回归扩展 - Softmax函数</h4><ul><li><p>逻辑回归只能用于二分类问题，如果是多分类问题，我们通常使用<strong>Softmax函数</strong>。</p> <div align="center"><img src="/2024/03/13/machine-learning/42.png" width="90%/"></div> </li><li><p>Softmax回归是逻辑回归的一般化，适用于<strong>K分类</strong>的问题。</p></li><li><p>Softmax函数的本质就是将一个K维的任意实数向量压缩（映射）成另一个K维的实数向量，其中向量中的每个元素取值都介于$(0，1)$之间。</p></li><li><p><strong>Softmax回归概率函数</strong>为:$$p(y&#x3D;k|x,w)&#x3D;\frac{e^{w_k^Tx}}{\sum^K_{l&#x3D;1} e^{w^T_lx}}，k&#x3D;1,2…K$$</p></li><li><p>Softmax为多类问题中的每个分类分配了概率值。这些概率加起来等于1。  </p><ul><li>Softmax可能产生一个属于特定类别的形式可能以如下方式展示: <div align="center"><img src="/2024/03/13/machine-learning/43.png" width="90%/"></div></li></ul></li></ul><h3 id="有监督学习-决策树"><a href="#有监督学习-决策树" class="headerlink" title="有监督学习 - 决策树"></a>有监督学习 - 决策树</h3><h4 id="决策树介绍"><a href="#决策树介绍" class="headerlink" title="决策树介绍"></a>决策树介绍</h4><ul><li><p><strong>决策树</strong>：决策树( decision tree )是一个树结构（可以是二叉树或非二叉树)。其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。使用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，开按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p> <div align="center"><img src="/2024/03/13/machine-learning/44.png" width="90%/"></div> </li><li><p><strong>决策树结构</strong>：</p> <div align="center"><img src="/2024/03/13/machine-learning/45.png" width="90%/"></div></li></ul><h4 id="决策树的构建关键点"><a href="#决策树的构建关键点" class="headerlink" title="决策树的构建关键点"></a>决策树的构建关键点</h4><ul><li>决策树的构造就是进行属性的选择，确定各个特征属性之间的树结构。构建决策树的关键步骤就是按照所有的特征属性进行划分操作，对所有的划分操作的结果集的“纯度”进行比较，选择“纯度”最高的属性作为分割数据集的数据点。</li><li>纯度的量化指标主要通过<strong>信息嫡</strong>与<strong>GINI系数</strong>，公式如下：<br>$$H(X)&#x3D;-\sum^K_{k&#x3D;1}p_k\log (p_k)$$<br>$$Gini&#x3D;1-\sum^K_{k&#x3D;1}p_k^2$$</li><li>其中 $p_k$ 表示样本属于类别 $k$ 的概率(共有$K$个类别)，<font color="red">分割前与分割后的纯度差异越大，决策树越好</font>。</li><li>常见的决策树算法有ID3，C4.5，CART等。</li></ul><h4 id="决策树的构建过程"><a href="#决策树的构建过程" class="headerlink" title="决策树的构建过程"></a>决策树的构建过程</h4><ul><li><strong>特征选择</strong>：从训练数据的特征中选择一个特征作为当前节点的分裂标准（特征选择的标准不同产生了不同的特征决策树算法）。</li><li><strong>决策树生成</strong>：根据所选特征评估标准，从上至下递归地生成子节点，直到数据集不可分则停止决策树停止生长。</li><li><strong>剪枝</strong>：决策树容易过拟合，需要剪枝来缩小树的结构和规模（包括预剪枝和后剪枝）。<ul><li>预剪枝：生成节点前剪</li><li>后剪枝：生成节点后剪</li></ul></li></ul><h4 id="决策树案例"><a href="#决策树案例" class="headerlink" title="决策树案例"></a>决策树案例</h4><ul><li>下图案例向我们展示了一个决策树进行的分类问题，分类结果受到三个属性的影响分别是Refund, Marital status,Taxable Income。 <div align="center"><img src="/2024/03/13/machine-learning/46.png" width="100%/"></div></li></ul><h3 id="有监督学习-支持向量机"><a href="#有监督学习-支持向量机" class="headerlink" title="有监督学习 - 支持向量机"></a>有监督学习 - 支持向量机</h3><h4 id="支持向量机基础"><a href="#支持向量机基础" class="headerlink" title="支持向量机基础"></a>支持向量机基础</h4><ul><li><strong>支持向量机</strong>( support vector machine，<strong>SVM</strong> )是一种<strong>二分类模型</strong>，它的基本模型是定义在特征空间上的<strong>间隔最大</strong>的线性分类器。SVM还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习算法是求解凸二次规划的最优化算法。 <div align="center"><img src="/2024/03/13/machine-learning/49.png" width="100%/"></div></li></ul><h4 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h4><ul><li><p>如何使用一条线直接分割下面的红蓝数据集？</p> <div align="center"><img src="/2024/03/13/machine-learning/50.png" width="100%/"></div> </li><li><p>直线被用来将数据分割到不同类别中，而实际上我们可以多条直线将数据分来。SVM的核心思路是找到一个直线，使离直线比较近的点，尽可能远离这条直线，这可以使模型具有很强的泛化能力。而这些点就被称为<strong>支持向量(Support Vector)</strong></p></li><li><p>在二维空间中，我们用<strong>直线</strong>来分割，如果是高维空间，我们使用<strong>超平面</strong>来分割。</p> <div align="center"><img src="/2024/03/13/machine-learning/51.png" width="900%/"></div></li></ul><h4 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h4><ul><li><p>如何分类一种非线性可分的数据集？</p> <div align="center"><img src="/2024/03/13/machine-learning/52.png" width="80%/"></div> </li><li><p>使用<strong>核函数</strong>来构建<strong>非线性支持向量机</strong>。</p></li><li><p>核函数允许算法在变换后的高维特征空间中拟合最大的超平面。</p> <div align="center"><img src="/2024/03/13/machine-learning/53.png" width="90%/"></div> </li><li><p><strong>高斯核函数</strong>应用范围最广，应用场景也最多</p></li></ul><h3 id="有监督学习-K最邻近算法"><a href="#有监督学习-K最邻近算法" class="headerlink" title="有监督学习 - K最邻近算法"></a>有监督学习 - K最邻近算法</h3><ul><li><p><strong>K最近邻</strong>(k-Nearest Neighbor，<strong>KNN</strong>)<strong>分类算法</strong>，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p> <div align="center"><img src="/2024/03/13/machine-learning/54.png" width="50%/"></div> </li><li><p>KNN的核心思想是“近朱者赤，近墨者黑”，其在逻辑上十分的简洁。</p></li><li><p>KNN是非参数方法，常用在决策边界非常不规则的数据集中使用。</p><ul><li>KNN在<strong>分类预测</strong>时，一般采用<strong>多数表决法</strong>；KNN在做<strong>回归预测</strong>时，一般采用<strong>平均值法</strong>。</li></ul></li><li><p>KNN的需要非常大的计算量。</p><div align="center"><img src="/2024/03/13/machine-learning/55.png" width="60%/"></div> </li><li><p>一般来说，较大的k值会降低噪声对分类的影响，但会使类之间的边界不那么明显 </p><ul><li><strong>K值越大</strong>越容易<strong>欠拟合</strong>，因为分割过于粗糙，<strong>越小</strong>越容易<strong>过拟合</strong>，因为分割过于细腻。<div align="center"><img src="/2024/03/13/machine-learning/56.png" width="60%/"></div></li></ul></li><li><p>可以发现你会发现随着K值的增加，边界会变得更平滑。</p></li><li><p>随着k值的增加到无穷大，最终会变成全蓝或全红</p></li></ul><h3 id="有监督学习-朴素贝叶斯"><a href="#有监督学习-朴素贝叶斯" class="headerlink" title="有监督学习 - 朴素贝叶斯"></a>有监督学习 - 朴素贝叶斯</h3><ul><li><strong>朴素贝叶斯算法</strong>(Naive Bayes )︰朴素贝叶斯是一种简单的<strong>多类分类算法</strong>，基于贝叶斯定理，并假设特征之间是独立的。给定样本特征 $X$，样本属于类别$H$的概率是:$$P(C_k|X_1,…,X_n)&#x3D;\frac{P(X_1,…,X_n|C_k)P(C_k)}{P(X_1,…,X_n)}$$<ul><li>$X_1,…,X_n$ 是数据的特征，通常用 $m$ 个属性集的测量值描述，<ul><li>比如说颜色特征可能有红，黄和蓝三个属性。</li></ul></li><li>$C_k$ 表示该数据属于某个特定类 $C$。</li><li>$P(C_k|X_1,…,X_n)$ 是后验概率，或在条件c下，H的后验概率</li><li>$P(C_k)$ 是先验概率，$P(C_k)$ 独立于$X_1,…,X_n$</li><li>$P(X_1,…,X_n)$ 是x的先验概率。</li></ul></li><li>特征独立假设。<ul><li>例如，如果一个水果是红色的，圆圆的，直径大约10厘米，就可以被认为是苹果。</li><li>一个朴素贝叶斯分类器认为这些特征中的每一个都独立地贡献了这个水果是一个苹果的概率，而不考虑颜色、圆度和直径特征之间的任何可能的相关性。</li></ul></li></ul><h3 id="有监督学习-集成算法"><a href="#有监督学习-集成算法" class="headerlink" title="有监督学习 - 集成算法"></a>有监督学习 - 集成算法</h3><h4 id="集成算法基础"><a href="#集成算法基础" class="headerlink" title="集成算法基础"></a>集成算法基础</h4><ul><li><strong>集成学习</strong>是一种机器学习范式，在这种范式中，多个学习者被训练和组合以解决同一个问题。通过使用多个学习者，集成的泛化能力可以比单个学习者强得多。</li><li>如果随机向数千人提出一个复杂的问题，然后汇总他们的答案。在许多情况下，会发现这个汇总的答案比专家的答案更好。这就是群众智慧。<div align="center"><img src="/2024/03/13/machine-learning/57.png" width="60%/"></div></li></ul><h4 id="集成算法分类"><a href="#集成算法分类" class="headerlink" title="集成算法分类"></a>集成算法分类</h4><div align="center"><img src="/2024/03/13/machine-learning/58.png"></div> <h4 id="集成算法-随机森林"><a href="#集成算法-随机森林" class="headerlink" title="集成算法 - 随机森林"></a>集成算法 - 随机森林</h4><ul><li><strong>随机森林(Random Forest)</strong> &#x3D; Bagging + CART决策树。</li><li>随机森林建立多个决策树，并将它们合并在一起，以获得更准确和稳定的预测。<ul><li>随机森林可以用于分类和回归问题。<div align="center"><img src="/2024/03/13/machine-learning/59.png"></div></li></ul></li></ul><h4 id="集成算法-GBDT"><a href="#集成算法-GBDT" class="headerlink" title="集成算法 - GBDT"></a>集成算法 - GBDT</h4><ul><li><strong>GBDT</strong>是Boosting算法的一种。</li><li>综合模型的结果是所有基础学习器的结果相加等于预测值，其本质是下一个基础学习器去<strong>拟合误差函数对预测值的残差</strong>(这个残差就是预测值与真实值之间的误差)。</li><li>GBDT在模型训练的时候，是要求模型预测的样本损失尽可能的小。<div align="center"><img src="/2024/03/13/machine-learning/60.png" width="70%/"></div></li></ul><h3 id="无监督学习-K-means"><a href="#无监督学习-K-means" class="headerlink" title="无监督学习 - K-means"></a>无监督学习 - K-means</h3><ul><li>K-means算法是输入聚类个数k，以及包含n个数据对象的数据集，输出满足方差最小的标准的k个聚类的一种算法。</li><li>K-means算法需要输入聚类的最终个数k ，然后将n个数据对象划分为k个聚类，而最终所获得的聚类满足:<ol><li>同一聚类中的对象相似度较高;</li><li>而不同聚类中的对象相似度较小。 <div align="center"><img src="/2024/03/13/machine-learning/47.png" width="100%/"></div></li></ol></li></ul><h3 id="无监督学习-层次聚类"><a href="#无监督学习-层次聚类" class="headerlink" title="无监督学习 - 层次聚类"></a>无监督学习 - 层次聚类</h3><ul><li>层次聚类法试图在不同层次对数据集进行划分，从而形成树形的聚类结构，数据集的划分可采用“自下向上”的聚合策略，也可以采用“自顶向下”的分拆策略。聚类的层次被表示成树形图。树根拥有所有样本的唯一聚类，叶子是仅有一个样本的聚类。 <div align="center"><img src="/2024/03/13/machine-learning/48.png" width="100%/"></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理笔记</title>
      <link href="/2024/03/10/digital-image-processing/"/>
      <url>/2024/03/10/digital-image-processing/</url>
      
        <content type="html"><![CDATA[<h1 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h1><hr><h2 id="数学图像基础"><a href="#数学图像基础" class="headerlink" title="数学图像基础"></a>数学图像基础</h2><h3 id="图像处理技术的分类"><a href="#图像处理技术的分类" class="headerlink" title="图像处理技术的分类"></a>图像处理技术的分类</h3><h4 id="1-模拟图像处理"><a href="#1-模拟图像处理" class="headerlink" title="1. 模拟图像处理"></a>1. 模拟图像处理</h4><p>光学处理和电子处理：照相、遥感图像处理、电视信号处理<br>优点：速度快（一般为实时处理，理论上讲可达到光的速度，并可同时并行处理）。<br>缺点：精度较差，灵活性差，很难有判断能力和非线性处理能力。</p><h4 id="2-数字图像处理"><a href="#2-数字图像处理" class="headerlink" title="2. 数字图像处理"></a>2. 数字图像处理</h4><p>数字图像处理用计算机处理，亦称计算机图像处理<br>优点：精度高，内容丰富，可进行复杂的非线性处理，灵活的变通能力，仅改变软件就可以改变处理内容。<br>缺点：处理速度问题（复杂处理过程更甚）。实时处理一般精度的数字图像需100Mips的处理能力；分辨率及精度限制</p><h3 id="数字图像处理的特点"><a href="#数字图像处理的特点" class="headerlink" title="数字图像处理的特点"></a>数字图像处理的特点</h3><ol><li>图像信息量大、数据量也大；</li><li>图像处理技术综合性强；</li><li>图像信息理论与通信理论密切相关。</li></ol><h3 id="图像取样和量化"><a href="#图像取样和量化" class="headerlink" title="图像取样和量化"></a>图像取样和量化</h3><h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><p>将在空间上连续的图像转换成离散的采样点（即像素）集的操作。<br>由于图像是二维分布的信息，所以采样是在 x轴和y轴两个方向上进行一般情况下， x轴方向与y轴方向的采样间隔相同。</p><h4 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h4><p>量化是将各个像素所含的明暗信息离散化后，用数字来表示。一般的量化值为整数。充分考虑到人眼的识别能力之后，目前非特殊用途的图像均为8bit量化，即用[0,255]描述“从黑到白”。<br>① 均匀量化：是简单地在灰度范围内等间隔量化。<br>② 非均匀量化：是对像素出现频度少的部分量化间隔取大，而对频度大的量化间隔取小。</p><h4 id="分辨率（空间、幅度）"><a href="#分辨率（空间、幅度）" class="headerlink" title="分辨率（空间、幅度）"></a>分辨率（空间、幅度）</h4><p>映射到图像平面上的单个像素的景物元素的尺寸。单位：像素&#x2F;厘米；或者是指要精确测量和再现一定尺寸的图像所必需的像素个数。单位：像素*像素</p><h4 id="采样、量化和分辨率之间的联系"><a href="#采样、量化和分辨率之间的联系" class="headerlink" title="采样、量化和分辨率之间的联系"></a>采样、量化和分辨率之间的联系</h4><p>① 采样频率决定分辨率<br>② 量化强度决定了每个象素可以取的值集合</p><h3 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h3><h4 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h4><h5 id="4邻域"><a href="#4邻域" class="headerlink" title="4邻域"></a>4邻域</h5><p>用 $N_4(p)$ 表示像素 $p$ 的4邻域<br><img src="/2024/03/10/digital-image-processing/1.png"></p><h5 id="D邻域"><a href="#D邻域" class="headerlink" title="D邻域"></a>D邻域</h5><p>用 $N_D(p)$ 表示像素 $p$ 的对角邻域，像素 $p(x,y)$ 的Dd邻域为其对角上像素<br><img src="/2024/03/10/digital-image-processing/2.png"></p><h5 id="8邻域"><a href="#8邻域" class="headerlink" title="8邻域"></a>8邻域</h5><p>用 $N_8(p)$ 表示像素 $p$ 的8邻域： $N_8(p) &#x3D; N_4(p)∪N_D(p)$<br><img src="/2024/03/10/digital-image-processing/3.png"></p><h4 id="邻接性"><a href="#邻接性" class="headerlink" title="邻接性"></a>邻接性</h4><p>令V是具有特定<strong>相似性准则</strong>的灰度值集合</p><h5 id="4邻接"><a href="#4邻接" class="headerlink" title="4邻接"></a>4邻接</h5><p>对于具有值 $V$ 的像素 $p$ 和 $q$ ，如果 $q$ 在集合 $N_4(p)$ 中，则称这两个像素是4邻接的<br><img src="/2024/03/10/digital-image-processing/4.png"></p><h5 id="8邻接"><a href="#8邻接" class="headerlink" title="8邻接"></a>8邻接</h5><p>对于具有值 $V$ 的像素 $p$ 和 $q$ ，如果 $q$ 在集合 $N_8(p)$ 中，则称这两个像素是8邻接的<br><img src="/2024/03/10/digital-image-processing/5.png"></p><h5 id="m邻接"><a href="#m邻接" class="headerlink" title="m邻接"></a>m邻接</h5><p>对于具有值 $V$ 的像素 $p$ 和 $q$ ，如果:<br>I.  $q$ 在集合 $N_4(p)$ 中，或<br>II.  $q$ 在集合 $N_D(p)$ 中，并且 $N_4(p)$ 与 $N_D(p)$ 的交集没有值V的像素<br>则称这两个像素是m邻接的，即4邻接和D邻接的混合邻接。<br><img src="/2024/03/10/digital-image-processing/6.png"></p><h4 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h4><h5 id="通路的定义"><a href="#通路的定义" class="headerlink" title="通路的定义"></a>通路的定义</h5><p>从具有坐标 $(x,y)$的像素 $p$,到具有坐标 $(s,t)$ 的像素 $q$ 的一条通路由一系列具有坐标 $(x_0,y_0)$，$(x_1,y_1)$，…，$(x_n,y_n)$的独立像素组成。其中，$(x_0,y_0) &#x3D; (x,y)$，$(x_n,y_n) &#x3D; (s,t)$，且$(x_i,_i)$  和 $(xi-1,yi-1)$ 是邻接的，$1≤i≤n$，$n$ 是路径的长度。如果 $(x0,y0) &#x3D; (x_n,y_n)$ ,则该通路是闭合通路。</p><h5 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h5><p>$S$ 是图像中的一个子集,对 $S$ 中任何一个像素 $p$，连通到该像素的像素集称为 $S$ 的连通分量。如果 $S$ 仅有一个连通分量，则称为<strong>连通集</strong>，也称作一个<strong>区域</strong>。</p><h5 id="邻接区域"><a href="#邻接区域" class="headerlink" title="邻接区域"></a>邻接区域</h5><p>两个区域联合起来形成一个连通集。<br>不连接区域：非邻接区域。</p><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>一幅图像的K个不连接区域的并集的补集。</p><h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><p>一个区域的边界，是该区域中至少有一个背景邻接点的像素的集合。</p><h4 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h4><h5 id="欧式-Euclidean-距离定义：模为2的距离"><a href="#欧式-Euclidean-距离定义：模为2的距离" class="headerlink" title="欧式(Euclidean)距离定义：模为2的距离"></a>欧式(Euclidean)距离定义：模为2的距离</h5><ul><li>像素$p(x,y)$和$(s,t)$间的欧式距离定义如下：<br>$D_e(p,q) &#x3D; \sqrt{(x-s)^2+(y-t)^2}$</li><li>对于这个距离计算法，具有与$(x,y)$距离小于等于某个值$r$的像素是：包含在以$(x,y)$为圆心，以$r$为半径的圆平面</li></ul><h5 id="城区-city-block-距离：模为1的距离或-𝐷-4-距离"><a href="#城区-city-block-距离：模为1的距离或-𝐷-4-距离" class="headerlink" title="城区(city-block)距离：模为1的距离或$𝐷_4$距离"></a>城区(city-block)距离：模为1的距离或$𝐷_4$距离</h5><ul><li>像素$p(x,y)$和$q(s,t)$之间的$D_4$距离定义为：<br>$D_4(x,y) &#x3D; \lvert x-s\rvert + \lvert y-t\rvert$</li></ul><p><strong>例</strong>：</p><ul><li>具有与$(x,y)$距离小于等于某个值r的那些像素形成一个菱形</li><li>例如，与点$(x,y)$（中心点）$D_4$距离小于等于2的像素，形成右边固定距离的轮廓</li><li>具有$D_4 &#x3D; 1$的像素是$(x,y)$的4邻域<br><img src="/2024/03/10/digital-image-processing/7.png"></li></ul><h5 id="棋盘-chessboard-距离：模为-infty-的距离或-𝐷-8-距离"><a href="#棋盘-chessboard-距离：模为-infty-的距离或-𝐷-8-距离" class="headerlink" title="棋盘(chessboard)距离：模为$\infty$的距离或$𝐷_8$距离"></a>棋盘(chessboard)距离：模为$\infty$的距离或$𝐷_8$距离</h5><ul><li>像素$p(x,y)$和$q(s,t)$之间的$D_8$距离定义为：<br>$D_8(x,y) &#x3D; max(\lvert x-s\rvert + \lvert y-t\rvert)$</li></ul><p><strong>例</strong>：</p><ul><li>具有与$(x,y)$距离小于等于某个值r的那些像素形成一个正方形</li><li>例如，与点$(x,y)$（中心点）$D_8$距离小于等于2的像素，形成右边固定距离的轮廓</li><li>具有$D_8 &#x3D; 1$的像素是$(x,y)$的4邻域<br><img src="/2024/03/10/digital-image-processing/8.png"></li></ul><hr><h2 id="灰度变化与空间滤波"><a href="#灰度变化与空间滤波" class="headerlink" title="灰度变化与空间滤波"></a>灰度变化与空间滤波</h2><h3 id="基本灰度变换"><a href="#基本灰度变换" class="headerlink" title="基本灰度变换"></a>基本灰度变换</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><ul><li>空间域指包含图像像素的平面，灰度变换与空间滤波均在空间域进行，即直接在图像像素上操作，表示为 $g(x,y)&#x3D;T[f(x,y)]$ ，其中 $T$ 是在点 $(x, y)$ 的邻域上定义的关于 $f$ 的一种算子<ul><li>如空间滤波：邻域与预定义的操作共称为空间滤波器（也称为空间掩膜、核、模版或窗口）  </li><li>空间滤波的最小邻域为 $1\times1$ ，此时 $T$ 成为灰度变换函数：$s&#x3D;T(r)$ ，可以起到对比度拉伸或阈值处理的作用</li></ul></li><li>图像增强应用<ul><li>增强是指对图像进行加工，使其结果对于<strong>特定</strong>的应用比原始图像更适合的一种处理</li></ul></li></ul><h4 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h4><ul><li>灰度变换函数：$s&#x3D;T(r)$ <ul><li>$r$ 为数字量且取值有限，该映射可通过查找表实现<br><img src="/2024/03/10/digital-image-processing/9.png"></li></ul></li></ul><h4 id="图像反转"><a href="#图像反转" class="headerlink" title="图像反转"></a>图像反转</h4><ul><li>灰度变换函数：$s&#x3D;L-1-r$<ul><li>适用于增强嵌入在一幅图像的暗区域中的白色或灰色细节，特别当黑色面积在尺寸上站主导地位时<br><img src="/2024/03/10/digital-image-processing/10.png"></li></ul></li></ul><h4 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h4><ul><li>灰度变换函数：$s&#x3D;clog(1+r)$</li><li>该变换将输入中范围较窄的低灰度值映射为输出中较宽范围的灰度值；对高的输入灰度值起相反作用</li><li>使用对数变换来扩展图像中暗像素的值，同时压缩更高灰度级的值</li><li>反对数变换与对数变换相反</li><li>对数变换可以压缩像素值变化较大的图像的动态范围，比如傅立叶频谱。傅立叶频谱的范围一般在 $0\sim10^6$ ，通过对数变换后可以显示图像中丰富的细节<br><img src="/2024/03/10/digital-image-processing/11.png"></li></ul><h4 id="幂律（伽马）变换"><a href="#幂律（伽马）变换" class="headerlink" title="幂律（伽马）变换"></a>幂律（伽马）变换</h4><ul><li>灰度变换函数：$s&#x3D;cr^\gamma$<br><img src="/2024/03/10/digital-image-processing/12.png"></li><li>随着 $\gamma$ 的变化，得到一族可能的变换曲线（分界点为 $\gamma &#x3D; 1$ ，此时简化成了恒等变换）</li><li>用于图像获取、显示、打印的各种设备常根据幂律来产生相应，因此应用<strong>伽马矫正</strong>来矫正这些幂律响应现象</li><li>幂律变换同样可用于调整图像的对比度：当 $\gamma\lt1$ 时，减小对比度；当 $\gamma\gt1$ 时，增加对比度<br><img src="/2024/03/10/digital-image-processing/13.png"></li></ul><h4 id="分段线性变换函数"><a href="#分段线性变换函数" class="headerlink" title="分段线性变换函数"></a>分段线性变换函数</h4><ul><li><p>对比度拉伸：一般函数是单值且单调递增的，保持了灰度级的次序（包括了阈值处理函数）<br><img src="/2024/03/10/digital-image-processing/14.png"></p></li><li><p>灰度级分层：用于突出图像特定灰度范围的亮度<br><img src="/2024/03/10/digital-image-processing/15.png"></p><ul><li>一种方法将感兴趣范围内所有灰度显示为一个值，将其他灰度值显示为另一个值</li><li>另一种方法使感兴趣范围的灰度变亮（或变暗），而保持图像中的其他灰度级不变</li></ul></li><li><p><strong>比特平面分层</strong>：将 256 级灰度图像分成 8 个 1 比特平面来表示，通过阈值灰度变换函数处理来得到对应平面的二值图像<br><img src="/2024/03/10/digital-image-processing/16.png"><br><img src="/2024/03/10/digital-image-processing/17.png"></p></li><li><p>可用于图像压缩：通过特定几个平面来恢复图像</p></li></ul><h3 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h3><h4 id="直方图定义"><a href="#直方图定义" class="headerlink" title="直方图定义"></a>直方图定义</h4><p>  $p(r_k)&#x3D;\frac{n_k}{MN}$ （类比概率）</p><h4 id="直方图均衡"><a href="#直方图均衡" class="headerlink" title="直方图均衡"></a>直方图均衡</h4><ul><li>灰度映射：$s&#x3D;T(r)$<ul><li>$T(r)$ 在区间 $0\leq r\leq L-1$ 上为（严格）单调递增函数</li><li>当 $0\leq r\leq L-1$ 时，$0\leq T(r)\leq L-1$</li></ul></li><li>重要变换函数：$s&#x3D;T(r)&#x3D;(L-1)\int^r_0p_r(w)dw$</li><li>离散形式：$s_k&#x3D;T(r_k)&#x3D;(L-1)\sum^k_{j&#x3D;0}p_r(r_j)&#x3D;\frac{(L-1)}{MN}\sum^k_{j&#x3D;0}n_j,\ k&#x3D;0, 1, 2, …,L-1$</li><li>对于该变换函数，恒有 $p_s(s)&#x3D;p_r(r)|\frac{dr}{ds}|&#x3D;p_r(r)|\frac{1}{(L-a)p_r(r)}|&#x3D;\frac{1}{L-1}$ ，即 $p_s(s)$ 始终是均匀的，与 $p_r(r)$ 的形式无关</li><li>只要图像直方图中没有为 0 的分量，就满足严格单调递增，可以进行反变换 $r_k&#x3D;T^{-1}(s_k)$</li><li>局部直方图均衡，自适应直方图均衡</li><li><a href="https://zhuanlan.zhihu.com/p/44918476">参考资料</a></li></ul><h4 id="直方图匹配"><a href="#直方图匹配" class="headerlink" title="直方图匹配"></a>直方图匹配</h4><ul><li>直方图匹配（规范化）用于在处理后产生特殊直方图</li><li>步骤<ol><li>由输入图像得到 $p_r(r)$ ，并通过直方图均衡得到 $s$ 的值</li><li>通过 $G(z)&#x3D;(L-1)\int^z_0p_z(t)dt&#x3D;s$ 中指定的 $p_z(z)$ 求得变换函数 $G(z)$ ；对于离散函数，用 $G(z_q)&#x3D;(L-a)\sum^q_{i&#x3D;0}p_z(z_i)$ 对 $q&#x3D;0,1,…,L-1$ 计算变换函数 $G$ 的所有值，将其四舍五入为范围 $[0,L-1]$ 内的整数，存入一个表中</li><li>求得反变换函数 $&#x3D;G^{-1}(z)$ ；对于离散函数，对每一个值 $s_k$ 找到对应的 $z_q$ 值，以使 $G(z_q)$ 最接近 $s_k$ ，并储存这些从 $s$ 到 $k$ 的映射，当映射不唯一时，按惯例选择最小的值</li><li>对经过直方图均衡的图像中每个像素执行反变换函数，最后输出图像的 PDF 将等于指定的 PDF；对于离散函数，使用上一步找到的映射把该图像每个均衡后的像素值 $s_k$ 映射为直方图规定化后的图像中相应的 $z_q$ 值，形成直方图规范化后的图像</li></ol></li></ul><h4 id="在图像增强中使用直方图统计"><a href="#在图像增强中使用直方图统计" class="headerlink" title="在图像增强中使用直方图统计"></a>在图像增强中使用直方图统计</h4><ul><li>平均灰度、灰度方差</li><li>局部均值、局部方差：与全局均值、方差做比较来判断当前区域的亮度和对比度特征</li></ul><h3 id="空间滤波基础"><a href="#空间滤波基础" class="headerlink" title="空间滤波基础"></a>空间滤波基础</h3><p>滤波一词一般用于频域处理中，指接受或拒绝一定的频率分量；而空间滤波器也可以直接作用于图像本身</p><h4 id="空间滤波机理"><a href="#空间滤波机理" class="headerlink" title="空间滤波机理"></a>空间滤波机理</h4><p>空间滤波器由一个邻域（一般为较小矩形）和对该邻域包围的像像素执行的预定义操作组成。根据操作的不同，可以分为线性滤波器和非线性滤波器</p><h4 id="空间相关与卷积"><a href="#空间相关与卷积" class="headerlink" title="空间相关与卷积"></a>空间相关与卷积</h4><ul><li>相关<ul><li>$w(x,y) * f(x,y)&#x3D;\sum^a_{s&#x3D;-a}\sum^b_{t&#x3D;-b}w(s,t)f(x+s,y+t)$</li><li>相关是滤波器模版移过图像并计算每个位置乘积之和的处理，是滤波器位移的函数</li><li>一个函数与离散单位冲激相关，在该冲激位置产生这个函数一个翻转的版本</li></ul></li><li>卷积<ul><li>$w(x,y)* f(x,y)&#x3D;\sum^a_{s&#x3D;-a}\sum^b_{t&#x3D;-b}w(s,t)f(x-s,y-t)$</li><li>卷积的机理与相关类似，只不过滤波器要先旋转 $180^{\circ}$</li><li>卷积的特性是某个函数与某个单位冲激卷积，得到一个在该冲激处的这个函数的拷贝</li><li>如果滤波器模版是对称的，相关和卷积将得到同样的结果</li></ul></li></ul><h4 id="线性滤波的向量表示"><a href="#线性滤波的向量表示" class="headerlink" title="线性滤波的向量表示"></a>线性滤波的向量表示</h4><p> $R&#x3D;w_1z_1+w_2z_2+…+w_{mn}z_{mn}&#x3D;\sum^{mn}_{k&#x3D;1}&#x3D;\mathbf{w^Tz}$</p><h4 id="空间滤波器模版的产生"><a href="#空间滤波器模版的产生" class="headerlink" title="空间滤波器模版的产生"></a>空间滤波器模版的产生</h4><p>滤波器模版的系数由进行的操作来决定，需注意线性滤波仅能实现乘积求和操作；而非线性滤波要求确定邻域的大小，以及对包含在邻域内图像像素执行的操作</p><h3 id="空域平滑"><a href="#空域平滑" class="headerlink" title="空域平滑"></a>空域平滑</h3><p>平滑滤波器常用于模糊处理与降低噪声（预处理任务中），主要作用是：<br>&emsp;&emsp;1.模糊处理:去除图像中一些不重要的细节<br>&emsp;&emsp;2.减小噪声</p><h4 id="线性滤波器"><a href="#线性滤波器" class="headerlink" title="线性滤波器"></a>线性滤波器</h4><p>主要类别：<strong>均值滤波器</strong>、<strong>高斯滤波器</strong></p><h5 id="均值滤波器"><a href="#均值滤波器" class="headerlink" title="均值滤波器"></a>均值滤波器</h5><ul><li>平滑线性空间滤波器的输出是包含在滤波器模版邻域内的像素的简单平均值  $w_i&#x3D;\frac{1}{mn}$ ，也称为<strong>均值滤波器</strong></li><li>作用：减小图像灰度的“尖锐”变化，减小噪声。由于图像边缘是由图像灰度尖锐变化引起的，所以也存在边缘模糊的问题 （局限性）</li><li>常用均值滤波器<br><img src="/2024/03/10/digital-image-processing/18.png"></li></ul><h5 id="高斯滤波器-正态分布"><a href="#高斯滤波器-正态分布" class="headerlink" title="高斯滤波器(正态分布)"></a>高斯滤波器(正态分布)</h5><ul><li>一种特殊的线性滤波，其使用高斯函数作为权函数。</li><li>一维高斯函数: $p(x) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}$<ul><li>$\sigma$值的意义及选取</li></ul><ol><li>高斯滤波器模板的生成最重要的参数就是高斯分布的标准差$\sigma$。标准差代表着数据的离散程度，如果$\sigma$较小，那么生成的模板的中心系数较大，而周围的系数较小，这样对图像的平滑效果就不是很明显；反之，$\sigma$较大，则生成的模板的各个系数相差就不是很大，比较类似均值模板，对图像的平滑效果比较明显。</li><li>$\sigma$越大，分布越分散，各部分比重差别不大，于是生成的模板各元素值差别不大，类似于平均模板；$\sigma$越小，分布越集中，中间部分所占比重远远高于其他部分，反映到高斯模板上就是中心元素值远远大于其他元素值。</li></ol></li><li>二维高斯函数: $p(x) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2+y^2}{2\sigma^2}}$<br>$x$ 的平方和 $y$ 的平方分别表示的是邻域内其他像素与邻域内中心像素的距离，$\sigma$代表的是标准差<br><img src="/2024/03/10/digital-image-processing/19.png"></li></ul><h4 id="统计排序（非线性）滤波器"><a href="#统计排序（非线性）滤波器" class="headerlink" title="统计排序（非线性）滤波器"></a>统计排序（非线性）滤波器</h4><ul><li>主要类别：<strong>中值滤波器</strong>、<strong>最大值滤波器</strong>、<strong>最小值滤波器</strong></li><li>统计排序滤波器的响应以滤波器包围的图像区域中所包含的像素的排序为基础，然后使用统计排序的结果所决定的值替代中心像素的值</li></ul><h5 id="中值滤波器"><a href="#中值滤波器" class="headerlink" title="中值滤波器"></a>中值滤波器</h5><ul><li><strong>中值滤波器</strong>：将像素邻域内灰度的<strong>中值</strong>代替该像素的值<ul><li>对于脉冲噪声（椒盐噪声）非常有效，且比现行平滑滤波器的模糊程度要低</li><li>主要功能是使拥有不同灰度的点看起来更接近于他的相邻点</li></ul></li></ul><h5 id="最大值-最小值滤波器"><a href="#最大值-最小值滤波器" class="headerlink" title="最大值&#x2F;最小值滤波器"></a>最大值&#x2F;最小值滤波器</h5><ul><li><strong>最大值滤波器</strong>、<strong>最小值滤波器</strong>:将像素邻域内灰度的<strong>最大值&#x2F;最小值</strong>值代替该像素的值</li></ul><h3 id="空域锐化"><a href="#空域锐化" class="headerlink" title="空域锐化"></a>空域锐化</h3><ul><li>锐化处理的主要目的是突使模糊图像变清晰，增强图像的边缘等细节。<br>一般先去除噪声，再进行锐化处理。</li><li>图像模糊可通过在空间域用像素邻域平均法实现，因为均值处理与积分类似；而锐化处理可由空间微分来实现，因为微分算子的相应强度与图像在用算子操作的这一点的突变程度成正比<ul><li>一阶微分：$\frac{\partial f}{\partial x}&#x3D;f(x+1)-f(x)$</li><li>二阶微分：$\frac{\partial^2f}{\partial x^2}&#x3D;f(x+1)+f(x-1)-2f(x)$</li><li>图像的一阶微分常常在灰度变化处产生较粗的边缘，而二阶微分由零产生分开的双边缘；同时，在图像灰度陡变处，二阶微分将产生零交叉，对于边缘定位十分有用。因此，二阶微分在增强细节方面要比一阶微分好得多，是一个适合锐化图像的理想特性</li></ul></li></ul><h4 id="一阶微分：梯度"><a href="#一阶微分：梯度" class="headerlink" title="一阶微分：梯度"></a>一阶微分：梯度</h4><ul><li><p>梯度的幅值（梯度图像）：$M(x,y)&#x3D;mag(\nabla f)&#x3D;\sqrt {g^2_x+g^2_y}$</p><ul><li>非线性算子、非各向同性</li></ul></li><li><p>用绝对值来近似平方根更适合计算：$M(x,y)\approx |g_x|+|g_y|$</p></li><li><p>Sobel 算子，Robert 算子，Prewitt 算子，Kirsch 算子<br><img src="/2024/03/10/digital-image-processing/20.png"></p></li><li><p>所有模版中系数总和为 0，正如微分算子的期望值，表明灰度恒定区域的相应为 0</p></li></ul><h4 id="二阶微分：拉普拉斯算子"><a href="#二阶微分：拉普拉斯算子" class="headerlink" title="二阶微分：拉普拉斯算子"></a>二阶微分：拉普拉斯算子</h4><ul><li>拉普拉斯算子是最简单的各向同性微分算子（线性）</li><li>$\nabla^2f&#x3D;\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}&#x3D;f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$</li><li>以上算子仅对 $90^\circ$ 为增量旋转的各向同性，若加入沿对角线方向的两项，便可对 $45^\circ$ 增幅的结果也为各向同性</li><li>使用拉普拉斯算子对图像增强：$g(x,y)&#x3D;f(x,y)+c[\nabla^2f(x,y)]$</li><li>几种常用的拉普拉斯算子：<br><img src="/2024/03/10/digital-image-processing/21.png"></li></ul><hr><h2 id="频率域滤波"><a href="#频率域滤波" class="headerlink" title="频率域滤波"></a>频率域滤波</h2><h3 id="傅里叶变换-DFT"><a href="#傅里叶变换-DFT" class="headerlink" title="傅里叶变换(DFT)"></a>傅里叶变换(DFT)</h3><h4 id="一维傅立叶变换"><a href="#一维傅立叶变换" class="headerlink" title="一维傅立叶变换"></a>一维傅立叶变换</h4><h5 id="一维傅立叶变换及其反变换"><a href="#一维傅立叶变换及其反变换" class="headerlink" title="一维傅立叶变换及其反变换"></a>一维傅立叶变换及其反变换</h5><ul><li>一维傅立叶变换：$$F(u)&#x3D;\int_{-\infty}^\infty f(x){e^{-j2\pi ux}dx}$$ </li><li>一维傅里叶逆变换：$$f(x)&#x3D;\int_{-\infty}^\infty F(u){e^{j2\pi ux}du}$$</li></ul><h5 id="离散形式"><a href="#离散形式" class="headerlink" title="离散形式"></a>离散形式</h5><ul><li>一维傅立叶变换：$$F(u)&#x3D;\sum_{x&#x3D;0} ^{M-1} {f(x){e^{-j2\pi ux&#x2F;M}}}$$ </li><li>一维傅里叶逆变换：$$f(x)&#x3D;\frac{1}{M}\sum_{u&#x3D;0} ^{M-1} F(u){e^{j2\pi ux&#x2F;M}}$$</li><li>根据欧拉公式 $e^{j\theta} &#x3D; \cos{\theta} + j\sin{\theta}$ 可得一维傅里叶变换：<br>$$F(u)&#x3D;\sum_{x&#x3D;0} ^{M-1} {f(x)(\cos{2\pi ux&#x2F;M}-j\sin{2\pi ux&#x2F;M})}$$</li></ul><h5 id="极坐标形式"><a href="#极坐标形式" class="headerlink" title="极坐标形式"></a>极坐标形式</h5><ul><li>傅里叶变换的极坐标表示: $$F(u) &#x3D; |F(u)|e^{-j\phi(u)}$$</li><li>幅度或频率谱为:$$|F(u)| &#x3D; \sqrt{R^2(u)+I^2(u)}$$ 其中 $R$ 和 $I$ 分别为F的实部和虚部</li><li>相角或相位谱为:$$\phi(u) &#x3D; \arctan{\frac{I(u)}{R(u)}}$$</li></ul><h4 id="二维傅立叶变换"><a href="#二维傅立叶变换" class="headerlink" title="二维傅立叶变换"></a>二维傅立叶变换</h4><h5 id="二维傅立叶变换及其反变换"><a href="#二维傅立叶变换及其反变换" class="headerlink" title="二维傅立叶变换及其反变换"></a>二维傅立叶变换及其反变换</h5><ul><li>二维傅立叶变换：$$F(u,v)&#x3D;\int_{-\infty}^\infty f(x,y){e^{-j2\pi (ux+vy)}dxdy}$$ </li><li>二维傅里叶逆变换：$$f(x,y)&#x3D;\int_{-\infty}^\infty F(u,v){e^{j2\pi (ux+vy)}dudv}$$</li></ul><h5 id="离散形式-1"><a href="#离散形式-1" class="headerlink" title="离散形式"></a>离散形式</h5><ul><li>图像尺寸为$M×N$的函数$f(x,y)$的DFT定义为：$$F(u,v)&#x3D;\sum_{x&#x3D;0} ^{M-1}\sum_{y&#x3D;0}^{N-1} {f(x,y){e^{-j2\pi (ux&#x2F;M+vy&#x2F;N)}}}$$ </li><li>二维傅里叶逆变换：$$f(x,y)&#x3D;\frac{1}{MN}\sum_{u&#x3D;0} ^{M-1} \sum_{y&#x3D;0} ^{N-1}F(u,v){e^{j2\pi (ux&#x2F;M+vy&#x2F;N)}}$$</li></ul><h5 id="极坐标形式-1"><a href="#极坐标形式-1" class="headerlink" title="极坐标形式"></a>极坐标形式</h5><ul><li>二傅里叶变换的极坐标表示: $$F(u,v) &#x3D; |F(u,v)|e^{-j\phi(u,v)}$$</li><li>幅度或频率谱为:$$|F(u,v)| &#x3D; \sqrt{R^2(u,v)+I^2(u,v)}$$ 其中 $R$ 和 $I$ 分别为F的实部和虚部</li><li>相角或相位谱为:$$\phi(u,v) &#x3D; \arctan{\frac{I(u,v)}{R(u,v)}}$$</li></ul><h4 id="DEF的性质-主要是二维"><a href="#DEF的性质-主要是二维" class="headerlink" title="DEF的性质(主要是二维)"></a>DEF的性质(主要是二维)</h4><p><img src="/2024/03/10/digital-image-processing/22.png"></p><h3 id="频率域滤波基础"><a href="#频率域滤波基础" class="headerlink" title="频率域滤波基础"></a>频率域滤波基础</h3><h4 id="傅里叶变换的频率分量和图像空间特征之间的联系"><a href="#傅里叶变换的频率分量和图像空间特征之间的联系" class="headerlink" title="傅里叶变换的频率分量和图像空间特征之间的联系"></a>傅里叶变换的频率分量和图像空间特征之间的联系</h4><ul><li>变化最慢的频率成分 $(u&#x3D;v&#x3D;0)$ 对应一幅图像的平均灰度级:$$F(0,0)&#x3D;\sum_{x&#x3D;0} ^{M-1}\sum_{y&#x3D;0} ^{N-1}f(x,y)&#x3D;MN\overline{f(x,y)}$$</li><li>当从变换的原点移开时，<font color="#dd0000">低频对应着图像的慢变化分量</font>，如图像的平滑部分</li><li>进一步离开原点时，<font color="#dd0000">较高的频率对应图像中变化越来越快的灰度级</font>，如边缘或噪声等尖锐部分</li></ul><h4 id="频率域的滤波步骤"><a href="#频率域的滤波步骤" class="headerlink" title="频率域的滤波步骤"></a>频率域的滤波步骤</h4><ol><li>用 $(-1)x+y$ 乘以输入图像进行中心变换 $$f (x, y)(−1)^{x+y} \Leftrightarrow F(u − M &#x2F; 2,v − N &#x2F; 2)$$</li><li>计算1中的DFT $F(u,v)$</li><li>用滤波器函数 $H(u,v)$ 乘以 $F(u,v)$</li><li>计算3中结果的IDFT(逆傅里叶变换)</li><li>得到4中结果的实部</li><li>用 $(-1)^{x+y}$ 乘以5中的结果<br><img src="/2024/03/10/digital-image-processing/23.png"></li></ol><h4 id="主要类别"><a href="#主要类别" class="headerlink" title="主要类别"></a>主要类别</h4><ul><li><strong>低通滤波器</strong>：使低频通过而使高频衰减的滤波器<ul><li>被低通滤波的图像比原始图像少尖锐的细节部分而突出平滑过渡部分</li><li>对比空间域滤波的平滑处理，如均值滤波器</li></ul></li><li><strong>高通滤波器</strong>：使高频通过而使低频衰减的滤波器<ul><li>被高通滤波的图像比原始图像少灰度级的平滑过渡而突出边缘等细节部分</li><li>对比空间域的梯度算子、拉普拉斯算子</li></ul></li></ul><h4 id="空间域滤波和频率域滤波之间的对应关系"><a href="#空间域滤波和频率域滤波之间的对应关系" class="headerlink" title="空间域滤波和频率域滤波之间的对应关系"></a>空间域滤波和频率域滤波之间的对应关系</h4><ul><li>大小为$M×N$的两个函数$f(x,y)$和$h(x,y)$的离散卷积表示为$f(x,y)*h(x,y)$，定义为$$f(x,y)*h(x,y)&#x3D;\frac{1}{MN}\sum_{u&#x3D;0} ^{M-1} \sum_{y&#x3D;0} ^{N-1}f(x,y)h(x-m,y-n)$$</li><li>对比空间域滤波：在$M×N$的图像$f$上，用$m×n$的滤波器进行线性滤波$$<br>g(x,y)&#x3D;\sum_{s&#x3D;-a} ^{a}\sum_{t&#x3D;-b} ^{b}w(s,t)f(x+s,y+t)$$</li><li>卷积定理:$f(x,y)*h(x,y)\Leftrightarrow F(u,v)*H(u,v)$</li><li>上式说明空间域卷积可以通过$F(u,v)H(u,v) $的乘积进行反傅里叶变换得到</li><li>上述两个公式主要为两个函数逐元素相乘的乘法<br><img src="/2024/03/10/digital-image-processing/25.png"><br><img src="/2024/03/10/digital-image-processing/24.png"></li></ul><h3 id="频率域滤波器平滑图像"><a href="#频率域滤波器平滑图像" class="headerlink" title="频率域滤波器平滑图像"></a>频率域滤波器平滑图像</h3><h4 id="理想低通滤波器-Ideal"><a href="#理想低通滤波器-Ideal" class="headerlink" title="理想低通滤波器(Ideal)"></a>理想低通滤波器(Ideal)</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>截断傅里叶变换中的所有<strong>高频</strong>成分，这些高频成分处于指定距离$D_0$之外<br><img src="/2024/03/10/digital-image-processing/26.png"><br><strong>说明</strong>：在半径为$D_0$的圆内，所有频率没有衰减地通过滤波器，而在此半径的圆之外的所有频率完全被衰减掉</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>截止频率即为$D_0$<br><img src="/2024/03/10/digital-image-processing/27.png"><br><strong>结论</strong>：半径$D_0$越小，模糊越大；半径$D_0$越大，模糊越小</p><h4 id="巴特沃思低通滤波器-Butterworth"><a href="#巴特沃思低通滤波器-Butterworth" class="headerlink" title="巴特沃思低通滤波器(Butterworth)"></a>巴特沃思低通滤波器(Butterworth)</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><img src="/2024/03/10/digital-image-processing/28.png"><br><strong>应用</strong>：可用于平滑处理，如图像由于量化不足产生虚假轮廓时，常可用低通滤波进行平滑以改进图像质量。通常，BLPF的平滑效果好于ILPF。</p><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/29.png"></p><h4 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a>高斯低通滤波器</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><img src="/2024/03/10/digital-image-processing/30.png"></p><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/31.png"><br>高斯低通滤波器（GLPF）的傅里叶反变换也是高斯的，因此通过上式的IDFT得到的空间高斯滤波器没有振铃。</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>低通滤波器的应用实例：<strong>模糊</strong>，<strong>平滑</strong>等</p><ul><li><strong>字符识别</strong>：通过模糊图像，桥接断裂字符的裂缝</li><li><strong>印刷和出版业</strong>：从一幅尖锐的原始图像产生平滑、柔和的外观，如人脸，减少皮肤细纹的锐化程度和小斑点</li><li><strong>处理卫星和航空图像</strong>：尽可能模糊细节，而保留大的可识别特征。低通滤波通过消除不重要的特征来简化感兴趣特征的分析</li></ul><h3 id="频率域滤波器锐化图像"><a href="#频率域滤波器锐化图像" class="headerlink" title="频率域滤波器锐化图像"></a>频率域滤波器锐化图像</h3><h4 id="理想高通滤波器"><a href="#理想高通滤波器" class="headerlink" title="理想高通滤波器"></a>理想高通滤波器</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p>截断傅里叶变换中的所有<strong>低频</strong>成分，这些低频成分处于指定距离$D_0$之内<br><img src="/2024/03/10/digital-image-processing/32.png"></p><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/33.png"></p><p><strong>结论</strong>：图a和b的振铃问题十分明显</p><h4 id="巴特沃思高通滤波器"><a href="#巴特沃思高通滤波器" class="headerlink" title="巴特沃思高通滤波器"></a>巴特沃思高通滤波器</h4><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><p><img src="/2024/03/10/digital-image-processing/34.png"></p><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/35.png"><br><strong>结论</strong>：BHPF的结果比IHPF的结果平滑得多</p><h4 id="高斯高通滤波器"><a href="#高斯高通滤波器" class="headerlink" title="高斯高通滤波器"></a>高斯高通滤波器</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><p><img src="/2024/03/10/digital-image-processing/36.png"></p><h5 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/37.png"><br><strong>结论</strong>：GHPF的结果比BHBF和IHPF的结果更平滑</p><hr><h2 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h2><h3 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h3><h4 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li>$A$被$B$腐蚀的定义为：$A\ominus B&#x3D; {z|(B)_z\subseteq A} $</li><li>该式表明腐蚀的结果为所有使$B$中包含于$A$中的点$z$的集合用$z$平移。集合$B$在被称为<strong>结构元素</strong>。</li><li><strong>腐蚀运算的含义是</strong>：每当在目标图像$A$中找到一个与结构元素$B$相同的子图像时，就把该子图像中与$B$的原点位置对应的那个像素位置标注为1，图像$A$上标注出的所有这样的像素组成的集合，即为腐蚀运算的结果。</li><li>简而言之，腐蚀运算的实质就是在目标图像中标出那些与结构元素相同的子图像的原点位置的像素。</li><li><strong>注意</strong>，<font color="#dd0000">结构元素中的原点位置可以不为1</font>。</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>对$Z$中的集合$A和B$，$B$对$A$进行腐蚀的整个过程如下：</li></ul><ol><li>用结构元素$B$，扫描图像$A$的每一个像素</li><li>用结构元素与其覆盖的二值图像做“与”操作</li><li>如果都为1，结果图像的该像素为1。否则为0</li></ol><ul><li>腐蚀处理的结果是使原来的二值图像减小一圈</li></ul><h5 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/38.png"><br><img src="/2024/03/10/digital-image-processing/39.png"></p><ul><li>事实上，我们可以将腐蚀视为形态学滤波操作，这种操作把<strong>比结构元小的图像细节</strong>从图像中滤除<br><img src="/2024/03/10/digital-image-processing/40.png"></li></ul><h4 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ul><li>$A$被$B$膨胀的定义为：$A\oplus B&#x3D;{z|(\hat{B})_z\cap A \neq\varnothing}$</li><li>该式表明膨胀过程是$B$首先做关于原点的映像$\hat{B}$，然后平移$z$。$A$被$B$膨胀是所有位移$z$的集合，这样 $\hat{B}$和$A$至少有一个元素是重叠的</li><li>腐蚀是一种收缩或细化操作，而膨胀则会“增长”或“粗化”二值图像中的物体</li></ul><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ul><li>对$Z$中的集合$A$和$B$，$B$对$A$进行膨胀的整个过程如下：</li></ul><ol><li>首先$B$做关于原点的映像$\hat{B}$</li><li>用结构元素$\hat{B}$，扫描图像$A$的每一个像素</li><li>用结构元素与其覆盖的二值图像做“与”操作</li><li>如果都为0，结果图像的该像素为0。否则为1</li></ol><h5 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/41.png"><br><img src="/2024/03/10/digital-image-processing/42.png"></p><ul><li>最简单的膨胀应用之一是连接裂缝<ul><li>形态学方法较之用于连接断裂的低通滤波方法的一个直接优点是，形态学方法<br>可在一幅二值图像中直接得到结果。</li><li>另一方面，低通滤波方法则从一幅二值图像开始，生成一幅灰度图像，它需要<br>用一个阈值函数将灰度图像转换为二值图像<br><img src="/2024/03/10/digital-image-processing/43.png"></li></ul></li></ul><h4 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h4><h5 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h5><ul><li>$B$ 对 $A$ 的腐蚀是 $\hat{B}$ 对 $A^c$ 的膨胀的补集，反之亦然</li><li>当结构元关于其原点对称时有 $\hat{B}&#x3D;B$，此时可以用相同的结构元简单地使用 $B$ 膨胀图像的背景，对该结果求补即可得到 $B$ 对该幅图像的腐蚀</li></ul><h5 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/44.png"></p><h3 id="开操作与闭操作"><a href="#开操作与闭操作" class="headerlink" title="开操作与闭操作"></a>开操作与闭操作</h3><h4 id="开操作"><a href="#开操作" class="headerlink" title="开操作"></a>开操作</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><ul><li>使用同一个结构元素对目标图像<strong>先</strong>进行<strong>腐蚀</strong>运算，然后<strong>再</strong>进行<strong>膨胀</strong>运算称为<strong>开操作</strong>。开操作一般使对象的轮廓变得光滑，断开狭窄的间断和消除细的突出物。</li><li>结构元素$B$对目标图像$A$的开操作定义为：$A\circ B&#x3D;(A\ominus B)\oplus B$</li></ul><h6 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h6><p><img src="/2024/03/10/digital-image-processing/45.png"></p><ul><li>假设我们把结构元 $B$ 视为一个“转球”</li><li>$B$ 对 $A$ 的开操作的边界由 $B$ 中的点建立：当 $B$ 在 $A$ 的边界内侧滚动时，$B$ 所能到达的 $A$ 的边界的最远点<br><img src="/2024/03/10/digital-image-processing/46.png"></li></ul><h4 id="闭操作"><a href="#闭操作" class="headerlink" title="闭操作"></a>闭操作</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><ul><li>使用同一个结构元素对目标图像<strong>先</strong>进行<strong>膨胀</strong>运算，然后<strong>再</strong>进行<strong>腐蚀</strong>运算称为<strong>闭操作</strong>。闭操作同样使轮廓线更光滑，但它通常消弭狭窄的间断和长细的鸿沟，消除小的孔洞，并填补轮廓线中的断裂。</li><li>结构元素$B$对目标图像$A$的闭运算定义为：$A\bullet B&#x3D;(A\oplus B)\ominus B$</li></ul><h5 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h5><p><img src="/2024/03/10/digital-image-processing/47.png"></p><ul><li>开操作与闭操作彼此对偶，所以闭操作在边界外侧滚动球体是意料之中的事情，$B$ 在 $A$ 的边界外侧外切滚动一圈， 所有 $(B)_z$ 的并集构成的内包络为边界<br><img src="/2024/03/10/digital-image-processing/48.png"></li></ul><h4 id="对偶性-1"><a href="#对偶性-1" class="headerlink" title="对偶性"></a>对偶性</h4><h5 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h5><ul><li>开操作与闭操作互为对偶，并可表示为：$$(A\bullet B)^c&#x3D;(A^c \circ \hat B)$$和$$(A \circ B)^c&#x3D;(A^c \bullet \hat B)$$</li></ul><ul><li>开操作满足下列性质：<ul><li>$A \circ B$是$A$的一个子集（子图像）</li><li>如果$C$是$D$的一个子集，则$C \circ B$是$𝐷 \circ B$的一个子集</li><li>$(A \circ B) \circ B &#x3D; A \circ B$</li></ul></li><li>类似地，闭操作满足下列性质：<ul><li>$A$是$A \bullet B$的一个子集（子图像）</li><li>如果$C$是$D$的一个子集，则$C \bullet B$是$𝐷 \bullet B$的一个子集</li><li>$(A \bullet B) \bullet B &#x3D; A \bullet B$</li></ul></li></ul><h3 id="击中或不击中变换"><a href="#击中或不击中变换" class="headerlink" title="击中或不击中变换"></a>击中或不击中变换</h3><ul><li><p>击中或击不中变换是形状检测的基本工具。</p></li><li><p>如果$B$表示由$D$及其背景组成的集合，则$B$在$A$中的匹配，表示为$A ⊛ B$，是$$A ⊛ B&#x3D;(A\ominus D)\cap[A^c\ominus(W-D)]$$</p><div align="center"><img src="/2024/03/10/digital-image-processing/49.png" width="60%"></div></li><li><p>我们可以通过令$B &#x3D; (B_1,B_2)$ 对这种表示法稍微做些推广，其中$B_1$是由与一个目标相联系的$B$的元素构成的集合，$B_2$是由与相应背景相联系的$B$的元素构成的集合。根据前面的讨论， $B_1 &#x3D; D，B_2 &#x3D;W − D）$。用这种表示方法，击中或击不中变换变为$$A ⊛ B&#x3D;(A\ominus B_1)\cap(A^c\ominus B_2)$$</p></li><li><p>因此，集合$A ⊛ B$包含了所有的原点，同时，在这些原点处，$B_1$在$A$中找到了一个匹配（击中），$B_2$在$𝐴^c$中也找到了一个匹配。使用腐蚀与膨胀的对偶关系，可将上式写为$$A ⊛ B&#x3D;(A\ominus B_1)\cap(A^c\oplus \hat B_2)^c$$</p></li><li><p>使用与物体有关的结构元$B_1$和与背景有关的结构元$B_2$的原因，基于一个假设的定义——仅当两个或多个物体形成相脱离的集合时，这些物体才是可分的。</p></li><li><p>在某些应用中，我们可能对检测某个集合内由$1$和$0$组成的某些模式感兴趣，在这种情况下不需要背景。因此，击中或击不中就简化为简单的腐蚀。</p></li></ul><h3 id="一些基本的形态学算法"><a href="#一些基本的形态学算法" class="headerlink" title="一些基本的形态学算法"></a>一些基本的形态学算法</h3><h4 id="边界提取"><a href="#边界提取" class="headerlink" title="边界提取"></a>边界提取</h4><ul><li>表示为 $\beta (A)$ 的集合 A 的边界可以通过先用 B 对 A 腐蚀，而后执行 A 和腐蚀的结果之间的差集得到</li></ul><h4 id="孔洞填充"><a href="#孔洞填充" class="headerlink" title="孔洞填充"></a>孔洞填充</h4><ul><li>孔洞定义:由前景像素相连接的边界所包围的背景区域</li><li>令 A 表示一个集合，其元素是 8 连通的边界，每个边界包围一个背景区域。当给定每个孔洞中的一个点后，目的就是用 1 填充所有的 孔洞</li><li>给定每个孔洞中对应于 $X_0$ 中的位置点(这一点已经置为 1 )，我们从形成一个由 0 组成的阵列 $X_0$ 开始。然后，如下过程将用 1 填充所有孔洞L ：$X_k&#x3D;(X_{k-1}\oplus B)\cap A^c$</li><li>如果 $X_k &#x3D; X_{k-1}$ ，则算法在迭代的第 k 步结束。然后，集合 $X_k$ 包含所有被填充的孔洞。$X_k$ 和 A 的并集包含所有填充的孔洞及这些孔洞的边界</li><li>如果左边不加限制，那么膨胀将填充整个区域。然而，每一步中 与 $A^c$ 的交集操作将把结果限制到感兴趣区域内，称为条件膨胀</li></ul><h4 id="连通分量的提取"><a href="#连通分量的提取" class="headerlink" title="连通分量的提取"></a>连通分量的提取</h4><ul><li>令 A 是包含一个或多个连通分量的集合，并形成一个阵列 $X_0$ 除了在对应于 A 中每个连通分量的一个点的每个已知位置处我们已置为 1 外，该阵列的所有其他元素均为 0 。如下迭代过程可完成这一目 的：$X_k&#x3D;(X_{k-1}\oplus B)\cap A$</li></ul><h4 id="凸壳"><a href="#凸壳" class="headerlink" title="凸壳"></a>凸壳</h4><ul><li>如果在集合 A 内连接任意两个点的直线段都在 A 的内部，则称集合 A 是凸形的。任意集合 S 的凸壳 H 是包含 S 的最小凸集。差集 H-S 称为 S 的凸缺</li><li>$X^i_k&#x3D;(X_{k-1}\circledast B^i)\cup A$，当该过程收敛时，我们令 $D^i&#x3D;X^i_k$，则 A 的凸壳为：$C(A)&#x3D;\bigcup^4_{i&#x3D;1}D^i$</li></ul><h4 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h4><ul><li>$A\otimes B&#x3D;A-(A\circledast B)$</li><li>我们仅对与结构元的模式匹配感兴趣，所以在击中或击不中变换中没有背景运算</li></ul><h4 id="粗化"><a href="#粗化" class="headerlink" title="粗化"></a>粗化</h4><ul><li>粗化是细化的形态学对偶：$A\cdot B&#x3D;A\cup (A\circledast B)$</li><li>然而，针对粗化的分离算法在实际中很少用到，取而代之的过程 是先对问题中集合的背景进行细化，而后对结果求补集。由于依赖于 A 的性质，这个过程可能会产生某些断点。因此，通过这种方法的粗化处理通常会跟随一个消除断点的后处理</li></ul><h4 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h4><ul><li>A 的骨架可以用腐蚀和开操作来表达，即骨架可以表示为 $S(A)&#x3D;\bigcup^K_{k&#x3D;0}S_k(A)$ 其中，$S(A)&#x3D;(A\ominus kB)-(A\ominus kB)\circ B$， $K$ 是 A 被腐蚀成空集前的最后一次迭代步骤</li><li>使用下式可由这些子集来重建 A ：$A&#x3D;\bigcup^K_{k&#x3D;0}(S_k(A)\oplus kB)$</li></ul><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><ul><li>裁剪方法本质上是对细化和骨架算法的补充，因</li><li>为这些过程会保留某些寄生成分，因而需要用后处理来清除这些寄生成分</li></ul><h4 id="形态学重建"><a href="#形态学重建" class="headerlink" title="形态学重建"></a>形态学重建</h4><ul><li>形态学重建涉及两幅图像和一个结构元，一幅图像是标记，它包含变换的起始点，另一幅图像是模板，它用来约束该变换。结构元用来定义连续性</li><li>形态学重建的核心是测地膨胀和测地腐蚀<ul><li>测地膨胀和测地腐蚀关于集合的补集对偶</li><li>有限数量图像的测地膨胀和腐蚀经过有限数量的迭代步骤后总会收敛，因为标记图像的扩散或收缩受模版约束</li></ul></li><li>用腐蚀和膨胀的形态学重建：反复执行测地膨胀或腐蚀，直到达到稳定状态</li><li>重建开操作：形态学开操作中，腐蚀会删除小的物体，而后续的膨胀会试图恢复遗留物体的形状。然而这种恢复的准确性高度依赖于物体的形状和所用结构元的相似性；而重建开操作可正确地恢复腐蚀后所保留物体的形状</li><li>填充孔洞</li><li>边界清除</li></ul><hr><h2 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h2><ul><li>图像分割是指将图像细分为构成它的子区域或物体</li><li>本章算法基于灰度值的两个基本性质之一：不连续性和相似性</li></ul><h3 id="边缘分割法"><a href="#边缘分割法" class="headerlink" title="边缘分割法"></a>边缘分割法</h3><h4 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h4><ul><li>就像局部平均平滑一幅图像那样，假设平均处理类似于积分，对于灰度的突变，局部变化可以用微分来检测</li><li>使用空间滤波器来计算图像中每个像素位置处的一阶导数和二阶导数</li><li>一阶导数和二阶导数的特点<ul><li>一阶导数通常在图像中产生较粗的边缘</li><li>二阶导数对精细细节，如细线、孤立点和噪声有较强的响应</li><li>二阶导数在灰度斜坡和灰度台阶过渡处会产生双边缘响应</li><li>二阶导数的符号可用于确定边缘的过渡是从亮到暗还是从暗到亮</li></ul></li></ul><h4 id="孤立点的检测"><a href="#孤立点的检测" class="headerlink" title="孤立点的检测"></a>孤立点的检测</h4><ul><li>点的检测应以二阶导数为基础，即使用拉普拉斯算子$$𝛻^2𝑓 (𝑥, 𝑦) &#x3D; 𝑓 (𝑥 + 1, 𝑦) + 𝑓 (𝑥 − 1, 𝑦) + 𝑓 (𝑥, 𝑦 + 1) + 𝑓 (𝑥, 𝑦 − 1) − 4𝑓(𝑥, 𝑦)$$</li><li>如果在某个点处，该模板的<strong>响应的绝对值超过了指定的阈值</strong>，则在 (x,y) 处的点已被检测到。在输出图像中，该点标为1，否则为0<div align="center"><img src="/2024/03/10/digital-image-processing/50.png" width="70%"></div></li></ul><h4 id="线检测"><a href="#线检测" class="headerlink" title="线检测"></a>线检测</h4><ul><li>对于线检测，二阶导数将导致更强的响应，产生比一阶导数更细的线。我们可以使用拉普拉斯模板，但要处理双线效应</li><li>例：<br><img src="/2024/03/10/digital-image-processing/51.png"> </li><li>当把3×3滤波器居中放在一条宽为5个像素的恒定灰度线上时，其响应将为零，这样就产生了双线效应</li><li>点检测的拉普拉斯算子是<strong>各向同性</strong>的，因此<strong>其响应与方向无关</strong> (相对于该3×3拉普拉斯目标的4个方向:垂直方向、水平方向和两个对角方向)</li><li>通常，我们的兴趣在于检测特定方向的线。<br><img src="/2024/03/10/digital-image-processing/52.png"> </li><li>第一个模板对于水平线有最佳响应；第二个模板对于45度方向的线有最佳响应；第三个模板对于垂直线有最佳响应；第四个模板对于-45度方向的线有最佳响应</li><li>每个模板的首选方向用一个比其他方向更大的系数（如2）加权。所有模板的系数之和为0，这表明<strong>恒定灰度区域中的响应为0</strong></li><li>特定方向线的检测<br><img src="/2024/03/10/digital-image-processing/53.png"></li></ul><h4 id="边缘模型"><a href="#边缘模型" class="headerlink" title="边缘模型"></a>边缘模型</h4><ul><li>边缘检测是基于灰度突变来分割图像的常用方法</li><li>边缘模型根据它们的灰度剖面来分类。有台阶边缘、斜坡边缘和 “屋顶”边缘等</li><li>下图显示了这些边缘模型和相应的灰度剖面<br><img src="/2024/03/10/digital-image-processing/54.png"> </li><li>一阶导数的<strong>幅度</strong>可用于检测图像中的某个点处是否存在一个边缘</li><li>二阶导数的<strong>符号</strong>用于确定一个边缘像素是位于该边缘的暗侧还是位于该边缘的亮侧<ul><li>对图像中的每条边缘，二阶导数生成两个值(一个不希望的特点)</li><li>二阶导数的<strong>零交叉点</strong>可用于定位粗边缘的中心</li></ul></li><li>微弱的可见噪声严重影响检测边缘所用的一阶导数和二阶导数，二阶导数比一阶导数更为敏感</li><li>因此执行边缘检测的三个基本步骤是:<ul><li>为降噪图像进行平滑处理</li><li>边缘点的检测。这是一个局部操作，从一幅图像中提取所有边缘点的潜在候选者</li><li>边缘定位。这一步的目的是从候选边缘点中选择组成边缘点集合的真实成员</li></ul></li></ul><h4 id="基本边缘检测"><a href="#基本边缘检测" class="headerlink" title="基本边缘检测"></a>基本边缘检测</h4><ul><li>梯度向量、幅度和方向角<br><img src="/2024/03/10/digital-image-processing/57.png"> </li><li>图像边缘方向与边缘上点的梯度向量正交<br><img src="/2024/03/10/digital-image-processing/58.png"> </li><li>梯度算子：Roberts, Prewitt, Sobel（抑制噪声）<br><img src="/2024/03/10/digital-image-processing/55.png"><br><img src="/2024/03/10/digital-image-processing/56.png"> <ul><li>精细的细节在边缘检测中通常是不符合需要的，因为它往往表现为噪声，导致<br>计算会增强这种噪声，使主要边缘的检测变得复杂。</li><li>减少精细细节的一个方法是对图像进行平滑处理，如下图<br><img src="/2024/03/10/digital-image-processing/59.png"></li></ul></li><li>与阈值处理相结合的梯度<ul><li>在计算梯度前对图像进行平滑处理，边缘检测可做更多的选择。实现相同基本目标的另一种方法是，对梯度图像进行阈值处理。</li><li>阈值处理后的图像边缘更少，并且图像中的边缘要清晰得多。另一方面，许多边缘被断开了</li><li>当目的是突出主要边缘并尽可能保持连接时，实践中通常既做平滑处理也做阈值处理<br><img src="/2024/03/10/digital-image-processing/60.png"></li></ul></li></ul><h4 id="Marr-Hildreth边缘检测器（马尔算子）"><a href="#Marr-Hildreth边缘检测器（马尔算子）" class="headerlink" title="Marr-Hildreth边缘检测器（马尔算子）"></a>Marr-Hildreth边缘检测器（马尔算子）</h4><ul><li>高斯拉普拉斯（LoG）</li><li>下图显示了一个LoG的负函数的三维图、图像和剖面<br><img src="/2024/03/10/digital-image-processing/61.png"> </li><li>特点<ul><li>算子的高斯部分会模糊图像</li><li>尽管一阶导数可用于检测灰度突变，但它们是有方向的算子。另一方面，拉普拉斯有各向同性的优点，符合人的视觉系统特性</li></ul></li><li>步骤<ul><li>用一个2-D的高斯平滑模板与源图象卷积</li><li>计算卷积后图象的拉普拉斯值</li><li>检测拉普拉斯图象中的零交叉作为边缘点<ul><li>寻找零交叉的方法是用以p为中心的一个3x3的邻域，p点处零交叉意味着至少有两个相对的邻域像素的符号不同；如果进行阈值处理，那么不仅相对邻域的符号不同，它们的数值差的绝对值还必须超过这个阈值</li><li>使用零交叉检测边缘的另一个好处是可以得到一个像素宽的边缘，简化了诸如边缘连接的后续阶段的处理</li></ul></li></ul></li><li>使用高斯差分(DoG)来近似LoG滤波器<br><img src="/2024/03/10/digital-image-processing/62.png"></li></ul><h4 id="坎尼边缘检测器-Canny"><a href="#坎尼边缘检测器-Canny" class="headerlink" title="坎尼边缘检测器(Canny)"></a>坎尼边缘检测器(Canny)</h4><ul><li><strong>一般标准</strong>:<br> ① 低错误率。既要少将真正的边缘丢失也要少将非边缘判为边<br>缘。<br>② 边缘点应被很好地定位。检测出的边缘应在真正的边界上。<br>③ 单一的边缘响应。得到的边界为单象素宽。</li><li>基本步骤总结:<ol><li>灰度化</li><li>使用<strong>高斯滤波器</strong>平滑图像、滤除噪声</li><li>计算图像中每个像素点的<strong>梯度强度和方向</strong></li><li>对梯度幅值图像应用<strong>极大值抑制</strong></li><li><strong>双阈值处理</strong></li><li>抑制孤立低阈值点</li></ol></li><li>以下是重点步骤详解：</li><li><strong>使用高斯滤波器平滑图像、滤除噪声</strong><ul><li>这一步很简单，类似于LOG算子（Laplacian of Gaussian）进行高斯平滑，主要作用就是去除噪声。因为噪声也集中于高频信号，很容易被识别为伪边缘。应用高斯模糊去除噪声，降低伪边缘的识别。但是由于图像边缘信息也是高频信号，高斯模糊的半径选择很重要，过大的半径很容易让一些弱边缘检测不到。</li><li>大小为$(2k+1)×(2k+1)$的高斯滤波器核的生成方程式由下式给出: $$w_{ij}&#x3D;\frac{1}{2\pi \sigma^2}e^{-\frac{(i-k-1)^2+(j-k-1)^2}{2\sigma^2}},1\leq i,j\leq(2k+1)$$</li><li>高斯卷积核大小的选择将影响Canny检测器的性能。尺寸越大，检测器对噪声的敏感度越低，但是边缘检测的定位误差也将略有增加。一般5×5是一个比较不错的trade-off。</li></ul></li><li><strong>计算图像中每个像素点的梯度强度和方向</strong><ul><li>注：在opencv中，选取3×3的Sobel算子</li></ul></li><li><strong>非极大值抑制</strong>(NMS,Non-Maximum Suppression)<ul><li>NMS是一种边缘稀疏技术，非极大值抑制的作用在于“瘦”边。对图像进行梯度计算后，仅仅基于梯度值提取的边缘仍然很模糊。对边缘而言，有且应当只有一个准确的响应。而NMS则可以帮助将局部最大值之外的所有梯度值抑制为0，对梯度图像中每个像素进行非极大值抑制的算法是： <ul><li>将当前像素的梯度强度与沿正负梯度方向上的两个像素进行比较。</li><li>如果当前像素的梯度强度与另外两个像素相比最大，则该像素点保留为边缘点，否则该像素点将被抑制。<br><img src="/2024/03/10/digital-image-processing/63.png"></li></ul></li></ul></li><li><strong>双阈值检测</strong><ul><li>在施加非极大值抑制之后，剩余的像素可以更准确地表示图像中的实际边缘。然而，仍然存在由于噪声和颜色变化引起的一些边缘像素。为了解决这些杂散响应，必须用<strong>弱梯度值过滤</strong>边缘像素，并<strong>保留</strong>具有<strong>高梯度值</strong>的边缘像素。</li><li>如果边缘像素的梯度值<strong>高于高阈值</strong>，则将其标记为<strong>强边缘像素</strong>；</li><li>如果边缘像素的梯度值<strong>小于高阈值并且大于低阈值</strong>，则将其标记为<strong>弱边缘像素</strong>；</li><li>如果边缘像素的梯度值<strong>小于低阈值</strong>，则会<strong>被抑制</strong>。</li><li>阈值的选择取决于给定输入图像的内容。</li></ul></li><li><strong>抑制孤立低阈值点</strong><ul><li>到目前为止，被划分为强边缘的像素点已经被确定为边缘，因为它们是从图像中的真实边缘中提取出来的。</li><li>然而，对于弱边缘像素，将会有一些讨论，因为这些像素可能从真实边缘提取也可能是因噪声或颜色变化引起的。为获得准确的结果，应该抑制由后者引起的弱边缘。</li><li>通常，由真实边缘引起的弱边缘像素将连接到强边缘像素，而噪声响应未连接。为了跟踪边缘连接，通过查看弱边缘像素及其8个邻域像素，只要其中一个为强边缘像素，则该弱边缘点就可以保留为真实的边缘。</li></ul></li><li>实例：<br><img src="/2024/03/10/digital-image-processing/64.png"></li></ul><h4 id="边缘连接和边界检测"><a href="#边缘连接和边界检测" class="headerlink" title="边缘连接和边界检测"></a>边缘连接和边界检测</h4><ul><li>理想情况下，边缘检测应该仅产生位于边缘上的像素集合。实际上，由于噪声、不均匀照明引起的<strong>边缘间断</strong>，以及其他引入灰度值虚假的不连续的影响，这些像素并不能完全描述边缘特性。</li><li>因此，一般是在边缘检测后紧跟连接算法，将边缘像素组合成有意义的边缘或区域边界。</li><li>本节讨论三种基本的边缘连接方法<ul><li>第一种方法需要有关局部区域中的边缘点（如一个3×3邻域）的知识；</li><li>第二种方法要求区域边界上的点已知；</li><li>第三种方法是<strong>处理整个边缘图像的全局方法</strong>(重点)</li></ul></li></ul><h4 id="基于Hough变换的全局处理"><a href="#基于Hough变换的全局处理" class="headerlink" title="基于Hough变换的全局处理"></a>基于Hough变换的全局处理</h4><ul><li>基本思想：图像中每一点对参数组合进行表决，赢得多数票的参数组合为胜者（结果）。最基本的霍夫变换是从黑白图像中检测直线(线段)。</li><li>Hough变换主要优点：是能容忍特征边界描述中的间隙，并且相对不受图像噪声的影响。</li><li>步骤：<ol><li>读取原始图并转换成灰度图，采用边缘检测算子（如Canny）转换成二值化边缘图像</li><li>然后对该图像进行霍夫变换</li><li>先使用峰值检测函数，找到大于阈值的霍夫变换单元（局部最大值应该最可能是线，步长和量化会影响效果）</li><li>将上述识别出的一组候选峰，需要确定与其相关的线段及其起始点和终止点（这需要一定的算法，很多论文对此都做了改进，诸如蝴蝶形状宽度，峰值走廊）</li><li>然后描绘于原图（或结果图）上</li></ol></li></ul><h3 id="阈值分割法"><a href="#阈值分割法" class="headerlink" title="阈值分割法"></a>阈值分割法</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>阈值处理操作<br>$$T &#x3D;T[x, y, p(x, y), f (x, y)]$$</li><li>$f(x,y)$是点$(x,y)$的灰度级，$p(x,y)$表示该点的局部性质，如以$(x,y)$为中心的邻域的平均灰度级</li><li>阈值处理后的图像$g(x,y)$定义为<br><img src="/2024/03/10/digital-image-processing/68.png"></li><li>标记为$1$的像素对应于对象，标记为$0$的像素对应于背景</li><li>当$T$仅取决于$f(x,y)$，阈值称为全局的</li><li>当$T$取决于$f(x,y)$和$p(x,y)$，阈值是局部的</li><li>当$T$取决于空间坐标$x$和$y$，阈值就是动态的或自适应的</li></ul><h4 id="全局阈值"><a href="#全局阈值" class="headerlink" title="全局阈值"></a>全局阈值</h4><ul><li>全局阈值算法步骤:<ol><li>选择一个$T$的初始估计值</li><li>用$T$分割图像，生成两组像素：$G_1$由所有灰度值大于$T$的像素组成，而$G_2$由所有灰度值小于或等于$T$的像素组成</li><li>对区域$G_1$和$G_2$中的所有像素计算平均灰度值$µ_1$和$µ_2$</li><li>计算新的阈值 $T&#x3D;\frac{1}{2}(µ_1+µ_2)$</li><li>重复步骤2到4，直到逐次迭代所得的$T$值之差小于事先定义的参数$T_0$<br><img src="/2024/03/10/digital-image-processing/69.png"></li></ol></li></ul><h4 id="Otsu方法：最佳全局阈值"><a href="#Otsu方法：最佳全局阈值" class="headerlink" title="Otsu方法：最佳全局阈值"></a>Otsu方法：最佳全局阈值</h4><ul><li>该方法在类间方差最大的情况下是最佳的；完全以在一幅图像的直方图上执行计算为基础。</li><li>算法具体步骤如下：<br><img src="/2024/03/10/digital-image-processing/70.png"></li><li>实例：<br><img src="/2024/03/10/digital-image-processing/71.png"></li></ul><h4 id="图像平滑改善全局阈值"><a href="#图像平滑改善全局阈值" class="headerlink" title="图像平滑改善全局阈值"></a>图像平滑改善全局阈值</h4><p><img src="/2024/03/10/digital-image-processing/72.png"></p><ul><li>Otsu失败的原因可归于这样一个事实，即区域太小，以至于该区域对直方图的贡献与由噪声引起的灰度扩散相比无足轻重<br><img src="/2024/03/10/digital-image-processing/73.png"></li></ul><h4 id="通过边界特性选择阈值"><a href="#通过边界特性选择阈值" class="headerlink" title="通过边界特性选择阈值"></a>通过边界特性选择阈值</h4><ul><li>通过边界特性选择阈值<ul><li>如果直方图的各个波峰很高、很窄、对称，且被很深的波谷分开时，有利于选择阈值。</li><li>为了改善直方图的波峰形状，我们只把区域边缘的像素绘入直方图，而不考虑区域中间的像素。</li><li>用微分算子，处理图像，使图像只剩下边界中心两边的值</li></ul></li><li>通过边界特性选择阈值的<strong>优点</strong><ul><li>在前景和背景所占区域面积差别很大时， 不会造成一个灰度级的波峰过高，而另一过低。</li><li>边缘上的点在区域内还是区域外的概率是相等的，因此可以增加波峰的对称性。</li><li>基于梯度和拉普拉斯算子选择的像素，可以增加波峰的高度。</li></ul></li><li><strong>算法实现：</strong><br><img src="/2024/03/10/digital-image-processing/74.png"><br><img src="/2024/03/10/digital-image-processing/75.png"></li></ul><h4 id="基本自适应阈值"><a href="#基本自适应阈值" class="headerlink" title="基本自适应阈值"></a>基本自适应阈值</h4><ul><li>单一全局阈值存在的问题<ul><li>不均匀亮度图像无法有效分割</li></ul></li><li>方法<ul><li>将图像进一步细分为子图像，并对不同的子图像使用不同的阈值处理</li><li>解决的关键问题：如何将图像进行细分和如何为得到的子图像估计阈值</li><li>自适应阈值：取决于像素在子图像中的位置<br><img src="/2024/03/10/digital-image-processing/76.png"></li></ul></li></ul><h3 id="区域分割法"><a href="#区域分割法" class="headerlink" title="区域分割法"></a>区域分割法</h3><h4 id="区域生长"><a href="#区域生长" class="headerlink" title="区域生长"></a>区域生长</h4><ul><li>区域生长是根据预先定义的生长准则，将像素或子区域组合为更大区域的过程。</li><li>基本方法是从一组“种子”点开始，将与种子预先定义的性质相似的那些领域像素添加到每个种子上，来形成这些生长区域。<ul><li><strong>连通属性，终止规则</strong></li></ul></li><li>令$𝑓(𝑥, 𝑦)$ 表示一个输入图像；$𝑆(𝑥, 𝑦)$  表示一个种子阵列，阵列中种子点位置处为$1$，其他为$0$；$Q$表示在每个位置$(𝑥, 𝑦 ) $处的属性。<ol><li>在$𝑆(𝑥, 𝑦)$中寻找所有连通分量，并把每个连通分量腐蚀为一个像素；把找到的所有这种像素标记为$1$，把$S$中的所有其他像素标记为$0$</li><li>在坐标对$(𝑥, 𝑦 ) $处形成图像$𝑓_𝑄$：若输入图像在该坐标处满足给定的属性$Q$，则令$𝑓_𝑄(𝑥, 𝑦) &#x3D; 1$，否则令$𝑓_𝑄(𝑥, 𝑦) &#x3D;  0$</li><li>令$g$是这样形成的图像：即把$𝑓_𝑄$中为8连通种子点的所有1值点，添加到$S$中的每个种子点</li><li>用不同的区域标记（如1,2,3, ⋯ ）标记g中的每个连通分量。这就是由区域生长得到的分割图像</li></ol></li></ul><h4 id="区域分裂与聚合"><a href="#区域分裂与聚合" class="headerlink" title="区域分裂与聚合"></a>区域分裂与聚合</h4><ul><li>上一节是从一组种子点来生长区域。另一种方法是首先将一幅图像细分为一组任意的不想交的区域，然后聚合和&#x2F;或分裂这些区域</li><li>令R表示整幅图像区域，并选择一个属性Q。则区域分裂与聚合的算法过程如下：<ol><li>把满足$𝑄 (𝑅_𝑖) &#x3D; 𝐹𝐴𝐿𝑆𝐸$的任何区域𝑅𝑖分裂为4个不相交的象限区域</li><li>不可能进一步分裂时，对满足条件$𝑄( 𝑅_𝑗 ∪ 𝑅_𝑘) &#x3D; 𝑇𝑅𝑈𝐸$的任意两个邻接区域$𝑅_𝑗$和$𝑅_𝑘$进行聚合</li><li>无法进一步聚合时，停止操作</li></ol></li><li>习惯上要规定一个不能再进一步执行分裂的最小四象限区的尺寸<br><img src="/2024/03/10/digital-image-processing/67.png"></li></ul><h3 id="基于形态学分割"><a href="#基于形态学分割" class="headerlink" title="基于形态学分割"></a>基于形态学分割</h3><h4 id="分水岭分割法"><a href="#分水岭分割法" class="headerlink" title="分水岭分割法"></a>分水岭分割法</h4><ul><li>分水岭也称分水线&#x2F;水线，将图像看成三维地形表示</li><li>基本思想：<ul><li>假设在每个区域的最小值上打一个洞，并且让水通过洞以均匀的速率上升，从低到高淹没整个地形。当不同汇水盆地中上升的水聚集时，修建一个水坝来阻止这种聚合。水将达到在水线上只能见到各个水坝的顶部的程度。这些大坝的边界对应于分水岭的分割线<br><img src="/2024/03/10/digital-image-processing/65.png"><br><img src="/2024/03/10/digital-image-processing/66.png"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记</title>
      <link href="/2023/07/01/operating-system/"/>
      <url>/2023/07/01/operating-system/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="操作系统四个特征-并发-共享-虚拟-异步"><a href="#操作系统四个特征-并发-共享-虚拟-异步" class="headerlink" title="操作系统四个特征: 并发, 共享, 虚拟, 异步"></a>操作系统四个特征: 并发, 共享, 虚拟, 异步</h3><ul><li>并发性: 指计算机系统中同时存在着多个运行着的程序<br><strong>并发</strong>: 指两个或多个事件在<strong>同一时间间隔内</strong>发生。这些事件宏观上是同时发生的，但微观上是交替发生的<br><strong>并行</strong>: 指两个或多个事件在<strong>同一时刻</strong>同时发生<br>PS：能并行一定能并发</li><li>共享性: 指系统中的资源可供内存中<strong>多个并发执行的进程</strong>共同使用</li><li>虚拟性:<ul><li>空分复用(虚拟存储器)<blockquote><p>4G内存电脑拥有,同时运行超过4G运行空间的程序</p></blockquote></li><li>时分复用(虚拟处理器)<blockquote><p>CPU时间片轮转</p></blockquote></li></ul></li><li>异步性: 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。<br>并发与共享相辅相存, 前者缺一不可, 否则虚拟性与异步性显得毫无意义.</li></ul><h3 id="操作系统类型"><a href="#操作系统类型" class="headerlink" title="操作系统类型"></a>操作系统类型</h3><h5 id="单批道处理"><a href="#单批道处理" class="headerlink" title="单批道处理"></a>单批道处理</h5><p>引入<strong>脱机输入&#x2F;输出</strong>技术, 并由 <strong>监督程序</strong> 负责控制作业的输入输出</p><ul><li>优点:<br>缓解了一定程度的<strong>人机速度矛盾</strong>， 资源利用率有所提升</li><li>缺点:<br>内存中仅能 <strong>有一道程序运行</strong>，只有 该程序运行结束之后才 能调入下一道程序。<strong>CPU有大量的时间是在 空闲等待I&#x2F;O完成</strong>。资源 利用率依然很低。</li></ul><p>PS：由于<strong>I&#x2F;O技术栈</strong>实现<strong>多批道处理系统</strong>。批处理系统的最大缺陷：**<font color="#dd0000">不能人机交互</font>**</p><h5 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h5><p>计算机以<strong>时间片为单位轮流为各个用户&#x2F;作业服务</strong>，各个用户可通过终端与计算机进行交互</p><ul><li>优点:<br>用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li><li>缺点:<br><strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F; 作业服务一个时间片，不区分任务的紧急性</li><li>特征：<br>多路性，独立性，交互性，及时性</li></ul><h5 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h5><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，<br>并且要<strong>在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p><ul><li>优点:<br>能够优先响应一些紧急任务，某些紧急任务不需时间片排</li><li>分类:<br>硬实时系统, 必须在绝对严格规定时间内完成<br>软实时系统, 接受偶尔违反时间规定</li></ul><p>除了以上, 还有网络操作系统, 分布式操作系统, 分布式操作系统的主要特点是 分布性和并行性, 任何工作都可以分布在这些计算机上, 由它们并行, 协同完成这个任务</p><p>PS：CPU可以you多个核，多核处理器多线程</p><h3 id="操作系统运行环境和调用"><a href="#操作系统运行环境和调用" class="headerlink" title="操作系统运行环境和调用"></a><font color="#dd0000">操作系统运行环境和调用</font></h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>系统调用：用户在程序中调用操作系统的一些子功能。<br>子功能都是凡是与共享资源相关的功能，如：设备管理、文件管理、进程控制、进程通信、内存管理<br>系统调用相关处理在 <strong>核心态</strong> 处理</p><p><strong>调用流程</strong></p><ol><li>传递系统调用参数</li><li>执行陷入指令(<strong>用户态</strong>)<ul><li><strong>陷入指令</strong>在<strong>用户态</strong>执行, 执行陷入指令后立即引发<strong>内中断</strong>, 从而 CPU 进入<strong>核心态</strong></li><li>发出请求在<strong>用户态</strong>, 相应处理在<strong>核心态</strong></li><li>是唯一一个只能在用户态执行的指令, <strong>核心态不可执行</strong></li></ul></li><li>执行系统调用相应服务程序(<strong>核心态</strong>)</li><li>返回用户程序<br><img src="/2023/07/01/operating-system/2.png"></li></ol><p><strong>操作系统向用户提供的接口</strong>：<br>&emsp;用户接口：命令行、图形、批处理<br>&emsp;程序接口：系统调用</p><h4 id="操作系统状态"><a href="#操作系统状态" class="headerlink" title="操作系统状态"></a>操作系统状态</h4><p>两种处理器状态, 用程序状态寄存器 (PSW) 标记, 0 用户, 1 核心</p><ul><li><strong>用户态</strong>(目态): CPU 只能执行非特权指令</li><li><strong>核心态</strong>(管态): 特权指令, 非特权指令都可以执行<br>两种程序</li><li><strong>内核程序</strong>: 系统的管理, 两种指令都可以执行, 在<strong>核心态</strong>运行</li><li><strong>应用程序</strong>: 只能运行非特权指令, 在<em><strong>用户态</strong></em>执行</li></ul><p><em><strong>问题：<u>用户态, 核心态之间是怎么切换的?</u></strong></em><br>答：切换是通过<strong>中断</strong>实现的, 并且是<strong>唯一</strong>途径, 改变 <strong>程序状态字(PSW)</strong> 即可<br>用户态$\rightarrow$核心态：中断<br>核心态$\rightarrow$用户态：修改PSW<br>用户态可以触发中断，但中断处理只能在核心态中执行<br>PS：进程切换、调度既不可以在用户态发生，更不能执行</p><p><strong>中断类型</strong>(同计组)：<br><img src="/2023/07/01/operating-system/1.png"><br><strong>自陷</strong>是主动的，如陷入指令，将用户态转为核心态<br><strong>常见异常</strong>：非法操作码、地址越界、运算溢出、虚存系统缺页、陷入指令</p><p><strong>中断响应周期(中断隐指令)<strong>：PC(程序计数器)、PSW(程序状态寄存器)&emsp;可以</strong>用户态</strong><br><strong>中断服务程序(ISR)</strong>:通用寄存器&emsp;必须<strong>核心态</strong></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的定义和状态"><a href="#进程的定义和状态" class="headerlink" title="进程的定义和状态"></a>进程的定义和状态</h3><p><strong>程序段</strong>、<strong>数据段</strong>、<strong>PCB(进程控制块)<strong>三部分组成了</strong>进程实体(进程映像)</strong>, 一般情況下，我们把进程实体就简称为<strong>进程</strong>，<br>例如，所谓创建进程，<strong>实质上是创建进程实体中的PCB</strong>；而撤销进程，实质上是撤销进程实体中的PCB。<br>PS：PCB是进程存在的<strong>唯一标志</strong>！</p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul><li>创建态 (New), 进程正在被创建，操作系统为进程分配资源、初始化PCB</li><li>运行态 (Running), 占有CPU并在CPU上执行</li><li>就绪态 (Ready), 已经具备运行条件, 没有空闲CPU 还没有运行</li><li>阻塞态 (Wating&#x2F;Blocking), 因等待某一时间暂时不能运行</li><li>终止态 (Terminated), 进程正在从系统中撤销，操作系统会回收进程拥有的资源、撒销PCB*</li></ul><h4 id="进程转换"><a href="#进程转换" class="headerlink" title="进程转换"></a>进程转换</h4><ul><li>就绪态$\rightarrow$运行态：<strong>调度</strong></li><li>运行态$\rightarrow$就绪态：<strong>CPU没了①时间片用完了②更高优先级进程执行</strong></li><li>运行态$\rightarrow$阻塞态：<strong>申请其他资源、等待I&#x2F;O完成、读文件</strong><ul><li>申请其他资源：1.内存；2.I&#x2F;O；3.buffer；4.设备；5.临界资源；6.磁盘；7.执行p操作</li></ul></li><li>阻塞态$\rightarrow$就绪态：<strong>I&#x2F;O完成</strong><br><img src="/2023/07/01/operating-system/3.png"></li></ul><p>PS：父子进程相关</p><ol><li>父进程创建了子进程；</li><li>二者地位一样，有独立资源、独立空间。</li></ol><p><font color="#dd0000">进程不能共享虚拟地址空间、不能使用同一临界资源 </font>这一点同样针对上面的子父进程</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a><font color="#dd0000">进程管理</font></h3><h4 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1. 进程创建"></a>1. 进程创建</h4><h5 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h5><ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul><h5 id="引起进程创建的时间-相关事件"><a href="#引起进程创建的时间-相关事件" class="headerlink" title="引起进程创建的时间(相关事件)"></a>引起进程创建的时间(相关事件)</h5><ul><li>用户登录 — 分时系统中，用户登录成功，系统会建立为其建立一个新的进程(<strong>内核态</strong>)</li><li>作业调度 — 多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程(<strong>内核态</strong>)</li><li>提供服务 — 用户向操作系统提出某些请求时，会新建一个进程处理该请求(<strong>内核态</strong>)</li><li>应用请求 — 由用户进程主动请求创建一个子进程(<strong>用户态</strong>)</li></ul><h4 id="2-进程终止"><a href="#2-进程终止" class="headerlink" title="2. 进程终止"></a>2. 进程终止</h4><h5 id="创建过程-1"><a href="#创建过程-1" class="headerlink" title="创建过程"></a>创建过程</h5><ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父迸程或操作系统</li><li>删除PCB</li></ul><h5 id="引起进程创建的时间-相关事件-1"><a href="#引起进程创建的时间-相关事件-1" class="headerlink" title="引起进程创建的时间(相关事件)"></a>引起进程创建的时间(相关事件)</h5><ul><li>正常结束</li><li>异常结束</li><li>外泉干预</li></ul><h4 id="3-进程阻塞和唤醒"><a href="#3-进程阻塞和唤醒" class="headerlink" title="3. 进程阻塞和唤醒"></a>3. 进程阻塞和唤醒</h4><h5 id="进程的阻塞（即运行-rightarrow-阻塞）"><a href="#进程的阻塞（即运行-rightarrow-阻塞）" class="headerlink" title="进程的阻塞（即运行$\rightarrow$阻塞）"></a>进程的阻塞（即运行$\rightarrow$阻塞）</h5><ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul><h5 id="迸程的唤醒（即阻塞-rightarrow-就绪）"><a href="#迸程的唤醒（即阻塞-rightarrow-就绪）" class="headerlink" title="迸程的唤醒（即阻塞$\rightarrow$就绪）"></a>迸程的唤醒（即阻塞$\rightarrow$就绪）</h5><ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul><p>PS：<strong>基本步骤</strong></p><ul><li>找到其PCB</li><li>改变状态</li><li>进入新队列</li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>两个进程对共享空间的<strong>访问</strong>必须是<strong>互斥</strong>的（互斥访问通过操作系统提供的工具实现）</p><ol><li>基于数据结构<br>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信方式</strong></li><li>基于存储区<br> 在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制而不是操作系统。相比之下，这种共享方式速度更快，是一种高<strong>级通信方式</strong>。<br> <img src="/2023/07/01/operating-system/4.png"></li></ol><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>进程间的数据交换以<strong>格式化的消息(Message)<strong>为单位。进程通过</strong>操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换</strong>。</p><ul><li><strong>消息结构</strong><ul><li>消息头, 包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化信息</li><li>消息体</li></ul></li><li><strong>传递方式</strong><ul><li>直接传递, 消息直接挂到接收进程的消息缓冲队列上</li><li>间接传递, 消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统<br><img src="/2023/07/01/operating-system/5.png"></li></ul></li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ol><li>管道<strong>只能采用半双工通信</strong>，某一时间段内只能实现单向的传输。如果要<strong>实现双向同时通信，则需要设置两个管道</strong>。</li><li>各进程要<strong>互斥地访问管道</strong></li><li>数据以宇符流的形式与入管道<ul><li>当管道<strong>写满</strong>时，写进程的<strong>write()系统调用将被阻塞</strong>，等待读进程将数据取走，才能read()</li><li>当读进程将数据全部取走后，<strong>管道变空</strong>，此时读进程的<strong>read()系统调用将被阻塞</strong>，才能write()</li></ul></li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读<strong>进程最多只能有一个</strong>，否则可能会有读错数据的情况。<br> <img src="/2023/07/01/operating-system/6.png"></li></ol><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>同步</strong>：同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。<br><strong>互斥</strong>：互斥亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。<br><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源(许多物理设备，如打印机)<br><strong>临界区</strong>：访问临界资源的代码</p><h5 id="进程互斥原则"><a href="#进程互斥原则" class="headerlink" title="进程互斥原则"></a>进程互斥原则</h5><ul><li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li><strong>忙则等待</strong>。当己有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li><strong>有限等待</strong>对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）：</li><li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul><h4 id="实现临界区互斥方法"><a href="#实现临界区互斥方法" class="headerlink" title="实现临界区互斥方法"></a>实现临界区互斥方法</h4><h5 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h5><p><strong>1.单标志法</strong><br>两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一进程. 也就是说<strong>每个进程进入临界区的权限只能被另一进程赋予</strong><br><strong><font color="#dd0000">不满足空闲让进</font></strong>的互斥原则<br>访问顺序一定是<code>01010101...</code>, 当临界区空闲, 0 没有访问临界区时, <code>turn == 0 </code>, 1 需要访问但无法进入.<br>代码中“只有turn”</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.双标志先检查法</strong><br>先检查, 后上锁<br><strong><font color="#dd0000">不满足忙则等待</font></strong> 原则.<br>若 0, 1 两个进程并发执行, P0 结束while循环还未复制 flag[0] 时, 发生进程切换, P1 也可以进入临界区<br>代码中“有flag”</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// flag[i] = true 表示 i 进程想要进入临界区</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>  <span class="token comment">//true表示上锁</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.双标志后检查法</strong><br>先上锁, 后检查<br>P0 先执行<code>flag[0] = true</code> 后, 发生进程切换, P[1]执行<code> flag[1]</code>, 最后两个进程都不能进入临界区<br><strong><font color="#dd0000">不满足空闲让进和有限等待</font></strong> 互斥原则<br>代码中“有flag”</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// flag[i] = true 表示 i 进程想要进入临界区</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.Peterson 算法</strong><br>主动先让对方进入临界区<br>进程发生<strong>忙等待</strong>, <strong><font color="#dd0000">不满足让权等待</font></strong>互斥原则<br>代码中“有flag也有turn”</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// P0</span><span class="token keyword">void</span> <span class="token function">funcp0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1</span><span class="token keyword">void</span> <span class="token function">funcp1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h5><p><strong>1. 中断屏蔽</strong><br>&emsp;利用“开&#x2F;关中断”指令实现<br>&emsp;不适用于多处理机；只适用于内核进程<br><strong>2. 硬件指令</strong><br>&emsp;TestAndSet指令和Swap 指令<br><strong>硬件缺点</strong>：<br><strong><font color="#dd0000">不满足让权等待</font></strong>，还有 <strong><font color="#dd0000">饥饿</font></strong>。</p><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><font color="#dd0000">信号量机制</font></h4><p>信号量表示系统中某种资源的数量<br><strong>初值</strong>为资源总量<br><strong>当前值</strong>为资源可用(还剩)数量，若当前值为<strong>负数</strong>，其绝对值表示等待资源的进程数。<br>PS：<code>while</code>后面直接加”<code>;</code>“，分号表示空语句，表示忙等，就没有“让权等待”，也就不会主动放弃CPU。因为不让权，所以其它进程也不会阻塞。</p><h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><p>整数型变量, 表示某种资源的数量<br><strong><font color="#dd0000">会发生忙等, 不满足让权等待</font></strong>互斥原则</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S <span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    S <span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P0</span><span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    使用资源<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h5><p>没有申请到资源的进程会被挂起进入<strong>阻塞态</strong>, 所以<strong>不会发生忙等(让权等待满足)</strong>, <strong><font color="#dd0000">满足所有的互斥原则</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>          <span class="token comment">// 剩余资源数</span>    <span class="token keyword">struct</span> <span class="token class-name">process</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>  <span class="token comment">// 等待队列</span><span class="token punctuation">&#125;</span> semaphore<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">wait</span> <span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 原语操作</span>    S<span class="token punctuation">.</span>value <span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token function">block</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 资源数不够, 把进程挂到S的等待队列中, 进入阻塞态</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 原语操作</span>    S<span class="token punctuation">.</span>value <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 释放资源后, 还要进程在等待, 就将等待队列中阻塞的进程唤起</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>信号量定义位置决定是否互斥</p><table><thead><tr><th align="center"></th><th align="center">进程间</th><th align="center">线程间</th></tr></thead><tbody><tr><td align="center">进程外</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">进程内</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">线程内</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h5 id="信号量实现进程互斥-同步"><a href="#信号量实现进程互斥-同步" class="headerlink" title="信号量实现进程互斥, 同步"></a>信号量实现进程互斥, 同步</h5><p>将临界区资源视为一种特殊资源, 设置<strong>互斥信号量mutex</strong>, 初值为 1</p><p>PS:<br>对<strong>不同的临界资源</strong>需要设置<strong>不同的互斥信号量</strong><br><strong>P, V 操作必须成对出现</strong></p><p><strong>同步</strong>：<br> ①设置同步信号量S, 初始为0<br> ②在”前操作”之后执行V(S)<br> ③在”后操作”之前执行P(S)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Semaphore S <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    code <span class="token number">1</span><span class="token punctuation">;</span>    code <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    code <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    code <span class="token number">4</span><span class="token punctuation">;</span>    code <span class="token number">5</span><span class="token punctuation">;</span>    code <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="信号量解决同步互斥问题"><a href="#信号量解决同步互斥问题" class="headerlink" title="信号量解决同步互斥问题"></a><font color="#dd0000">信号量解决同步互斥问题</font></h5><p><strong>PV问题解题</strong></p><ol><li>有几类进程？————每类进程(几类人)对一个函数</li><li>在函数内部用中文描述$\Rightarrow$只做一个？不断重复？（<font color="#0090dd">加不加while(1)</font>）</li><li>每个动作之前需要$P$什么？————注意隐含的互斥(缓冲区的访问)，同时注意有$P$则则必有$V$</li><li>所有的$PV$写完之后再去定义信号量</li><li>检查多个$P$操作出现的地方是否可能<u>死锁</u>？<br>①对一个信号量的$P$之间无其它$P$，不可能死锁<br>②连续的$P$产生死锁，可以调节$P$顺序</li></ol><p><font color="#0000dd">往往容量(缓冲区)会设置两个信号量，一个$n$一个$0$，分别表示上限和下限。同时对其的操作(一般是中文操作)前后要加上$mutex$进行互斥访问</font><br><font color="#dd0000">无论题目中有没有提及都必须互斥访问</font><br><font color="#0000dd">与容量(缓冲区)容易混淆的是工具中介信号量。该容量只需设置一个$n$。特点是对其访问不用互斥。同时其量是定死的，没有凭空产生或消耗。例子：打水的水桶有三个。可以没有中文操作对其访问。</font><br><font color="#dd0000">PS：对工具资源的访问尤其需要注意$P$操作产生的死锁问题。往往是先对缓冲区$P$再对工具区$P$</font></p><p><strong>1.生产者-消费者问题</strong><br>改变互斥信号量mutex 在 同步信号量操作之间</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 互斥</span>semaphore empty <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token comment">// 同步</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 同步</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        把产品放入缓冲区<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">v</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        取出产品        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 使用产品</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.多生产者-消费者问题</strong><br>问题描述：<br>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放<br>橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。<br>只有盘子空时，爸爸或妈妈才<br>可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p><p>分析：<br>&emsp;1.父亲, 母亲: 生产者1, 2<br>&emsp;2.儿子, 女儿: 消费者1, 2<br>&emsp;3.公用一个临界区资源, 有 2 类信号量</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//可以省去, 缓冲区大于1 必须设置, 等于 1 可能不用设置</span>semaphore apple <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//盘子里有多少苹果</span>semaphore orange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//盘子里有多少橘子</span>semaphore plate <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//盘子里还可以放多少水果(缓冲区)</span><span class="token function">dad</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      准备一个苹果<span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      把苹果放入盘子<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">mom</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      准备一个橘子<span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      把橘子放入盘子<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">daughter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">P</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      从盘子中取出苹果<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>      吃掉苹果<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">son</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">P</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      从盘子中取出橘子<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>      吃掉橘子<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.服务者-被服务者问题</strong><br>该类型题特点：</p><ol><li>有类型需要等待；</li><li>也需要一个变量计数等待人数(也需要互斥访问)<br><font color="#dd0000">往往类似读写者问题有多个$count$(int count&#x3D;0;)</font></li><li>可能会有两个变量均用于同步，且值为$0$；一个用于实现无顾客服务人员等待，一个用于实现无服务人员顾客等待</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//设几个顾客在等待</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//对count互斥访问</span>semaphore rest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//同步 无顾客，服务人员等待</span>semaphore wait <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//同步 无服务人员，顾客等待</span><span class="token function">Sever</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         count<span class="token operator">--</span><span class="token punctuation">;</span>         叫号<span class="token punctuation">;</span>         <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">V</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒一个顾客</span>         理发<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span><span class="token punctuation">&#123;</span>         <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">P</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//服务人员休息，一定要在所有V操作后面</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">Customer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">></span>上限<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      离开<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      count<span class="token operator">++</span><span class="token punctuation">;</span>      排队取号<span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">V</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒一个服务人员</span>      <span class="token function">P</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待被服务，一定要在所有V操作后面</span>      被服务<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.吸烟者问题</strong><br>题目描述<br>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种料：烟草、纸和胶水。<br>三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供并给供应者进程应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore offer1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//桌上组合一的数量</span>semaphore offer2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//桌上组合二的数量</span>semaphore offer3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//桌上组合三的数量</span>semaphore finish <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//抽烟是否完成</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//用于实现“三个抽烟者轮流抽烟”</span><span class="token function">provider</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         组合一放到桌上<span class="token punctuation">;</span>         <span class="token function">V</span><span class="token punctuation">(</span>offer1<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         组合二放到桌上<span class="token punctuation">;</span>         <span class="token function">V</span><span class="token punctuation">(</span>offer2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         组合三放到桌上<span class="token punctuation">;</span>         <span class="token function">V</span><span class="token punctuation">(</span>offer3<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>       i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">;</span>      <span class="token function">P</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">smoker1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">P</span><span class="token punctuation">(</span>offer1<span class="token punctuation">)</span><span class="token punctuation">;</span>      从桌上拿走组合一；      卷烟；      抽掉；      <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">smoker2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">P</span><span class="token punctuation">(</span>offer2<span class="token punctuation">)</span><span class="token punctuation">;</span>      从桌上拿走组合二；      卷烟；      抽掉；      <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">smoker3</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">P</span><span class="token punctuation">(</span>offer5<span class="token punctuation">)</span><span class="token punctuation">;</span>      从桌上拿走组合三；      卷烟；      抽掉；      <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.读者写者问题</strong><br>有<strong>读者</strong>和<strong>写者</strong>两组并发进程，<br>共享一个文件，当两个或两个以上的读进程同时访问共享数据时不产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致<br>数据不一致的错误。因此要求：<br>&emsp;&emsp;1.允许多个读者可以同时对文件执行读操作；<br>&emsp;&emsp;2.只允许一个写者往文件中写信息；<br>&emsp;&emsp;3.任一写者在完成写操作之前不允许其他读者或写者工作；<br>&emsp;&emsp;4.写者执行写操作前，应让己有的读者和写者全部退出。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore rw <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 读写锁 </span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">// 记录正在访问的读者数量，特点，也要互斥访问</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 保证对 count 的互斥访问</span>semaphore w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 实现读写公平</span><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        写文件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//第一个人上锁</span>            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        读文件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//最后一个人解锁</span>            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>6.哲学家进餐问题</strong><br>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子己在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。<br>关键在于解决 <strong>死锁</strong>, 每个进程需要持有<strong>两个或两种以上的临界资源</strong><br>方法:<br>&emsp;&emsp;1.设定信号量代表拿筷子的人数, 最多让 4名哲学家同时拿筷子<br>&emsp;&emsp;2.奇数号先拿左边, 偶数号先拿右边<br>&emsp;&emsp;3.仅当一个哲学家左右两支筷子都可用时才允许抓筷子<br>实现<strong>一气呵成</strong>, 加一个 <strong>互斥信号量</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//定义资源</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">//保证获取资源一气呵成</span><span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//拿资源先上锁</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">P</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拿左</span>            <span class="token function">P</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 拿右</span>            <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//资源全拿到再解锁</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//资源全拿到再解锁</span>        <span class="token punctuation">&#125;</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//资源全拿到再解锁</span>        吃饭<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>管程是一种特殊的软件模块，有这些部分组成：<br>&emsp;&emsp;1.局部于管程的<strong>共享数据结构</strong>说明：<br>&emsp;&emsp;2.对该数据结构进行操作的<strong>一组过程</strong>；<br>&emsp;&emsp;3.对局部于管程的共享数据设置初始值的语句：<br>&emsp;&emsp;4.管程有一个名字。<br>管程的基本特征：<br>&emsp;&emsp;1.局部于管程的数据只能被局部于管程的过程所访问：<br>&emsp;&emsp;2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据；<br>&emsp;&emsp;3.<strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。<br>管程是段代码，可以<strong>互斥</strong>也可以<strong>同步</strong><br><font color="0000dd">管程的确能保证互斥性，但是是否允许多个读进程或写进程并发访问，取决于具体管程实现和应用需求</font><br><strong>一般允许多个读进程并发访问，但写操作是互斥的。</strong><br><strong>x.wait&#x2F;x.signal</strong> 类似于P&#x2F;V<br>但是x是无值的，wait是将其放入x的等待序列即将其阻塞，signal则是将因x阻塞的进程唤醒</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">monitor ProducerConsumer<span class="token punctuation">&#123;</span>    condition full<span class="token punctuation">,</span> empty<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>end monitor<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        item <span class="token operator">=</span> 生产一个产品<span class="token punctuation">;</span>        ProducerConsumer<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        item <span class="token operator">=</span> ProducerConsumer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        消费产品 item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进程与多线程"><a href="#进程与多线程" class="headerlink" title="进程与多线程"></a>进程与多线程</h3><p>进程：独立调度、资源分配(<strong>一直是资源分配的基本单位</strong>)<br>线程：将进程中的调度功能分离出来，让线程尽量不使用资源。也可共享进程内的所有，但别的线程不行。</p><h4 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h4><p>线程是一个<em><strong>基本的CPU执行单元，也是程序执行流的最小单位</strong></em>。</p><p>引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p><p>引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）<br>即, <strong>进程是资源分配的基本单位</strong>, <strong>线程是调度的基本单位</strong></p><ul><li>每个线程有一个线程ID, 线程控制块 (TCB)</li><li><strong>同一线程的切换, 不需要切换进程环境</strong></li><li>线程几乎不拥有系统资源</li><li>同一线程内进程共享进程的资源, 并且通信无需系统干预</li></ul><h4 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h4><ul><li>用户级线程 (User-Level Thread, ULT)<ul><li>用户级线程由应用程序通过线程库实现。</li><li>所有的线程管理工作都由应用程序负责（包括线程切换）</li><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明）<br><img src="/2023/07/01/operating-system/7.png"></li></ul></li><li>内核级线程 (Kernel-Level Thread, KLT, 内核支持的线程)<ul><li>内核级线程的管理工作由操作系统内核完成。</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。<br><img src="/2023/07/01/operating-system/8.png"><br>在同时支持 ULT 和 KLT 的 OS 中, 可以用 n个 ULT 映射到 m个 KLT 上, n≥m<br><img src="/2023/07/01/operating-system/9.png"><br>PS: <strong>只有内核级线程才是处理机分配的单位</strong></li></ul></li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul><li>多对一模型：<ul><li>多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li></ul></li><li>一对一模型:<ul><li>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul></li><li>多对多模型:<ul><li>n用户及线程映射到 m个内核级线程 (n≥m)。每个用户进程对应 m个内核级线程。</li><li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li></ul></li></ul><h3 id="处理机调度算法"><a href="#处理机调度算法" class="headerlink" title="处理机调度算法"></a><font color="#dd0000">处理机调度算法</font></h3><p>一个作业从提交开始直到完成，往往要经历以下三级调度。<br><img src="/2023/07/01/operating-system/10.png"><br><img src="/2023/07/01/operating-system/11.png"></p><h5 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h5><ul><li>主动放弃<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞 (i&#x2F;o)</li></ul></li><li>被动放弃<ul><li>分给进程的时间片用完</li><li>有更紧急的事要处理 (I&#x2F;O)</li><li>有更高优先级的进程进入队列</li></ul></li><li>不能进行<ul><li>处理中断时</li><li>进程在操作系统内核程序临界区中</li><li>在原子操作中</li></ul></li></ul><h4 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h4><p><strong>CPU利用率</strong><br>CPU 利用率 &#x3D; $\frac{忙碌时间}{总时间}$</p><p><strong>系统吞吐量</strong><br>单位时间内完成作业的数量<br>系统吞吐量 &#x3D; $\frac{总共完成多少作业}{总共花了多少时间}$</p><p><strong>周转时间</strong><br>指<strong>从作业被提交给系统开始</strong>, 到<strong>作业完成为止</strong>这段时间间隔<br>包括四个部分<br>&emsp;1.作业在外存后备队列上等待作业调度（高级调度）的时间、<br>&emsp;2.进程在就绪队列上等待进程调度（低级调度）的时间、<br>&emsp;3.进程在CPU上执行的时间、<br>&emsp;4.进程等待I&#x2F;O操作完成的时间。<br>后三项在一个作业的整个处理过程中，可能发生多次。</p><p><strong>作业周转时间</strong> &#x3D; 作业完成时间 − 作业提交时间</p><p><strong>平均周转时间</strong> &#x3D; $\frac{各作业周转时间之和}{作业数}$</p><p><strong>带权周转时间</strong> &#x3D; $\frac{作业周转时间}{作业实际运行时间}$</p><p><strong>平均带权周转时间</strong> &#x3D; $\frac{各作业带权周转时间之和}{作业数}$</p><p><strong>等待时间</strong><br>对于进程, 就是在处理机上等待时间总和<br>对于作业, 还要计算上作业在外存等待队列上等待的时间</p><p><strong>响应时间</strong><br>从用户提交请求到首次产生响应所产生的时间</p><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a><font color="#dd0000">调度算法</font></h4><h5 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 (FCFS)"></a>先来先服务 (FCFS)</h5><ul><li>思想: 先来先得</li><li>规则: 按照到达先后顺序服务</li><li>作业&#x2F;进程调度: 都能使用, 作业调度考虑谁先到后背队列, 进程调度考虑谁先到就绪队列</li><li>抢占: <strong>非抢占式</strong></li><li>优点: 公平, 实现简单</li><li>缺点: <strong>对长作业有利, 短作业不利</strong>；<strong>有利于CPU繁忙型作业，不利于I&#x2F;O繁忙型作业</strong></li><li>饥饿: <strong>不会导致饥饿</strong></li><li>等待时间 &#x3D; 周转时间 - 运行时间 - I&#x2F;O 操作时间</li></ul><h5 id="短作业优先-SJF-最短剩余时间优先-SRTN"><a href="#短作业优先-SJF-最短剩余时间优先-SRTN" class="headerlink" title="短作业优先 (SJF), 最短剩余时间优先 (SRTN)"></a>短作业优先 (SJF), 最短剩余时间优先 (SRTN)</h5><ul><li>思想: 追求最少的平均等待时间, 平均周转时间, 平均带权周转时间</li><li>规则: 最短的作业&#x2F;进程优先得到服务(服务时间最短)</li><li>作业&#x2F;进程调度: 两者都可以, 用于进程时称为 “短进程优先 (SPF, Shortest Process First)” 算法</li><li>抢占: 默认<strong>非抢占式</strong>, 也有<strong>抢占式—最短剩余时间优先算法</strong> (SRTN, Shortest Remaining Time Next)</li><li>优点: “最短” 平均等待时间, 周转时间</li><li>缺点: <strong>对短作业有利, 长作业不利</strong></li><li>饥饿: <strong>会发生饥饿</strong></li></ul><h5 id="高响应比优先算法-HRRN"><a href="#高响应比优先算法-HRRN" class="headerlink" title="高响应比优先算法 (HRRN)"></a>高响应比优先算法 (HRRN)</h5><ul><li>思想: 总和考虑等待时间和要求服务时间</li><li>规则: 每次调度时计算各个作业&#x2F;进程的响应比, 选择最高的来服务<ul><li><strong>响应比</strong> &#x3D; $\frac{等待时间+要求服务时间}{要求服务时间}$</li></ul></li><li>作业&#x2F;进程调度: 都能使用</li><li>抢占: <strong>非抢占式</strong>, 当前运行作业&#x2F;进程主动放弃处理机才进行调度</li><li>优点: 综合考虑, 结合了 SJF 和 FCFS 的优点</li><li>缺点: 无</li><li>饥饿: <strong>不会导致饥饿</strong></li></ul><p>高响应比优先算法：</p><ul><li>非抢占式的调度算法，只有当前运行的进程主动放弃 CPU 时(正常&#x2F;异常完成，或主动阻塞），才需要进<br>行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</li></ul><p><img src="/2023/07/01/operating-system/12.png"></p><h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><ul><li>思想: 根据任务紧急程度来调度</li><li>规则: 每个任务有自己的优先级, 调度时选择优先级最高的</li><li>作业&#x2F;进程调度: 都可以, 甚至还能用于 I&#x2F;O 调度</li><li>抢占: <strong>抢占式, 非抢占式均可</strong>, 抢占式时就绪队列发生变化就可能要调度, 否则主动放弃处理机时调度</li><li>优点: 优先级区分紧急程度, 适用实时操作系统</li><li>缺点: 一直有高优先级进入会有饥饿</li><li>饥饿: <strong>导致饥饿</strong></li></ul><p>同优先级, 选择先进来的</p><p>优先级可以动态改变:</p><ul><li>静态优先级: 进程创建后, 优先级一直不变</li><li>动态优先级: 创建进程有个初始值, 之后根据情况动态调整</li></ul><p>通常策略</p><ul><li>通常<strong>系统进程</strong>优先级 <strong>高于</strong> <strong>用户进程</strong></li><li><strong>前台(交互)进程</strong>优先级 <strong>高于</strong> <strong>后台(非交互)进程</strong></li><li>操作系统<strong>更偏好I&#x2F;O型进程(I&#x2F;O繁忙型进程)</strong>, 相对的是<strong>计算型进程(CPU繁忙进程)</strong>, 两者可以并行, 选择更早进行 I&#x2F;O 可以更优</li></ul><p>动态策略</p><ul><li>如果某进程在就绪队列中<strong>等待了很长时间</strong>，则可以适当<strong>提升</strong>其优先级</li><li>如果某进程占用<strong>处理机运行了很长时间</strong>，则可适当<strong>降低</strong>其优先级</li><li>如果发现一个进程<strong>频繁地进行I&#x2F;O操作</strong>，则可适当<strong>提升</strong>其优先级</li></ul><h5 id="时间片轮转-RR"><a href="#时间片轮转-RR" class="headerlink" title="时间片轮转 (RR)"></a>时间片轮转 (RR)</h5><ul><li>思想: 公平轮流服务, 每个进程在一定时间间隔内都得到响应</li><li>规则: 按照各进程到就绪队列顺序, 轮流让各进程执行一个 时间片 (如100ms), 时间片结束未执行完成将被剥夺处理机, 放到队尾</li><li>作业&#x2F;进程调度: <strong>进程调度</strong>, 作业放入内存建立了进程才能被分配时间片</li><li>抢占: <strong>抢占式</strong>, 时钟装置产生<strong>时钟中断</strong>进行时间片轮转</li><li>优点: 公平,响应快, 适用分时操作系统</li><li>缺点: 高频率进程切换, 不区分任务紧急程度</li><li>饥饿: <strong>不会导致饥饿</strong></li></ul><p>同一时刻两个进程 A 和 B, A 刚下处理机, B 刚进入队列, <strong>默认</strong> B 先轮转时间片<br>如果<strong>时间片太大</strong>, <strong>退化为FCFS</strong>, 会<strong>增大进程响应时间</strong><br>如果<strong>时间片太小</strong>, <strong>进程切换频繁</strong>, 切换进程会花费大量时间<br>一般来说, 设计时间片要让切换进程的开销占比<strong>不超过 1%</strong><br>时间片大小影响因素：系统响应时间、就绪队列进程数、系统处理能力</p><h5 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h5><ul><li>思想: 对其他算法的折中考虑</li><li>规则:<ul><li>设置多级就绪队列, 优先级<strong>从高到低</strong>, 时间片<strong>从小到大</strong></li><li>新进程到达时<strong>先进入第1级</strong>队列, 按FCFS原则排队等待时间片, 如果用完时间片还未结束, 进入下一级队列队尾, 如果已经在最低级队列, 则重新放回队尾</li><li>只有<strong>第k级</strong>队列为空, 才会为 k+1 级队列分配时间片</li></ul></li><li>作业&#x2F;进程调度: <strong>用于进程调度</strong></li><li>抢占: <strong>抢占式</strong>, 抢占式的算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，<strong>原来运行的进程放回 k 级队列队尾</strong>。</li><li>优点: 结合了前面所有调度算法的优点, 并且对于 CPU密集型进程, I&#x2F;O密集型进程可以调整偏好程度 (如: 将因 I&#x2F;O 阻塞的进程重新放回原队列, 这样可以保证 I&#x2F;O 进程保持较高优先级)</li><li>缺点: 无明显缺点</li><li>饥饿: <strong>会导致饥饿</strong><br><img src="/2023/07/01/operating-system/13.png"></li></ul><p><img src="/2023/07/01/operating-system/14.png"></p><h3 id="死锁和处理"><a href="#死锁和处理" class="headerlink" title="死锁和处理"></a>死锁和处理</h3><p><strong>死锁定义</strong></p><ul><li><strong>死锁</strong>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li><strong>饥饿</strong>：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先 （SPF）算法<br>中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”而发生长进程</li><li><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是<br>程序员故意设计的。</li></ul><p><img src="/2023/07/01/operating-system/15.png"></p><h4 id="死锁发生必要条件"><a href="#死锁发生必要条件" class="headerlink" title="死锁发生必要条件"></a>死锁发生必要条件</h4><p>产生死锁<strong>必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生</strong>。</p><ol><li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。<br>像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</li><li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出子新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己己有的资源保持不放。</li><li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程己获得的资源同时被下一个进程所请求。</li></ol><p>注意！<strong>发生死锁时一定有循环等待</strong></p><ul><li>但是发生循环等待时未必死锁（<strong>循环等待是死锁的必要不充分条件</strong>）, 如果同类资源数大于 1，则即使有循环等待，也未必发生死锁。</li><li>但如果系统中每类资源都只有 1个，那循环等待就是死锁的充分必要条件了。</li></ul><p><strong>死锁的处理策略</strong><br>&emsp;&emsp;<strong>预防死锁</strong>。破坏死锁产生的四个必要条件中的一个或几个。<br>&emsp;&emsp;<strong>避免死锁</strong>。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）<br>&emsp;&emsp;<strong>死锁的检测和解除</strong>。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p><h4 id="死锁处理策略——死锁预防"><a href="#死锁处理策略——死锁预防" class="headerlink" title="死锁处理策略——死锁预防"></a>死锁处理策略——死锁预防</h4><p>限制条件苛刻，实现简单，但系统效率低、资源利用率低</p><ol><li>破坏互斥<br>允许资源共享。优先资源不能共享，用SPOOLing技术解决</li><li>破坏不剥夺条件<br>方案一：申请不到资源就放弃<br>方案二：将想要的资源强行剥夺。</li><li>破坏请求和保持条件<br>申请后一次性满足其所需资源，不满足就不执行</li><li>破坏循环等待条件<br>顺序资源分配：首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</li></ol><h4 id="死锁处理策略——死锁避免"><a href="#死锁处理策略——死锁避免" class="headerlink" title="死锁处理策略——死锁避免"></a><font color="#dd0000">死锁处理策略——死锁避免</font></h4><p>限制资源分配的顺序</p><p>系统安全状态<br><strong>安全序列</strong>：就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就<strong>可能</strong>发生<strong>死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p><p>经典例题：n 个资源，k 个进程，每个进程最多要 m 个资源<br>&emsp;不会死锁：k(m-1) &lt; n<br>&emsp;会锁：k(m-1) ≥ n</p><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p><strong>安全性算法</strong><br><img src="/2023/07/01/operating-system/16.png"><br><strong>银行家算法</strong><br><strong>数据结构</strong></p><ul><li>长度为 m的一维数组 Avalible 表示还有多少可用的资源</li><li>n∗m矩阵 Max 表示各进程对资源的最大需求数</li><li>n∗m矩阵 Allocation 表示已经给各进程分配了多少资源</li><li>Max−Allocation&#x3D;Need矩阵表示各进程最多还需要多少资源</li><li>用长度为 m的一维数组 Request 表示进程此次申请的各种资源数</li></ul><p><strong>步骤</strong></p><ol><li>检查此次申请是否超过声明的最大需求数</li><li>检查此时系统剩余可用资源是否满足要求</li><li>试探分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ol><p><img src="/2023/07/01/operating-system/17.png"></p><h4 id="死锁处理策略——检测与解除"><a href="#死锁处理策略——检测与解除" class="headerlink" title="死锁处理策略——检测与解除"></a>死锁处理策略——检测与解除</h4><p>建立<strong>资源分配图</strong><br><img src="/2023/07/01/operating-system/18.png"><br>R $\rightarrow$ P：已经分配的资源<br>P $\rightarrow$ R：申请资源<br><strong>检测算法</strong>：</p><ol><li>找到一个既不是孤点也不阻塞的点， 消除其所有边</li><li>消除后释放的资源可以让某些阻塞进程被唤醒，然后继续消除这些进程的边。</li></ol><p><strong>总结简化过程</strong>：<strong>当P进程所有P $\rightarrow$ R的边可以被满足时，则消去该P的所有边</strong></p><p><strong>死锁定理</strong><br>如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统发生<strong>死锁</strong></p><p><strong>死锁解除</strong><br>PS： 并不是所有进程都是死锁状态，用<strong>检测算法化简资源分配图后</strong>，还<strong>连着边的进程就是死锁进程</strong>。</p><p>主要方法：<br>&emsp;&emsp;1.<strong>资源剥夺法</strong>。挂起（放外存）某些进程，抢占资源重新分配给其他进程。后续注意饥饿<br>&emsp;&emsp;2.<strong>撤销进程法</strong>（终止进程）。付出代价可能很大，前功尽弃，但实现简单<br>&emsp;&emsp;3.<strong>进程回退法</strong>, 让死锁进程回退到足以避免死锁的地步，需要系统记录进程历史信息。</p><p><em><strong>问题：<u>如何决定“对谁动手” ？</u></strong></em><br>答：<br>&emsp;进程优先级来看（越低先牺牲）<br>&emsp;已执行多长时间（越短先牺牲）<br>&emsp;还要多久能结束（越久先牺牲）<br>&emsp;进程已经使用了多少资源(更多先牺牲)<br>&emsp;进程是交互式还是批处理式（优先批处理）</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理基本概念"><a href="#内存管理基本概念" class="headerlink" title="内存管理基本概念"></a>内存管理基本概念</h3><p>逻辑地址如何映射物理地址<br><img src="/2023/07/01/operating-system/19.png"></p><h4 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h4><ol><li>操作系统负责<strong>内存空间的分配与回收</strong></li><li>提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></li><li>提供地址转换功能，负责程序的<strong>逻辑地址</strong>与<strong>物理地址</strong>的转换</li><li>提供<strong>内存保护</strong>，保证各进程在各自顾存储空间内运行，互不干扰<ul><li>在CPU设置一对<strong>上、下限寄存器</strong>，判断寻址合法</li><li>采用<strong>重定位寄存器（基址寄存器）</strong>和界<strong>址寄存器（限长寄存器)</strong> 进行越界检查 , 界址寄存器中存放进程的<strong>最大逻辑地址</strong></li></ul></li></ol><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><p>为用户进程分配的一定是要一个连续的内存空间</p><ul><li>内部碎片：分配给某进程的内存区域中，某些部分没有用上</li><li>外部碎片：是指内存中的某些空闲分区由于太小而难以利用<br>使用 <strong>紧凑（Compacation)</strong> 技术解决外部碎片</li></ul><p><strong>单一分配</strong><br>内存被分为<strong>系统区和用户区</strong><br>内存中<strong>只有一道用户程序</strong></p><ul><li>优点：<ul><li>实现简单；</li><li>无外部碎片；</li><li>可以采用覆盖技术扩充内存；</li><li>不一定需要内存保护;</li></ul></li><li>缺点：<ul><li>只能用于单用户，单任务操作系统</li><li>有<strong>内部碎片</strong></li><li>存储器利用效率极低</li></ul></li></ul><p><strong>固定分区分配</strong><br>将用户空间划分为<strong>若干个固定大小的分区</strong>，在每<strong>个分区只装入一道作业</strong></p><p>操作系统需要建立一个数据结构—<strong>分区说明表</strong>，来实现各个分区的分配与回。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<strong>大小、起始地址、状态（是否已分配）</strong>。</p><ul><li>分区大小相等<ul><li>缺乏灵活性</li><li>使用与用一台计算机控制多个相同对象</li></ul></li><li>分区大小不等<ul><li>增加了灵活性，可以满足不同大小的进程需求</li></ul></li><li>优点：实现简单，无外部碎片</li><li>缺点：<ul><li>用户程序太大，需要覆盖技术来解决但又会降低性能</li><li>会产生内部碎片，内存利用率低</li></ul></li></ul><p><strong>动态分区分配</strong><br><strong>动态分区分配</strong>又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB..)</p><p>数据结构：<br>&emsp;1.空闲分区表<br>&emsp;2.空闲分区链<br>注意内存回收时的各种情况，对分区表的修改情况<br><strong>无内部碎片，有外部碎片</strong></p><h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p><strong>算法思想</strong>：每次都<strong>从低地址开始查找</strong>，找到第一个能满足大小的空闲分区<br><strong>如何实现</strong>：<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p><strong>算法思想</strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区<br><strong>如何实现</strong>：空闲分区<strong>按容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。<br><strong>缺点</strong>：每次选最小的分区分配，会留下越来越多，很小的，难以利用的内存块。<strong>因此会产生很多的外部碎片</strong></p><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p><strong>算法思想</strong>：为了解決最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。<br><strong>如何实现</strong>：空闲分区<strong>按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。<br><strong>缺点</strong>：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果<strong>之后有“大进程”到达，就没有内存分区可用了</strong></p><h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p><strong>算法思想</strong>：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。<br><strong>如何实现</strong>：空闲分区<strong>以地址递增的顺序排列（可排成一个循环链表）</strong>,每次分配内存时从<strong>上次查找结束的位置开始查找空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区.<br><img src="/2023/07/01/operating-system/20.png"></p><h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a><font color="#dd0000">基本分页存储管理</font></h3><p><strong>分页地址转换</strong><br>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个 <strong>“页框”</strong>，或称<strong>“页帧”</strong><br><strong>“内存块”、“物理块”</strong> 。每个页框有一个编号，即 <strong>“页框号”，“内存块号”，“页帧号”、“物理块号”</strong>，页框号从0开始</p><p>将用户进程的地址空间也分为<strong>与页框大小相等</strong>的一个个区域称为 <strong>“页”</strong>或<strong>“页面”</strong>。每个页面也有一个编号，即“页号”。<strong>页号也是从0开始</strong>。(注：进程的最<strong>后一个页面可能没有一个页框那么大</strong>。因此，<strong>页框不能太大，否则可能产生过大的内部碎片</strong>）<br>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系。</p><p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><ol><li>要算出逻辑地址对应的页号</li><li>要知道该页号对应页面在内存中的起始地址</li><li>要算出逻辑地址在页面内的“偏移量”</li><li>物理地址&#x3D;页面始址 ＋页内偏移量</li></ol><p>结论：如果每个页面大小为 2kB，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号<br>因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p><p><strong>页表</strong></p><ol><li>一个进程对应一张页表</li><li>进程的每一页对应一个页表项</li><li>每个页表项由“页号”和“块号” 组成</li><li>页表记录进程页面和实际存放的内存块之间的对应关系</li><li>每个页表项的长度是相同的，页号是“隐含”的<br><img src="/2023/07/01/operating-system/21.png"></li></ol><p><strong>总结</strong>：<br><strong>页表长度M</strong>：有多少个页表项(即多少页)<br><strong>页表项长度</strong>：每个页表项占多少空间<br><strong>页面大小</strong>：一个页面有多少空间&emsp;<strong>页表项长度×页表长度</strong> &#x3D; $2^{页内偏移量}$(若是有多个页面则不一定)</p><p><strong>具有快表的地址变换机构</strong><br><strong>快表</strong>，又称<strong>联想寄存器 (TLB)<strong>，是一种访</strong>问速度比内存快很多</strong>的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为<strong>慢表</strong>。以加速地址变换的过程<br><img src="/2023/07/01/operating-system/22.png"></p><p><strong>例题</strong>：访问一次快表消耗 1 us, 内存 100 us, TLB命中率为 90%, 平均耗时？<br><strong>答</strong>：(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 &#x3D; 111 us<br>都至少要访问一次内存</p><p><strong>例题</strong>：<br><img src="/2023/07/01/operating-system/23.png"><br>A：逻辑地址<br>L：页面大小<br><strong>页号P</strong>：P&#x3D;A&#x2F;L<br><strong>页内偏移量</strong>：W &#x3D; A%L<br>**页号P所对应的页表项地址(物理地址)**：页表始址F+页号P×页表项长度<br><strong>物理地址E</strong>：E&#x3D;b×L+W。b是该页表项内容即物理块号</p><p>**缺页异常处理(有效位为0)**：调页+读磁盘<br>根据页表中该表的外存地址找到所对应的磁盘块，读入页框，修改页表中的块号&#x2F;页框号。<br>如果页框满了，还需淘汰页<br>调页表一般页直接加入到TLB中，下一次访问直接访问快表</p><h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><p><img src="/2023/07/01/operating-system/24.png"><br>段页对比：</p><ul><li><strong>分段</strong>比分页<strong>更容易实现信息的共享与保护</strong></li><li>不能被修改的代码称为<strong>纯代码或可重入代码（不属于临界资源）</strong>，这样的代码是可以共享的。改的代码是不能共享的 （比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</li></ul><p>逻辑地址结构: (段号， 页号， 页内偏移量)</p><p>每个段对应段表项，各表项长度相同段表组成： (段号（隐含）、页表长度、页表存放地址)</p><p>每个页对应一个页表项，页表组成：（页号（隐含）、页面存放的内存块号）<br><img src="/2023/07/01/operating-system/25.png"></p><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul><li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</li><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</li><li>在操作系统的管理下，，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</li></ul><p>传统内存管理方式：</p><ul><li>一次性：作业必须一次性装入内存后才能运行</li><li>驻留性：作业被装入内存，就会一直驻留在内存中</li></ul><p>虚拟内存：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存.</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虛拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul><p>虚存大小：min{$2^{MAR}$，内存+外存}</p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p>请求分页存储管理与基本分页存储管理的主要区别：</p><ul><li>在程序执行过程中，当<strong>所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</strong>。</li><li>若内存空间不够，由<strong>操作系统负责将内存中暂时用不到的信息换出到外存</strong>。</li></ul><p>请求页表新增增加4个字段：</p><ol><li>状态位：是否已经调入内存</li><li>访问字段：记录最近访问过几次或者上次访问的时间，供置换算法使用</li><li>修改位：调入内存后是否被修改</li><li>外存地址：页面在外存中的存放位置</li></ol><p><strong>缺页中断机构</strong><br>在请求分页系统中，每当要访问的<strong>页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的缺页<strong>中断处理程序处理中断</strong>。<br>PS：一条指令执行过程中可能产生多次缺页中断<br><strong>需要磁盘I&#x2F;O</strong><br>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列。</p><ul><li>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项。</li><li>如果内存中<strong>没有空闲块</strong>，，则由页<strong>面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</li></ul><p>需要<strong>修改页表</strong><br>缺页中断与当前指令有关， 属于<strong>内中断</strong></p><p><strong>地址变换机构</strong><br>新增步骤：</p><ol><li>查到页表项判断是否调入内存</li><li>页面置换（需要调入页面，但没有空闲内存块）</li><li>需要修改请求页表中新增的表项</li></ol><p>抖动：<strong>频繁</strong>页面调度。表现为CPU利用率低，I&#x2F;O利用率高。原因为内存小，算法不好。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法 (OPT)"></a>最佳置换算法 (OPT)</h4><p>思想： 每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>。<br><strong>缺页中断次数</strong> ≥<strong>页面置换次数</strong><br>缺点：最佳置换算法是<strong>无法实现</strong>的</p><h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法 (FIFO)"></a>先进先出置换算法 (FIFO)</h4><p>思想：每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong><br><strong>Belady 异常</strong>—当为进程分配的物理块数增大时，缺页次数不减反增。<br><strong>只有FIFO算法发生Belady异常</strong>, 实现简单，但不适应，<strong>算法性能差</strong></p><h4 id="最近最久未使用置换算法（LRU"><a href="#最近最久未使用置换算法（LRU" class="headerlink" title="最近最久未使用置换算法（LRU)"></a>最近最久未使用置换算法（LRU)</h4><p>思想：每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong><br>实现：用<strong>访问字段记录该页面上次被访问以来所经历的时间t</strong>，每次要淘汰一个页面选择 t最大的<br>做题时，若淘汰页面，逆向检查此时内存中的几个页面号。逆<strong>向扫描过程中最后一个出现的页号就是要淘汰的页面</strong><br>缺点： 算法<strong>性能好</strong>， 但是<strong>实现困难，开销大</strong></p><h4 id="时钟置换算法-CLOCK-最近未用算法，NRU"><a href="#时钟置换算法-CLOCK-最近未用算法，NRU" class="headerlink" title="时钟置换算法 (CLOCK, 最近未用算法，NRU)"></a>时钟置换算法 (CLOCK, 最近未用算法，NRU)</h4><h5 id="简单CLOCK"><a href="#简单CLOCK" class="headerlink" title="简单CLOCK"></a>简单CLOCK</h5><ol><li>首次被装入或访问，置1；</li><li>被替换时，指针指向被替换的下一个(最开始指向第1帧，只有被替换的指针才移动)</li><li>为0，置换；为1，置0；</li><li>拖全为1，则将队首置换<br><img src="/2023/07/01/operating-system/26.png"></li></ol><h5 id="改进CLOCK"><a href="#改进CLOCK" class="headerlink" title="改进CLOCK"></a>改进CLOCK</h5><p>增加一个字段修改位M，（访问位A，修改位M）</p><ul><li>第一次扫描：从当前位置开始扫描到第一个 (0, 0) 的帧用于置换，不修改标志位</li><li>第二次扫描：查找第一个 (0, 1) 的帧用于置换，扫描过的帧访问位设0</li><li>第三次扫描：查找第一个 (0, 0) 用于置换，不修改标志位</li><li>第四次扫描：查找第一个 (0, 1) 的帧用于置换</li></ul><p>优先级：</p><ul><li>1类 A&#x3D;0，M&#x3D;0；最近没访问且没修改，最先置换</li><li>2类 A&#x3D;0，M&#x3D;1；最近没访问，但修改，其次</li><li>3类 A&#x3D;1，M&#x3D;0；最近访问过，但没修改，不淘汰</li><li>4类 A&#x3D;1，M&#x3D;1；最近访问过，且修改，不淘汰(后两类会变成前两类)</li></ul><p><strong>工作集</strong><br>在某段时间间隔内，进程访问页面的集合<br>工作集由<strong>时间t</strong>和<strong>工作集合窗口大小</strong>确定</p><p>例：1 4 |5 3 5 3 2| 2 1 1 1 ，窗口大小$\triangle$&#x3D;5<br>工作集为{5,3,2}</p><p>当所有进程工作集之和<strong>超过了</strong>可用的<strong>物理快总数</strong>，则操作系统会<strong>暂停一个进程</strong>，将其页面调出并将物理块分配给其他进程，<strong>防止抖动</strong>。</p><p>PS：缺页<strong>不等同</strong>于置换次数</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件管理概念"><a href="#文件管理概念" class="headerlink" title="文件管理概念"></a>文件管理概念</h3><p>文件打开，操作系统将 ①<strong>文件控制信息</strong> ②<strong>FCB</strong> ③<strong>文件的属性</strong> 逐步读入内存</p><p><strong>文件的属性</strong></p><ul><li>文件名：同目录无重名文件</li><li>标识符：对用户无可读性，操作系统用于区分文件的内部名称</li><li>类型：指明文件的类型</li><li>位置：文件存放的路径（用户使用）、在外存中的地址（操作系统使用，用户不可见）</li><li>大小：文件大小</li><li>创建信息、上次修改时间、文件所有者信息</li><li>保护信息：对文件进行保护的访问控制信息</li></ul><p><strong>文件控制块FCB</strong><br>目录本身是有结构文件，由一条条记录组成，每个记录都是放在该目录的一个文件<br><strong>FCB(File Control Block)</strong> 的有序集合是 “文件目录”。一个FCB就是一个文件<strong>目录项</strong><br>FCB 中包含了文件的基本信息（<strong>文件名、物理地址</strong>、逻辑结构、物理结构等），存取控制信息(访问存取权限)，使用信息(建立时间、修改时间)。</p><p>需要对目录进行哪些操作？</p><ol><li>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li><li>创建文件：创建一个新文件时，需要再所属目录中新增一个目录项</li><li>删除文件：当删除一个文件时需要在目录中删除相应的目录项</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li><li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</li></ol><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>为了加快文件检索速度<br>删除文件：<br>删除文件不会删除其所在的文件夹<br>会删除FCB、磁盘释放空间，但不会删除快捷方式</p><h3 id="文件物理结构-文件分配方式"><a href="#文件物理结构-文件分配方式" class="headerlink" title="文件物理结构(文件分配方式)"></a><font color="#dd0000">文件物理结构(文件分配方式)</font></h3><p>在很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong></p><p>外存管理中，<strong>文件的逻辑地址也被分为了一个一个的文件块</strong><br>逻辑地址形式 <strong>（逻辑块号，块内地址）</strong></p><h4 id="磁盘分配方法"><a href="#磁盘分配方法" class="headerlink" title="磁盘分配方法"></a>磁盘分配方法</h4><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><p><strong>每个文件在磁盘上占有一组连续的块</strong></p><ul><li>转换时，只关心 <strong>逻辑块号&lt;-&gt;物理块号</strong></li><li>验证逻辑块号是否小于物理块长度</li><li>物理块号&#x3D;起始块号+逻辑块号</li><li><strong>顺序读&#x2F;写最快</strong></li><li>优点：<ul><li><strong>支持顺序访问和直接访问（随机访问）</strong></li><li>读取某个磁盘块，需要移动磁块，<strong>连续分配文件在顺序读写的速度最快</strong></li></ul></li><li>缺点：<ul><li>物理上<strong>不方便对文件拓展</strong></li><li><strong>空间利用率低，产生难以利用的磁盘碎片，可以通过紧凑解决(反复增删容易形成碎片)</strong></li><li>为保持有序，删除和加入记录需要对物理块易用</li></ul></li></ul><h5 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h5><p>采取<strong>离散分配</strong>的方式，分为<strong>隐式链接</strong>和<strong>显示链接</strong></p><p><strong>隐式链接</strong></p><p>FCB: (文件名,…,起始块号，结束块号)，</p><p>类比链表的指针遍历，访问逻辑为 i 号逻辑块，需要 i+1 次磁盘 I&#x2F;O.<br><img src="/2023/07/01/operating-system/27.png"></p><ul><li>优点：<ul><li><strong>拓展方便，不存在磁盘碎片</strong></li></ul></li><li>缺点:<ul><li><strong>只支持顺序访问，不支持随机访问</strong>，查找效率低</li><li>指向下一盘块的指针也要耗费少量空间</li><li>指针易丢失。将几个盘块组成簇可解决</li></ul></li></ul><p><strong>显式链接</strong></p><ul><li>顺序存储表中信息, 表项： <strong>（物理块号，下一块）</strong>, 类似数组实现邻接表</li><li><strong>一个磁盘仅需要一张 FAT</strong>。<strong>开机时 FAT 被读入内存并常驻</strong><br><img src="/2023/07/01/operating-system/28.png"><br>PS：-1表示最后一块，-2表示空闲</li><li>优点：<ul><li>采用链式分配 （显式链接）方式的文件，<strong>支持顺序访问</strong>，也<strong>支持随机访问</strong>（想访问i号逻辑块时，并不需要依次访问之前的0~i-1号逻辑块）</li><li>块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</li><li>显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</li></ul></li><li>缺点：<ul><li>FAT 需要占用一定内存空间<br>链接方式默认隐式链接</li></ul></li></ul><h5 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h5><p><strong>注意： FCB 在内存里时读取不需要 I&#x2F;O，初始放在外存（属于目录项，存在磁盘里）</strong></p><p><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中记<strong>录了文件的各个逻辑块对应的物理块</strong>（索引表的功能类似于内存管理中的页表一一建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p><p>目录中需要记录文件的索引快是几号磁盘块。 （文件名，…,索引块号）, 一个索引项指向物理块<br>可以<strong>支持随机访问</strong>，<strong>文件拓展很容易实现</strong></p><h5 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a><font color="#dd0000">多层索引</font></h5><p>多层索引，类似多级页表。FCB中记录 (文件名，索引块)。</p><ul><li>磁盘块大小为 <strong>1 KB</strong>, 一个索引表项占<strong>4 B</strong>， 则一个磁盘块只能存放** 256 **个索引项</li><li>两层索引文件最大长度：<strong>256×256×1KB &#x3D; 65,536 KB &#x3D; 64MB</strong></li><li>文件过小但依然需要多层索引。。。</li></ul><h5 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a><font color="#dd0000">混合索引</font></h5><p>多种索引分配方式的结合。</p><p>例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表)</p><p>PS：<strong>K层索引，K+1次读磁盘</strong><br>&emsp; &emsp;<strong>索引结点个数 &#x3D; 文件个数</strong></p><p><strong>例题：</strong><br><img src="/2023/07/01/operating-system/30.png"><br><img src="/2023/07/01/operating-system/29.png"></p><ol><li><strong>直接地址</strong>：<strong>10个直接地址</strong>，若一块4KB，文件不大于10 × 4KB &#x3D; 40KB。可以在里面直接读出所有盘块号&emsp; &emsp;<strong>2次访问</strong></li><li>一次间接地址：1个一次间接地址，实质<strong>一级索引</strong>。一个间接地址块可放1024个盘块号，文件长达1024 × 4KB &#x3D; 4MB&emsp; &emsp;<strong>3次访问</strong></li><li>多次间接地址：2次为例，文件长度大于4MB+40KB时，采取2次间接地址。最大可达4GB</li></ol><p>PS：总文件的最大长度要将以上每个地址最大允许大小相加</p><h4 id="外存空闲空间管理"><a href="#外存空闲空间管理" class="headerlink" title="外存空闲空间管理"></a>外存空闲空间管理</h4><h5 id="FAT文件分配表法"><a href="#FAT文件分配表法" class="headerlink" title="FAT文件分配表法"></a>FAT文件分配表法</h5><h5 id="空闲表法-适用于-连续分配方式"><a href="#空闲表法-适用于-连续分配方式" class="headerlink" title="空闲表法 (适用于 连续分配方式)"></a>空闲表法 (适用于 连续分配方式)</h5><p>记录 <strong>(第一个空闲盘，块号)<strong>， <strong>为文件分配连续的存储空间</strong>, 与内存管理的相似<br><strong>首次适应</strong>和</strong>最佳适应算法</strong><br><strong>回收时注意表项合并</strong></p><h5 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h5><ul><li>空闲盘块链<ul><li><strong>盘块为单位</strong>，存有指向下一块指针</li><li>系统保存<strong>链头</strong>、<strong>链尾指针</strong></li><li>分配与回收都是一个一个操作，回收放置链尾</li></ul></li><li>空闲盘区链<ul><li><strong>盘区为单位</strong>，<strong>第一个盘块存有盘区长度和下一个盘区的指针</strong>，通常用<strong>首次适应</strong></li><li>系统保存 <strong>链头</strong>、<strong>链尾指针</strong>。</li><li>分配时也有最佳适应算法等， 大小没有符合要求时，可以将不同盘区分配给一个文件</li><li>回收时，要注意前后合并的问题，离散分配、连续分配都适用，效率高</li></ul></li></ul><h5 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h5><p>每一个块用 <strong>0或1</strong> 表示是否空闲<br>若是 <strong>m×n位</strong> 位示图，可用来表示** m×n 个盘块**，适用于大型文件系统<br><img src="/2023/07/01/operating-system/31.png"></p><h5 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h5><p>设立一个磁盘块为 <strong>超级块</strong><br>结合了空闲表和空闲链表<br>顺序的几个空闲块号组成一个成组链块<br><img src="/2023/07/01/operating-system/32.png"><br><strong>最后一个指向另一个成组链块</strong></p><p>盘块分配：指针下移，若移动到最后就指向另一个成组链块<br>盘块回收：指针上移，若移动到头了，则将已有的几个空间盘块号的成组链块号放入新的回收盘块</p><p>若是满了，超级块中内容复制到新回收块，新回收块变为超级块加到链表头</p><p>PS：<strong>簇和块都在 $\rightarrow$ 按簇分配磁盘空间文件</strong>；<strong>只有块</strong>，<strong>按块分配</strong></p><h3 id="文件共享和保护"><a href="#文件共享和保护" class="headerlink" title="文件共享和保护"></a>文件共享和保护</h3><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>基于索引结点</p><p>索引结点，对FCB进行瘦身（存放文件名, 指针）</p><p>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数</p><ul><li>若 count &#x3D; 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。<br>若某个用户决定“删除〞该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的<strong>count值减 1</strong>。</li><li>若 count &gt; 0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</li><li><strong>当 count &#x3D; 0 时,系统负责删除文件</strong></li></ul><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>基于符号链接</p><p>索引节点指向 Link 类型的文件(源文件被删除依然存在link文件)。类似 <strong>快捷方式</strong><br>不改变count值，只会引用count值。源文件删除后，count值也不变。</p><h3 id="磁盘管理概念"><a href="#磁盘管理概念" class="headerlink" title="磁盘管理概念"></a>磁盘管理概念</h3><h4 id="一次磁盘读写时间"><a href="#一次磁盘读写时间" class="headerlink" title="一次磁盘读写时间"></a>一次磁盘读写时间</h4><ul><li><strong>寻找时间（寻道）</strong> $T_S$  （题目往往会直接给）<ul><li><strong>启动磁头臂</strong>， 花费 s</li><li><strong>移动磁头</strong>，每跨越一个磁道耗时 m, 总共跨越 n 条磁道</li><li>$T_S&#x3D;s+m∗n$</li><li><strong>操作系统可以控制</strong></li></ul></li><li><strong>延迟时间</strong> $T_R$,<ul><li><strong>转半周的时间</strong></li><li>磁盘转速为 $r$。</li><li>延迟时间 $T_R&#x3D;\frac{1}{2∗r}$</li><li>例：题目给定转速如10000转&#x2F;分<br>$T_R&#x3D;\frac{60s*1000}{2∗10000}$&#x3D; 3 ms</li></ul></li><li><strong>读写时延&#x2F;传输时间</strong> $T_t$,<ul><li>转速为 $r$, 读写字节数为 $b$。每个磁道上字节数为 $N$</li><li>传输时间 $T_t&#x3D;\frac{b}{r∗N}$</li><li>例1：读取扇区大小4KB，磁盘传输速率20MB&#x2F;s，<br>  $T_t&#x3D;\frac{4KB}{20MB&#x2F;s}$ &#x3D; 0.2ms</li><li>例2：1&#x2F;N圈的时间<br>  $T_t&#x3D;\frac{b}{r∗N}</li></ul></li></ul><h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><ol><li><strong>磁盘初始化</strong><br>磁盘在存储数据之前，将其分成扇区，以便磁盘控制器能够进行读写操作，这个过程为<strong>低级格式化(物理格式化)</strong></li><li><strong>分区</strong><br>分为一个或多个柱面组成的分区(C盘、D盘)<br><strong>以簇(linux为块)为单位</strong>，多个相邻扇区为一簇</li><li><strong>引导块</strong><br>计算机启动初始化程序(自举程序)也是<strong>系统启动的第一步</strong>，<strong>放在ROM中</strong></li><li><strong>坏块</strong></li></ol><p><strong>逻辑格式化</strong>：建立文件系统<strong>根目录</strong>，对保存空闲块的数据结构初始化。</p><h3 id="磁盘寻寻道-调度-算法"><a href="#磁盘寻寻道-调度-算法" class="headerlink" title="磁盘寻寻道(调度)算法"></a>磁盘寻寻道(调度)算法</h3><h4 id="先来先服务算法-FCFS"><a href="#先来先服务算法-FCFS" class="headerlink" title="先来先服务算法 (FCFS)"></a>先来先服务算法 (FCFS)</h4><p><font color="#dd0000">多用于Flash等随机存储器，因为其不需要考虑寻道和旋转时延。</font><br><img src="/2023/07/01/operating-system/33.png"></p><h4 id="最短寻找时间优先-SSTF"><a href="#最短寻找时间优先-SSTF" class="headerlink" title="最短寻找时间优先 (SSTF)"></a>最短寻找时间优先 (SSTF)</h4><p><img src="/2023/07/01/operating-system/34.png"></p><h4 id="扫描算法-SCAN"><a href="#扫描算法-SCAN" class="headerlink" title="扫描算法 (SCAN)"></a>扫描算法 (SCAN)</h4><p>题目不说明，SCAN就是LOOK算法<br>在SCAN的基础上，如果在磁头移动方向上己经没有别的请求，就可以立即改变磁头移动方向<br><img src="/2023/07/01/operating-system/35.png"></p><h4 id="循环扫描算法-C-SCAN"><a href="#循环扫描算法-C-SCAN" class="headerlink" title="循环扫描算法 (C-SCAN)"></a>循环扫描算法 (C-SCAN)</h4><p><img src="/2023/07/01/operating-system/36.png"></p><h4 id="减少磁盘延迟的方法"><a href="#减少磁盘延迟的方法" class="headerlink" title="减少磁盘延迟的方法"></a>减少磁盘延迟的方法</h4><ol><li>采用交替编号<ul><li>原理：读完一个扇区需要一段时间才能继续读</li></ul></li><li>磁盘结构设计 (柱面，盘面，扇区)</li><li>错位命名</li></ol><h2 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I&#x2F;O设备管理"></a>I&#x2F;O设备管理</h2><h3 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I&#x2F;O软件"></a>I&#x2F;O软件</h3><p><img src="/2023/07/01/operating-system/37.png"><br><strong>用户层软件</strong></p><ul><li><strong>实现了与用户交互的接口</strong>，用户使用提供的 <strong>库函数(在应用层)</strong></li><li>将用户请求翻译成格式化的 I&#x2F;O 请求，并通过系统调用请求操作系统内核的服务</li></ul><p><strong>设备独立性软件</strong><br>又称**设备无关性软件 **</p><ul><li>向上提供用户程序与设备驱动器统一的调用接口（read&#x2F;write)</li><li>设备命令</li><li>设备的保护（类似文件保护， 设备被看成一种特殊的文件）</li><li>差错处理，对设备错误进行处理</li><li>设备的分配与回收（临界资源）</li><li>数据缓冲区管理（缓冲技术屏蔽设备间数据交换单位大小和数据传输的差异）</li><li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序。<strong>逻辑设备在应用程序中作为申请，实际系统执行时逻辑程序将映射为物理设备来使用</strong><ul><li>(通过<strong>逻辑设备表（LUT, Logical Unit Table)</strong> 确定逻辑设备对应的<strong>物理设备</strong>，并找到对应的<strong>设备驱动程序</strong>)<ul><li>第一种方式，整个系统设置一张 LUT， 只适用于单用户操作系统</li><li>第二种方式，每个用户设置一张 LUT, 存在用户进程对应的 PCB 中</li></ul></li></ul></li></ul><p><strong>设备驱动程序</strong>  &emsp; <strong>(初始化设备)</strong><br><strong>负责对硬件设备的具体控制，将上层发出一系列命令（read、write）转化成设备听得懂一系列操作</strong>。包括设置设备寄存器；检查设备状态。<strong>也将设备控制器传来的信号发送给上层</strong>。</p><p>也是<strong>真正完成对设备的驱动</strong>，比如一些<strong>找数据的计算</strong></p><p>不同I&#x2F;O设备具有不同的硬件特性，厂家需要根据设备的硬件特性设计并提供相应的驱动程序</p><p>驱动程序<strong>一般以一个进程的形式存在</strong></p><p><strong>中断处理程序</strong><br>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。<strong>最早接受设备输入信号</strong></p><h3 id="I-O缓冲"><a href="#I-O缓冲" class="headerlink" title="I&#x2F;O缓冲"></a>I&#x2F;O缓冲</h3><p>I&#x2F;O缓冲的作用在于减少I&#x2F;O的次数<br>用磁盘告诉缓冲技术来提高磁盘的I&#x2F;O速度<br><img src="/2023/07/01/operating-system/38.png"></p><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p><strong>每块处理时间：M+max(C,T)</strong><br>非空不能输入，只能输出；反之，空，只能输入<br><img src="/2023/07/01/operating-system/39.png"><br>若是有 n 个块，<strong>总处理时间：n (M + max(C,T)) + C</strong></p><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p><img src="/2023/07/01/operating-system/40.png"><br>若是有 n 个块，<strong>总处理时间：n (max(C + M,T)) + M + C</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理笔记</title>
      <link href="/2023/06/28/computer-architecture/"/>
      <url>/2023/06/28/computer-architecture/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h3><p><img src="/2023/06/28/computer-architecture/1.png"></p><h3 id="冯·诺依曼机"><a href="#冯·诺依曼机" class="headerlink" title="冯·诺依曼机"></a>冯·诺依曼机</h3><p>美籍匈牙利科学家冯·诺依曼最先提出“<strong>程序存储</strong>”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。<br>“程序存储”：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即<strong>按地址访问并顺序执行指令</strong></p><h4 id="冯诺曼体系结构特点"><a href="#冯诺曼体系结构特点" class="headerlink" title="冯诺曼体系结构特点:"></a>冯诺曼体系结构特点:</h4><p>计算机硬件系统由五大部件组成(存储器、运算器、控制器、输出设备、输入设备)<br>指令和数据以同等地位存于存储器，可按地址寻访<br>指令和数据在CPU中区分是根据<strong>指令周期的不同阶段</strong><br>指令和数据用二进制表示<br>指令由操作码和地址码组成<br>存储程序<br>以运算器为中心</p><h3 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a><font color="#dd0000">计算机性能指标</font></h3><p><img src="/2023/06/28/computer-architecture/2.png"><br><strong>吞吐量</strong>，指系统在单位时间内处理请求的数量 ；从用户观点看，它是评价计算机系统性能的综合参数<br><strong>响应时间</strong>，指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间。<br><strong>CPU时钟周期</strong>，通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。<br>**主频(CPU时钟频率)**。机器内部主时钟的频率，是衡量机器速度的重要参数。</p><ul><li>CPU周期又称为机器周期，由多个时钟周期组成！</li><li>指令周期&gt;CPU周期&gt;时钟周期</li></ul><p><strong>CPI</strong>（Clock cycle Per Instruction），即执行一条指令所需的时钟周期数。<br>CPU执行时间，指运行一个程序所花费的时间。<br><font color="#dd0000">CPU执行时间 &#x3D; CPU时钟周期数&#x2F;主频 &#x3D; (指令条数xCPI)&#x2F;主频</font><br>CPU的性能取决于三个要素:主频、CPI 、指令条数<br><strong>IPS</strong> &#x3D; 主频&#x2F;平均CPI，每秒执行多少指令<br><strong>MIPS</strong> &#x3D; 即每秒执行多少百万条指令。<br>MFLOPS&#x3D;浮点操作次数&#x2F;(执行时间x$10^6$),即每秒执行多少百万次浮点运算。<br>GFLOPS&#x3D;浮点操作次数&#x2F;(执行时间x$10^9$)，即每秒执行多少十亿次浮点运算。<br>TFLOPS&#x3D;浮点操作次数&#x2F;(执行时间x$10^{12}$)，即每秒执行多少万亿次浮点运算。<br>PFLOPS:$10^{15}$<br>EFLOPS:$10^{18}$<br>ZFLOPS:$10^{21}$<br><em><strong>问题：<u>计算机由哪几部分组成？以哪部分为中心？</u></strong></em><br>答：计算机由<font color="#dd0000">运算器、控制器、存储器、输入设备及输出设备五大部分</font>构成。早期的冯·诺依曼机<strong>以运算器为中心</strong>；现代计算机已经发展为<strong>以存储器为中心</strong></p><h3 id="C语言浮点数类型"><a href="#C语言浮点数类型" class="headerlink" title="C语言浮点数类型"></a>C语言浮点数类型</h3><p>1.int$\rightarrow$float &emsp; 不会溢出、影响精度<br>2.int或float$\rightarrow$double &emsp; 保留精确值<br>3.double$\rightarrow$float &emsp; 可能溢出、舍入<br>4.double或float$\rightarrow$int &emsp; 可能溢出、影响精度</p><h2 id="数据的表示与运算"><a href="#数据的表示与运算" class="headerlink" title="数据的表示与运算"></a>数据的表示与运算</h2><p>常见 2 的指数：<br>$2^5&#x3D;32$，$2^6&#x3D;64$，$2^7&#x3D;128$，$2^8&#x3D;256$，$2^9&#x3D;512$，$2^{10}&#x3D;1024$，$2^{11}&#x3D;2048$，$2^{12}&#x3D;4096$，$2^{13}&#x3D;8192$，$2^{14}&#x3D;16384$，$2^{15}&#x3D;32768$，$2^{16}&#x3D;65536$</p><h3 id="补码相关内容"><a href="#补码相关内容" class="headerlink" title="补码相关内容"></a>补码相关内容</h3><h4 id="补码大小比较"><a href="#补码大小比较" class="headerlink" title="补码大小比较"></a>补码大小比较</h4><p>正数：1多值大，1越靠左值大<br>负数：1多值大，1越靠左值大<br>负数补码快速计算:1000 0011&#x3D;-128+3&#x3D;125</p><h4 id="有无符号转换"><a href="#有无符号转换" class="headerlink" title="有无符号转换"></a>有无符号转换</h4><p>有符号$\rightarrow$无符号：将符号位转为最高位数值位<br>例：-32767&#x3D;1000 0000 0000 0001$\rightarrow$无符号 32768+1<br>无符号$\rightarrow$有符号：最高数值位直接作为符号位</p><h4 id="符号拓展"><a href="#符号拓展" class="headerlink" title="符号拓展"></a>符号拓展</h4><p>正数：填0<br>负数：<strong>原码</strong>：填0<br>&emsp;  <strong>反码、补码</strong>：填1  </p><h4 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h4><p>乘2&#x3D;左移&emsp; 除2&#x3D;右移<br>补码<strong>算术移位</strong>(符号位不变)：<br>  &emsp;1.正数：左移右移都是补0<br>  &emsp;2.负数：左0右1<br>  补码<strong>逻辑移位</strong>：补0而且是整个移动</p><p><em><strong>问题：<u>如何判断移位是否溢出？</u></strong></em><br>答：若<strong>左移</strong>且<strong>移丢的是有效位</strong>时，则溢出。<br>例：0<u><strong>1</strong></u>00 1100 &emsp;<strong>1是有效位置</strong>&emsp; 溢出<br>0<u><strong>0</strong></u>10 0010 &emsp;<strong>0是有效位置</strong>&emsp; 无溢出<br>1<u><strong>0</strong></u>10 0010 &emsp;<strong>0是有效位置</strong>&emsp; 溢出<br>1<u><strong>1</strong></u>00 1100 &emsp;<strong>1是有效位置</strong>&emsp; 无溢出<br>PS：正数有效位为1；负数有效位为0</p><p><em><strong>问题：<u>双符号位移位？</u></strong></em><br>答：最高符号位不参与移位，次高位参与移位<br>若双符号位最高与次高不同时，则溢出<br>例：1100 1100 左移$\rightarrow$1001 1000 溢出<br>&emsp; &emsp; &emsp; &emsp;&emsp;&emsp;右移$\rightarrow$1110 0110 无溢出</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>补码范围：-128~127<br>定点数其值超出能表示的范围时，溢出</p><h3 id="定点数计算"><a href="#定点数计算" class="headerlink" title="定点数计算"></a>定点数计算</h3><p>补码定点加法&emsp;符号位参与运算，产生进位丢掉<br>补码定点减法<br>长度为n+1的定点数，按照不同的编码方式，表示的数值范围：<br><img src="/2023/06/28/computer-architecture/3.png"></p><h3 id="浮点数计算"><a href="#浮点数计算" class="headerlink" title="浮点数计算"></a>浮点数计算</h3><p>IEEE 754标准 &emsp;阶码-126~127</p><p>IEEE 754浮点数格式：</p><table><thead><tr><th align="center"></th><th align="center">符号</th><th align="center">阶码</th><th align="center">尾数</th></tr></thead><tbody><tr><td align="center">短浮点数(32位)</td><td align="center">1</td><td align="center">8</td><td align="center">23</td></tr><tr><td align="center">长浮点数(64位)</td><td align="center">1</td><td align="center">11</td><td align="center">52</td></tr></tbody></table><p>IEEE 754浮点数范围：</p><table><thead><tr><th align="center"></th><th align="center">min</th><th align="center">max</th></tr></thead><tbody><tr><td align="center">单精度</td><td align="center">$2^{-126}$</td><td align="center">$2^{127}(2-2^{-23})$</td></tr><tr><td align="center">双精度</td><td align="center">$2^{-1022}$</td><td align="center">$2^{1023}(2-2^{-52})$</td></tr></tbody></table><h4 id="浮点数转为十进制运算例子"><a href="#浮点数转为十进制运算例子" class="headerlink" title="浮点数转为十进制运算例子"></a>浮点数转为十进制运算例子</h4><p>1<u>100</u> <u>0110</u> <u>0</u>100 0000 …………0000<br>1：符号位<br>1000 1100：阶码&emsp;<br>1.1&#x3D;1.5：尾数(默认个位有个1)</p><p>阶码转为十进制：将其看作无符号数再减去127然后转为10进制<br><font color="#dd0000">PS:这个方法只限于1~254（全0和全1不能用）<br>全0就是-126，全1则是无穷大或NaN</font></p><h4 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h4><p>低阶转高阶<br>浮点数运算溢出判断是根据阶码尾数右规或左规后的阶码是否溢出</p><h4 id="规格化特点"><a href="#规格化特点" class="headerlink" title="规格化特点"></a>规格化特点</h4><p>规格化浮点数的尾数小数点后的第一位一定是个非零数。<br>左规：阶码-1 &emsp; 右规：阶码+1</p><table><thead><tr><th align="center"></th><th align="center">正数</th><th align="center">负数</th></tr></thead><tbody><tr><td align="center">原码</td><td align="center">0.1xxxx</td><td align="center">1.1xxxx</td></tr><tr><td align="center">补码</td><td align="center">0.1xxxx</td><td align="center">1.0xxxx</td></tr></tbody></table><p>阶码和尾数均用补码表示，阶码部分共K+1位(含1位阶符)，尾数部分共n+1位（含1位数符），则这样的浮点数的表示范围<br><img src="/2023/06/28/computer-architecture/3.png"></p><h3 id="基本运算常见问题总结"><a href="#基本运算常见问题总结" class="headerlink" title="基本运算常见问题总结"></a>基本运算常见问题总结</h3><h4 id="基本运算部件"><a href="#基本运算部件" class="headerlink" title="基本运算部件"></a>基本运算部件</h4><p><img src="/2023/06/28/computer-architecture/60.png"></p><h4 id="OP、SF、ZF、CF-溢出判定"><a href="#OP、SF、ZF、CF-溢出判定" class="headerlink" title="OP、SF、ZF、CF 溢出判定"></a>OP、SF、ZF、CF 溢出判定</h4><p><img src="/2023/06/28/computer-architecture/61.png"></p><h4 id="加减溢出判定"><a href="#加减溢出判定" class="headerlink" title="加减溢出判定"></a>加减溢出判定</h4><p><img src="/2023/06/28/computer-architecture/62.png"></p><h4 id="乘除溢出判定"><a href="#乘除溢出判定" class="headerlink" title="乘除溢出判定"></a>乘除溢出判定</h4><p><img src="/2023/06/28/computer-architecture/63.png"><br><img src="/2023/06/28/computer-architecture/64.png"></p><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h3 id="存储器概念和特点"><a href="#存储器概念和特点" class="headerlink" title="存储器概念和特点"></a>存储器概念和特点</h3><h4 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h4><p>按存取方式分类：</p><ul><li>随机存储器（<strong>RAM</strong>）。存储器的任何一个存储单元的内容都可以<strong>随机存取</strong>，而且存取时间与存取单元的物理位置无关，主要用作<strong>主存或高速缓冲存储器，如内存条</strong>。</li><li>只读存储器（<strong>ROM</strong>）。存储器的内容只能随机读出而不能写入(<strong>只读不写</strong>)。<strong>即使断电，内容也不会丢失</strong>。主要用于<strong>光盘、专辑、CD-DOM</strong>。<strong>不用刷新</strong></li><li>串行访问存储器。对存储单元进行读&#x2F;写操作时，需按其物理位置的先后顺序寻址，包括<strong>SAM顺序存取存储器</strong>（如<strong>磁带</strong>）与<strong>DAM直接存取存储器</strong>（如<strong>磁盘</strong>）。<br>PS：RAM和ROM都是<strong>随机存取方式</strong>。但传统的ROM不是</li></ul><p><strong>SRAM和DRAM</strong>:<br><img src="/2023/06/28/computer-architecture/5.png"></p><p>PS:<strong><font color="#dd0000">任何存储器“写”都比“读”慢</font></strong></p><h4 id="ROM分类——断点不丢失的只读存储器"><a href="#ROM分类——断点不丢失的只读存储器" class="headerlink" title="ROM分类——断点不丢失的只读存储器"></a>ROM分类——断点不丢失的只读存储器</h4><p><img src="/2023/06/28/computer-architecture/6.png"><br>PS：<font color="#dd0000">随机存储器是指RAM，Flash不是。但有随机存储能力的有EPROM.Flash和SSD</font></p><h3 id="存储器与CPU连接"><a href="#存储器与CPU连接" class="headerlink" title="存储器与CPU连接"></a>存储器与CPU连接</h3><p>字长位数默认是8<br>芯片数量&#x3D;存储容量&#x2F;芯片大小<br>题中常见形式:<br>1.给大小，直接算；<br>2.给范围，尾-首+1.例：$5FFF$H-$4000$H+1&#x3D;$2000$H&#x3D;8k<br>内存空间：<br>1.逻辑地址空间&emsp;主存地址空间<br>2.物理地址空间&emsp;主存储器容量</p><p>常见题型：<br>4M×8(<strong>8为芯片字长</strong>) DRAM芯片组成256MB存储器<br>DRAM 数据引脚：8<br>&emsp;&emsp;&emsp; 地址引脚：$\frac{log_2{4M}}{2}$&#x3D;11位 (PS:除2的原因是DRAM送行到地址需要分两次，所以<strong>地址引脚需要减半</strong>)</p><p>存储器 数据引脚：8<br>&emsp;&emsp;&emsp; 地址引脚：11+6片选 (6是所需芯片个数，然后进行$log_2n$处理，比如该题为$log_2\frac{256}{4}&#x3D;6$)</p><p>芯片&emsp;&emsp;$2^k\rightarrow2^{11}$&emsp;地址引脚最少&emsp;$log_2\frac{2^k}{2}$&emsp;$2^5·2^6$<br>刷新是按行刷新，行数越少；刷新越快</p><h3 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h3><p>注意：区分字、字节、位<br>字$\rightarrow$<strong>n</strong>×B &emsp;16，32，64 基本形式：FFFF<br>字节$\rightarrow$1B&#x3D;8b 基本形式：FF<br>位$\rightarrow$b</p><h4 id="大端-小端"><a href="#大端-小端" class="headerlink" title="大端&#x2F;小端"></a>大端&#x2F;小端</h4><p>大端(从大到小)&#x2F;小端(从小到大)</p><ol><li>每个字内字节顺序要根据大小端对应变化</li><li>字的顺序递增(所以在存储单元内往往是字要倒着存的)</li><li>字节内顺序不变</li></ol><p>例：<br><img src="/2023/06/28/computer-architecture/7.png"><br>大端：低位<strong>字节</strong>在内存高位 &emsp;大$\rightarrow$小<br>小端:低位<strong>字节</strong>在内存低位(往往要把字内字节顺序倒过来) &emsp;小$\rightarrow$大</p><p>题目主往往字长为32位，也就是4字节，格式一般为：FFFF FFFF<br>int类就是一个字长，double类就是两个字长</p><h4 id="数据边界"><a href="#数据边界" class="headerlink" title="数据边界"></a>数据边界</h4><p>按照数据长度大的对齐<br><img src="/2023/06/28/computer-architecture/8.png"></p><h3 id="多体模块系统"><a href="#多体模块系统" class="headerlink" title="多体模块系统"></a>多体模块系统</h3><h4 id="单体多字存储器-多体并行存储器："><a href="#单体多字存储器-多体并行存储器：" class="headerlink" title="单体多字存储器&#x2F;多体并行存储器："></a>单体多字存储器&#x2F;多体并行存储器：</h4><p><img src="/2023/06/28/computer-architecture/9.png"></p><h4 id="多体并行存储器分类"><a href="#多体并行存储器分类" class="headerlink" title="多体并行存储器分类"></a>多体并行存储器分类</h4><p>多体并行存储器分为<strong>高位交叉编址(顺序方式)<strong>和</strong>低位交叉编址(交叉方式)</strong><br><img src="/2023/06/28/computer-architecture/10.png"></p><p>方便理解的例题：<br><img src="/2023/06/28/computer-architecture/11.png"></p><p>可能会出现<strong>冲突情况</strong>：<br>假定某计算机采用<strong>四体交叉编址存储器</strong><br><img src="/2023/06/28/computer-architecture/12.png"></p><h3 id="主存与Cache系统"><a href="#主存与Cache系统" class="headerlink" title="主存与Cache系统"></a><font color="#dd0000">主存与Cache系统</font></h3><h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p><strong>空间局部性</strong>：在最近的未来要用到的信息(指令和数据)，很可能<br>与现在正在使用的信息在存储空间上是邻近的(<strong>未来使用的可能是邻近使用的</strong>)<br><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息(<strong>未来使用的可能是最近使用的</strong>)<br>总结：<br>1.<strong><font color="#dd0000">一重循环</font><strong>：只有</strong>空间</strong>局部性<br>2.<strong><font color="#dd0000">二重循环</font><strong>：有</strong>时间</strong>、有<strong>空间</strong><br><img src="/2023/06/28/computer-architecture/13.png"></p><h4 id="Cache与主存映射方式"><a href="#Cache与主存映射方式" class="headerlink" title="Cache与主存映射方式"></a>Cache与主存映射方式</h4><ol><li>直接映射<br>直接映射的关系可定义为：<strong>Cache行号 &#x3D; 主存块号 mod Cache总行数</strong><br><img src="/2023/06/28/computer-architecture/14.png"></li><li>全相联映射<br><img src="/2023/06/28/computer-architecture/15.png"></li><li>组相联映射<br>组相联映射的关系可定义为：<strong>Cache组号 &#x3D; 主存块号 mod Cache组数</strong><br><img src="/2023/06/28/computer-architecture/16.png"><br><img src="/2023/06/28/computer-architecture/17.png"></li></ol><p><font color="#dd0000">块内地址位数&#x3D;主存块大小&#x3D;主存地址长&#x2F;主存块号</font></p><h4 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h4><ol><li><strong>随机算法(RAND)</strong>:随机地确定替换的 Cache块。它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低</li><li><strong>先进先出算法(FIFO)</strong>:选择最早调入的行进行替换。它比较容易实现，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入 Cache的块替换掉。</li><li><strong>近期最少使用算法（LRU)</strong>:依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比FFO要高，是堆栈类算法。<br>LRU算法对每行设置一个计数器， Cache每命中一次，命中行计数器清0,而其他各行计数器均加1,需要替换时比较各特定行的计数值，将计数值最大的行换出。</li><li><strong>最不经常使用算法(LFU)</strong>:将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1,需要替换时比较各特定行的计数值，将计数值最小的行换出。</li></ol><h4 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h4><p><img src="/2023/06/28/computer-architecture/18.png"><br>PS：题中表明<strong>写回法</strong>，有<strong>脏位</strong>(也即是修改位，为1标志Cache行中的块被修改过，替换时需要写回主存)，所以计算Cache行长的时候需要$\mathbf{+1}$</p><h4 id="Cache行长计算-TLB-重要题型"><a href="#Cache行长计算-TLB-重要题型" class="headerlink" title="Cache行长计算&#x2F;TLB(重要题型)"></a><font color="#dd0000">Cache行长计算&#x2F;TLB(重要题型)</font></h4><p><img src="/2023/06/28/computer-architecture/65.png"><br><strong>根据6个条件考虑：一个Cache行的完整构成</strong><br><img src="/2023/06/28/computer-architecture/66.png"><br><strong>Cache行长 &#x3D; 标记 + 数据位+ 有效位(1b) + (可能有)脏位(1b)</strong><br><strong>标记</strong>：主存地址(位数) - 主存块大小($log_2{n}$) - (根据映射方式变化：<u>直接-行号</u>；<u>全相联-0</u>；<u>组相联-组号</u>)<br>PS：若是组相联可能还有<strong>LRU位</strong>，LRU位用于主存块使用情况，其位数跟Cache组大小有关。2路有一位LRU位，4路有两位LRU位，$n$路有$log_2{n}$位。<br><strong>数据位</strong>：块内地址，主存块大小 例：32B×8&#x3D;256b，256位<br><img src="/2023/06/28/computer-architecture/67.png"></p><p><strong>TLB行长计算(与Cache有异曲同工之处)</strong><br><img src="/2023/06/28/computer-architecture/68.png"><br><img src="/2023/06/28/computer-architecture/69.png"></p><h3 id="虚拟存储器系统"><a href="#虚拟存储器系统" class="headerlink" title="虚拟存储器系统"></a>虚拟存储器系统</h3><h4 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h4><p><img src="/2023/06/28/computer-architecture/19.png"></p><h4 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h4><p><strong>页内地址</strong>：页面大小，若页面大小4KB即12位<br><strong>虚拟地址空间大小</strong>：虚页号+页内地址，若为4GB即32位<br><strong>物理地址</strong>：实页号+页内地址<br><img src="/2023/06/28/computer-architecture/20.png"></p><h4 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h4><p><img src="/2023/06/28/computer-architecture/21.png"></p><h4 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h4><p>把程序按逻辑结构分段，每段再划分为固定大小的页，<br>主存空间也划分为大小相等的页，<br>程序对主存的调入、调出仍以页为基本传送单位。<br>每个程序对应一个段表，每段对应一个页表<br><strong>虚拟地址：段号+段内页号+页内地址</strong></p><h4 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h4><p>页表、段表存放在主存中，收到虚拟地址后要先访问主存，查询页表、段表，进行虚实地址转换。<br>放在主存中的页表称为慢表(Page)。<br>提高变换速度 $\rightarrow$ 用高速缓冲存储器存放常用的页表项  $\rightarrow$ 快表(TLB)<br><img src="/2023/06/28/computer-architecture/22.png"><br><strong>TLB与Cache</strong>：<br>1.TLB存放页表的一部分，若缺失$\rightarrow$页表；<br>&emsp;Cache存放内存的一部分，若缺失$\rightarrow$内存<br>2.二者都是SRAM<br>PS：TLB是Page的一部分</p><p>①TLB命中<br>②TLB不中，Page中<br>说明在内存中，Cache中&#x2F;Cache不中<br>③TLB，Page都不中</p><p>Cache无论是否命中都要访问一次</p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p><img src="/2023/06/28/computer-architecture/23.png"><br>OP:有多少指令就有几位</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><img src="/2023/06/28/computer-architecture/24.png"><br><strong>立即寻址</strong>：形式地址A就是操作数本身，又称为立即数，一般采用补码形式。</p><p><strong>直接寻址</strong>：指令字中的形式地址A就是操作数的真实地址EA，即EA&#x3D;A。</p><p><img src="/2023/06/28/computer-architecture/25.png"><br><strong>间接寻址</strong>：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址<br>所在的存储单元的地址，也就是操作数地址的地址，即EA&#x3D;(A) 。<br><img src="/2023/06/28/computer-architecture/26.png"></p><p><strong>寄存器寻址</strong>：在指令字中直接给出操作数所在的寄存器编号，即EA &#x3D;Ri，其操作数在由Ri所指的寄存器内。<strong>缩短字长</strong><br><img src="/2023/06/28/computer-architecture/27.png"></p><p><strong>寄存器间接寻址</strong>：寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA&#x3D;(Ri) 。<br><img src="/2023/06/28/computer-architecture/28.png"></p><p><strong>相对寻址</strong>：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA&#x3D;(PC)+A，其中A是相对于当前指令地址的位移量，可正可负，补码表示 。<strong>程序移动</strong><br><img src="/2023/06/28/computer-architecture/31.png"><br><font color="#dd0000">取指后PC会+1，往往最后的转移目标地址位PC+2+A。<br>“+2”的原因是根据题目而定，指令往往是2字节大小，所以+2、按字节编址<br>PS：若题目给的是取指后的PC就不用+1，但若是转移指令的地址就需要了</font></p><p><strong>基址寻址</strong>：将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA&#x3D;(BR)+A。<strong>多道，循环</strong><br><img src="/2023/06/28/computer-architecture/29.png"></p><p><strong>变址寻址</strong>：：有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA&#x3D; (IX)+A，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器 。<strong>数组</strong><br><img src="/2023/06/28/computer-architecture/30.png"></p><p>寻址方式总结：<br><img src="/2023/06/28/computer-architecture/32.png"></p><h3 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h3><h4 id="CISC：复杂指令系统计算机"><a href="#CISC：复杂指令系统计算机" class="headerlink" title="CISC：复杂指令系统计算机"></a>CISC：复杂指令系统计算机</h4><p>x86架构，主要用于笔记本、台式机等<br><font color="#dd0000">指令长度不一</font><br>提供了很多功能的指令，比如矩阵的加减乘除<br>80%左右的指令很少用，约占整个程序的20%<br>或者是有load、store等访问主存的指令有“[]”，也可以证明是CISC</p><h4 id="RISC：精简指令系统"><a href="#RISC：精简指令系统" class="headerlink" title="RISC：精简指令系统"></a>RISC：精简指令系统</h4><p>ARM架构，主要用于手机、平板等<br>只提供普遍的加减乘除。一定采用“<font color="#dd0000">流水线技术</font>”<br><font color="#dd0000">指令长度一致</font><br>Register(寄存器多)、程序长、硬布线</p><h4 id="二者比较："><a href="#二者比较：" class="headerlink" title="二者比较："></a>二者比较：</h4><p><img src="/2023/06/28/computer-architecture/33.png"></p><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><h3 id="CPU的设计与实现"><a href="#CPU的设计与实现" class="headerlink" title="CPU的设计与实现"></a>CPU的设计与实现</h3><h4 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h4><p>1.运算器</p><ul><li>算术逻辑单元：主要功能是进行算术&#x2F;逻辑运算。 </li><li>通用寄存器组：如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。 </li><li>暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。 </li><li>累加寄存器：它是一个通用寄存器，用于暂时存放 ALU运算的结果信息，用于实现加法运算。 </li><li>程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。 </li><li>移位器：对运算结果进行移位运算。 </li><li>计数器：控制乘除运算的操作步数。</li></ul><p>2.控制器</p><ul><li>程序计数器：用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以PC有自增功能。 </li><li>指令寄存器：用于保存当前正在执行的那条指令。</li><li>指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号。 </li><li>微操作信号发生器：根据IR的内容（指令）、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</li><li>时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到。</li><li>存储器地址寄存器：用于存放所要访问的主存单元的地址</li><li>存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。</li></ul><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>指令周期：CPU从主存中每取出并执行一条指令所需的全部时间。<br>指令周期常常用若干机器周期来表示，机器周期又叫CPU周期。<br>一个机器周期又包含若干时钟周期（也称为节拍、T周期或CPU时钟周期，它是CPU操作的最基本单位）。<br><img src="/2023/06/28/computer-architecture/34.png"><br>每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。<br><img src="/2023/06/28/computer-architecture/35.png"></p><h4 id="微程序控制器-硬布线控制器"><a href="#微程序控制器-硬布线控制器" class="headerlink" title="微程序控制器&#x2F;硬布线控制器"></a>微程序控制器&#x2F;硬布线控制器</h4><p><img src="/2023/06/28/computer-architecture/36.png"></p><h4 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a><font color="#dd0000">微指令的编码方式</font></h4><h5 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h5><p>在微指令的操作控制字段中，<font color="#dd0000">每一位代表一个微操作命令</font>，也就是<strong>n个指令就有n位</strong><br>某位为 <font color="#dd0000">“1” </font>表示该控制信号有效<br><img src="/2023/06/28/computer-architecture/37.png"><br>特点总结：<br>优点：简单、直观，执行速度<strong>快</strong>，操作并行性好。<br>缺点：微指令字长过长，n个微命令就要求微指令<br>的操作字段有n位，造成<strong>控存容量极大</strong>。</p><h5 id="字段直接编码方式"><a href="#字段直接编码方式" class="headerlink" title="字段直接编码方式"></a>字段直接编码方式</h5><p>将微指令的控制字段分成若干 “段”，每段经译码后发出控制信号微命令字段分段的原则：<br>① 互斥性微命令分在同一段内，相容性微命令分在不同段内。<br>② 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。<br>③ 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。<br><img src="/2023/06/28/computer-architecture/38.png"><br><strong>例题</strong>：某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位？<br><strong>答</strong>：第1个互斥类有7个微命令，要留出1个状态表示不操作，所以需要表示8种不同的状态，故需要3个二进制位。以此类推，后面4个互斥类各需要表示4、13、6、7种不同的状态，分别对应2、4、3、3个二进制位。<br>故操作控制字段的总位数为：3+2+4+3+3 &#x3D; 15 位<br><strong>简单总结</strong>：几个互斥类就有几段，几种微命令加上1后取对数就要几位</p><p>特点总结：<br>优点：可以缩短微指令字长 。<br>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢 。</p><h5 id="字段间接编码方式"><a href="#字段间接编码方式" class="headerlink" title="字段间接编码方式"></a>字段间接编码方式</h5><p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。</p><h4 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h4><p><img src="/2023/06/28/computer-architecture/39.png"><br><strong>例题</strong>：某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用<strong>断定法</strong>（下地址字段法）确定下条微指令地址，则微指令中下地址字段的位数至少是多少位？<br><strong>答</strong>：总共需要存储微指令数：32 × 4 + 2 &#x3D; 130条<br>对其标注所需的二进制位数：2^8 &#x3D; 256 &gt; 130。<br>下地址字段的位数至少是8位<br><strong>简单总结</strong>：有$n$条指令，就有$n$道微程序，若每个微程序的平均微指令个数为$k$，则一共有$k*n$个微指令。然后再加上取指令微程序的微指令，就是总微指令数。</p><p>按内容访问：全相联 Cache；TLB 快表&emsp;其余的都是按地址访问</p><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><h4 id="指令阶段"><a href="#指令阶段" class="headerlink" title="指令阶段"></a>指令阶段</h4><p>在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。指令之间并行执行。<br><img src="/2023/06/28/computer-architecture/40.png"><br><strong>例题</strong>：大致上，指令可以分为5个阶段(功能段)<br>每一段对应一个CPU时钟周期，而长度以最大的功能段为准。<br>如：取值(IF):200ps；译码&#x2F;读寄存器(IP):100ps；执行&#x2F;计算地址(EX):150ps；访存(MEM):200ps；写回(WB):100ps<br>则每个流水段为200ps(有延时再加上延时)<br>PS：运算类指令：无MEM访存；<br>&emsp; &emsp;条件转移指令用相对地址：无WB写回；<br>&emsp; &emsp;无条件转移：无MEM访存、无WB写回</p><h4 id="流水线冒险与处理"><a href="#流水线冒险与处理" class="headerlink" title="流水线冒险与处理"></a>流水线冒险与处理</h4><h5 id="结构冒险-资源冲突"><a href="#结构冒险-资源冲突" class="headerlink" title="结构冒险(资源冲突)"></a>结构冒险(资源冲突)</h5><p>由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。<br>解决办法：<br>1.后一相关指令暂停一周期<br>2.资源重复配置：数据存储器+指令存储器，使得取指和取数在不同存储器进行</p><h5 id="数据冒险-数据冲突"><a href="#数据冒险-数据冲突" class="headerlink" title="数据冒险(数据冲突)"></a><font color="#dd0000">数据冒险(数据冲突)</font></h5><p>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。<br>三类：<strong>RAW</strong>写后读；<strong>WAW</strong>写后写；<strong>WAR</strong>读后写<br><img src="/2023/06/28/computer-architecture/41.png"><br>题目中要注意<strong>前后相邻、编号相同的</strong><br><font color="#dd0000">无转发，注意写后读</font><br>解决办法：<br>1.把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞(stall)和软件插入“NOP”两种方法。<br>2.数据旁路技术(转发机制)。<br>3.编译优化：通过编译器调整指令顺序来解决数据相关。</p><h5 id="控制冒险-控制冲突"><a href="#控制冒险-控制冲突" class="headerlink" title="控制冒险(控制冲突)"></a>控制冒险(控制冲突)</h5><p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关。<br>解决办法：<br>1.尽早判别转移是否发生，尽早生成转移目标地址<br>2.预取转移成功和不成功两个控制流方向上的目标指令<br>3.加快和提前形成条件码<br>4.提高转移方向的猜准率</p><h4 id="流水线性能指标"><a href="#流水线性能指标" class="headerlink" title="流水线性能指标"></a>流水线性能指标</h4><h5 id="流水线吞吐率"><a href="#流水线吞吐率" class="headerlink" title="流水线吞吐率"></a>流水线吞吐率</h5><p>吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量。<br>设任务数为$n$；处理完成$n$个任务所用的时间为$T_k$<br>则计算流水线吞吐率（TP）的最基本的公式为：$TP&#x3D;\frac{n}{T_k}$<br><img src="/2023/06/28/computer-architecture/42.png"><br>总结：$n$任务数(指令数)&emsp;$k$流水线段数(k级指令)&emsp;$\triangle{t}$时钟周期(1&#x2F;主频)<br>吞吐率：$TP&#x3D;\frac{n}{(k+n-1)\triangle{t}}$<br>最大吞吐率：$TP_{max}&#x3D;\frac{1}{\triangle{t}}$</p><h5 id="流水加速比"><a href="#流水加速比" class="headerlink" title="流水加速比"></a>流水加速比</h5><p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。<br><img src="/2023/06/28/computer-architecture/43.png"><br>$S_{max}&#x3D;k$</p><h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>流水线的设备利用率称为流水线的效率。<br>在时空图上，流水线的效率定义为<strong>完成n个任务占用的时空区有效面积</strong>与 <strong>n个任务所用的时间与k个流水段所围成的时空区总面积</strong>之比。<br><img src="/2023/06/28/computer-architecture/44.png"><br><font color="#dd0000">E&#x3D;$\frac{n-1}{k+n-1}$</font><br>n趋于无穷，E&#x3D;1</p><h4 id="高级流水线技术"><a href="#高级流水线技术" class="headerlink" title="高级流水线技术"></a>高级流水线技术</h4><h5 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h5><p>又名动态多发射技术<br><img src="/2023/06/28/computer-architecture/45.png"></p><h5 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h5><p><img src="/2023/06/28/computer-architecture/46.png"><br>最理想是将时钟周期分段为机械周期</p><h5 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h5><p><img src="/2023/06/28/computer-architecture/47.png"><br>超长指令字与超标量技术区别：看同一时间是否进行多个运算</p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h3 id="总线组成和性能"><a href="#总线组成和性能" class="headerlink" title="总线组成和性能"></a>总线组成和性能</h3><p>总线是一组能为多个部件<strong>分时共享</strong>的公共信息传送线路<br><strong>分时</strong>是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。<br><strong>共享</strong>是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。<br><img src="/2023/06/28/computer-architecture/48.png"></p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><h5 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h5><p>注：单总线并不是指只有一根信号线，系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线。<br>CPU、主存、I&#x2F;O设备（通过I&#x2F;O接口）都连接在一组总线上，允许I&#x2F;O设备之间、I&#x2F;O设备和CPU之间或I&#x2F;O设备与主存之间直接交换信息。<br><img src="/2023/06/28/computer-architecture/49.png"></p><h5 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h5><p>双总线结构有两条总线，一条是<strong>主存总线</strong>，用于CPU、主存和通道之间进行数据传送；另一条是<strong>I&#x2F;O总线</strong>，用于多个外部设备与通道之间进行数据传送。<br><img src="/2023/06/28/computer-architecture/50.png"></p><h5 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h5><p>三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为<strong>主存总线</strong>、<strong>I&#x2F;O总线</strong>和<strong>直接内存访问DMA总线</strong>。<br>三个总线同一时间只能一个工作<br><img src="/2023/06/28/computer-architecture/51.png"></p><h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a><font color="#dd0000">总线性能指标</font></h3><ol><li><p>总线的<strong>传输周期(总线周期)</strong><br><font color="#dd0000">一次总线操作所需的时间</font>（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。</p></li><li><p>总线的<strong>工作频率</strong><br>总线上各种操作的频率，为<font color="#dd0000">总线周期的倒数</font>。<br>若总线周期&#x3D;N个时钟周期，则总线的工作频率&#x3D;时钟频率&#x2F;N。<br>实际上指<font color="#dd0000">一秒内传送几次数据</font>。   </p></li><li><p>总线<strong>时钟周期</strong><br>即<font color="#dd0000">机器的时钟周期</font>。计算机有一个统一的<br>时钟，以控制整个计算机的各个部件，总<br>线也要受此时钟的控制</p></li><li><p>总线的<strong>时钟频率</strong><br>即机器的时钟频率，为<font color="#dd0000">时钟周期的倒数</font>。<br>若时钟周期为T，则时钟频率为1&#x2F;T。<br>实际上指<font color="#dd0000">一秒内有多少个时钟周期</font>。</p></li><li><p>总线宽度<br>又称为<strong>总线位宽</strong>，它是总线上<font color="#dd0000">同时能够传输的数据位数</font>，通常是<font color="#dd0000">指数据总线的根数</font>，如32根称为32位（bit）总线。</p></li><li><p>总线带宽<br>可理解为总线的<font color="#dd0000">数据传输率</font>，即<font color="#dd0000">单位时间内总线上可传输数据的位数</font>，通常用每秒钟传送信息的字节数来衡量，单位可用字节&#x2F;秒（B&#x2F;s）表示。<br><img src="/2023/06/28/computer-architecture/52.png"></p></li><li><p>总线复用(不常考)<br>总线复用是指一种信号线在不同的时间传输不同的信息。可以使用较少的线传输更多的信息，从而节省了空间和成本。</p></li><li><p>信号线数(不常考)<br>地址总线、数据总线和控制总线,这3种总线数的总和称为信号线数。</p></li></ol><p>PS：总线频率独立于CPU频率</p><p>突发传输方式：数据存放地址连接，只要访问一次，便可连续读取。寻址阶段是发送数据单元的首地址。<br>并行不一定比串行慢。<br><strong><font color="#dd0000">总线传输数据总时间</font></strong>&#x3D;传地址(<strong>一次</strong>)+传数据(<strong>根据数据大小传几次</strong>)</p><h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><p><img src="/2023/06/28/computer-architecture/53.png"></p><h3 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h3><h4 id="总线事务"><a href="#总线事务" class="headerlink" title="总线事务"></a>总线事务</h4><p>总线周期的四个阶段：<br>1）申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲</strong>裁两个阶段。<br>2）寻址阶段：获得使用权的主模块通过总线<strong>发出</strong>本次要访问的从模块的<strong>地址</strong>及有关<strong>命令</strong>，启动参与本次传输的从模块。<br>3）传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送。<br>4）结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权。</p><h4 id="总线定时"><a href="#总线定时" class="headerlink" title="总线定时"></a>总线定时</h4><p>总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议或规则</p><ul><li>同步通信(同步定时方式)</li><li>异步通信(异步定时方式)</li><li>半同步通信</li><li>分离式通信</li></ul><h5 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h5><p>同步定时方式是指系统采用一个<strong>统一的时钟信号</strong>(由系统提供不根据设备)来协调发送和接收双方的传送定时关系。<br>时钟产生相等的时间间隔，每个间隔构成一个总线周期。<br>在<strong>一个总线周期中，发送方和接收方可进行一次数据传送</strong>。<br>因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始。<br>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。<br>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。<br>同步通信适用于<strong>总线长度较短</strong>及<strong>总线所接部件的存取时间比较接近</strong>的系统。</p><h5 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h5><p>在异步定时方式中，<strong>没有统一的时钟</strong>，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。<br>主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。<br>根据“请求”和“回答”信号的撤销是否互锁，分为以下3种类型。</p><ol><li>不互锁<br>主设备发出“<strong>请求</strong>”信号后，<strong>不必等</strong>到接到从设备的“<strong>回答</strong>”信号，而是经过一段时间，便撤销“请求”信号。<br>而从设备在接到“请求”信号后，发出“回答”信号，并<strong>经过一段时间</strong>，<strong>自动撤销</strong>“<strong>回答</strong>”信号。双方不存在互锁关系。<br>特点：<strong>速度最快 可靠性最差</strong></li><li>半互锁<br>主设备发出“<strong>请求</strong>”信号后，<strong>必须待接</strong>到从设备的“<strong>回答</strong>”信号后，才<strong>撤销</strong>“<strong>请求</strong>”信号，有互锁的关系。<br>而从设备在接到“请求”信号后，发出“<strong>回答</strong>”信号，但<strong>不必等待</strong>获知主设备的“<strong>请求</strong>”信号已经撤销，而是<strong>隔一段时间</strong>后<strong>自动撤销</strong>“<strong>回答</strong>”信号，不存在互锁关系。</li><li>全互锁<br>主设备发出“<strong>请求</strong>”<em>信号后，<strong>必须待接</strong>从设备“<strong>回答</strong>”后，才<strong>撤销</strong>“<strong>请求</strong>”信号；<br>从设备发出“<strong>回答</strong>”信号，<strong>必须待获</strong>知主设备“<strong>请求</strong>”信号已撤销后，再<strong>撤销</strong>其“<strong>回答</strong>”信号。双方存在互锁关系。<br>特点：*<em>最可靠 速度最慢</em></em></li></ol><h2 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2><h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h3><p>I&#x2F;O接口在主机同I&#x2F;O总线与内存、CPU相连<br>I&#x2F;O端口是I&#x2F;O接口中的寄存器，与<strong>通用寄存器</strong>进行数据交互<br><img src="/2023/06/28/computer-architecture/54.png"><br>数据线：读写数据、状态字、控制字、中断类型号<br>控制线：读写I&#x2F;O端口位置、中断请求信号</p><h5 id="I-O端口的编址方式"><a href="#I-O端口的编址方式" class="headerlink" title="I&#x2F;O端口的编址方式"></a>I&#x2F;O端口的编址方式</h5><ol><li>统一编址<br>把I&#x2F;O端口当做存储器的单元进行地址分配，用<strong>统一的访存指令</strong>(<font color="#dd0000">意思是：CPU访存与I&#x2F;O端口访问用同一指令</font>)就可以访问I&#x2F;O端口，又称存储器映射方式。靠不同的<strong>地址码</strong>区分<strong>内存</strong>和<strong>I&#x2F;O设备</strong>，I&#x2F;O地址要求相对固定在地址的某部分。</li><li>独立编址<br>I&#x2F;O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入&#x2F;输出指令访问端口，又称I&#x2F;O映射方式。<br>靠不同的<strong>指令</strong>区分<strong>内存</strong>和<strong>I&#x2F;O设备</strong>。<font color="#dd0000">所以I&#x2F;O端口地址可能与主存地址相同</font></li></ol><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a><font color="#dd0000">中断系统</font></h3><h4 id="外部中断-硬件-——计组强调"><a href="#外部中断-硬件-——计组强调" class="headerlink" title="外部中断(硬件)——计组强调"></a>外部中断(硬件)——计组强调</h4><ul><li>I&#x2F;O中断</li><li>DMA中断</li><li>逻辑中断</li><li>时钟中断</li></ul><h4 id="中断流程"><a href="#中断流程" class="headerlink" title="中断流程"></a>中断流程</h4><h5 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h5><p>中断源向CPU发出中断请求<br><img src="/2023/06/28/computer-architecture/55.png"><br>通过INTR线的是<strong>可屏蔽中断</strong><br>通过NMI线的是<strong>不可屏蔽中断</strong><br>可屏蔽中断：优先级低，关中断下不响应<br>不可屏蔽中断：优先级高，关中断下响应，多是时钟中断或是断电</p><h5 id="中断响应判优"><a href="#中断响应判优" class="headerlink" title="中断响应判优"></a>中断响应判优</h5><p>中断判优既可以用硬件实现，也可用软件实现：<br><strong>硬件实现</strong>是通过<strong>硬件排队器</strong>实现的，它既可以设置在CPU中，也可以分散在各个中断源中；<br><strong>软件实现</strong>是通过<strong>查询程序</strong>实现的。</p><p><strong>优先级设置：</strong></p><ol><li>硬件故障$&gt;$软件中断；</li><li>非屏蔽中断优于$&gt;$内部异常$&gt;$可屏蔽中断； </li><li>DMA请求$&gt;$I&#x2F;O设备传送的中断请求；</li><li>高速设备$&gt;$低速设备； </li><li>输入设备$&gt;$输出设备；</li><li>实时设备$&gt;$普通设备。</li></ol><h5 id="CPU响应中断的条件"><a href="#CPU响应中断的条件" class="headerlink" title="CPU响应中断的条件"></a>CPU响应中断的条件</h5><ol><li>中断源要有发出中断请求；</li><li>CPU允许中断即处于开中断(不可屏蔽中断不受影响)； </li><li>一条指令执行完毕后(异常不受影响)，且无紧迫任务；</li></ol><h5 id="中断响应-中断隐指令的主要任务"><a href="#中断响应-中断隐指令的主要任务" class="headerlink" title="中断响应(中断隐指令的主要任务)"></a>中断响应(中断隐指令的主要任务)</h5><p>① <strong>关中断</strong>。在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。<br>② <strong>保存断点</strong>。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。可以存入堆栈，也可以存入指定单元。<br>PS：基本上外内中断的断点都是<strong>下一个指令的地址即PC</strong>；只有异常中<strong>缺页</strong>是返回当前指令的地址。<br>③ <strong>引出中断服务程序</strong>。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）。<br>ISR$\rightarrow$PC，对应中断服务程序入口地址送入PC</p><h5 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h5><p>中断向量即是中断服务程序的入口地址。每个中断都有一个<strong>中断类型号</strong>，CPU通过识别中断源获得中断类型号，从<strong>中断向量表</strong>找到对应的中断向量，根据其入口地址启动中断服务程序</p><h5 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h5><p><img src="/2023/06/28/computer-architecture/56.png"></p><h4 id="多重中断和中断屏蔽技术"><a href="#多重中断和中断屏蔽技术" class="headerlink" title="多重中断和中断屏蔽技术"></a>多重中断和中断屏蔽技术</h4><p>允许多重中断的条件：<br>① 在中断服务程序中提前设置开中断指令。<br>② 优先级别高的中断源有权中断优先级别低的中断源。<br>每个中断源都有一个屏蔽触发器，<strong>1表示屏蔽该中断源的请求</strong>，<strong>0表示可以正常申请</strong>，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为<strong>屏蔽字</strong>。<strong>哪一位有“1”可以屏蔽哪一个，优先级越高“1”越多</strong></p><p><strong>例题</strong>：设某机有4个中断源A、B、C、D，其硬件排队优先次序为A&gt;B&gt;C&gt;D，现要求将中断处理次序改为D&gt;A&gt;C&gt;B。写出每个中断源对应的屏蔽字。<br><strong>答</strong>：中断源A的屏蔽字为1110<br>&emsp;&emsp;中断源B的屏蔽字为0100<br>&emsp;&emsp;中断源C的屏蔽字为0110<br>&emsp;&emsp;中断源D的屏蔽字为1111</p><p><strong>内外中断区别</strong>：<br><strong>外中断</strong>：指令周期之末响应 与当前指令无关<br><strong>内中断</strong>：指令周期之中响应 与当前指令有关</p><h3 id="I-O方式"><a href="#I-O方式" class="headerlink" title="I&#x2F;O方式"></a>I&#x2F;O方式</h3><p><strong>常见题型</strong>：<br>① 程序查询、中断、DMA这些方式的特点<br>② 在基本I-O方式下，CPU用于I&#x2F;O的时间在这个CPU总时间的比值</p><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>程序查询方式：CPU执行I&#x2F;O时，查询设备状态，根据设备状态来选择数据传输还是等待。<br>I&#x2F;O一旦启动便停止当前运行的程序。最主要的特点是：CPU踏步等待现象，CPU与I&#x2F;O串行工作。<br>主要类别：<br>① 独占查询：CPU100%的时间都在查询I&#x2F;O状态<br>② 立即查询：每隔一段时间查询一次</p><p><strong>例题</strong>：<br>在程序查询方式的输入&#x2F;输出系统中，假设不考虑处理时间，每一个查询操作需要100个时钟周期，CPU的时钟频率为50MHz。现有鼠标和硬盘两个设备，而且CPU必须每秒对鼠标进行30次查询，硬盘以32位字长为单位传输数据，即每32位被CPU查询一次，传输率为2×220B&#x2F;s。求CPU对这两个设备查询所花费的时间比率。<br><strong>答</strong>：<br>时间的角度：<br>一个时钟周期为 1&#x2F;50MHz &#x3D; 20ns<br>一个查询操作耗时 100 × 20ns &#x3D; 2000ns<br>1)鼠标<br>每秒查询鼠标耗时 30 × 2000ns &#x3D; 60000ns<br>查询鼠标所花费的时间比率 &#x3D; 60000ns&#x2F;1s &#x3D; 0.006%<br>对鼠标的查询基本不影响CPU的性能<br>2)硬盘<br>每32位需要查询一次，每秒传送2×2^20B<br>每秒需要查询(2×220B)&#x2F;32 &#x3D; 2^19次<br>查询硬盘耗时 2^19× 2000ns &#x3D; 512 × 1024 × 2000ns ≈ 1.05× 10^9 ns<br>查询硬盘所花费的时间比率 &#x3D; (1.05× 10^9 ns)&#x2F;1s &#x3D; 105%<br>CPU将全部时间都用于对硬盘的查询也不能满足磁盘传输的要求</p><h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>&emsp;见上一节</p><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><h5 id="DMA特点"><a href="#DMA特点" class="headerlink" title="DMA特点"></a>DMA特点</h5><p>有中断方式的优点即数据准备阶段CPU与外设并行工作。<br>由于DMA方式传送数据不需要经过CPU，因此不必中现行程序，<font color="#dd0000">I&#x2F;O与主机并行工作，程序和传送并行工作</font>。</p><p>DMA方式具有下列特点：<br>① 它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。<br>② 在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。<br>③ 主存中要开辟专用缓冲区，及时供给和接收外设的数据。<br>④ DMA传送速度快，CPU和外设并行工作，提高了系统效率。<br>⑤ DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p><p>PS：数据每传送一个字就释放总线让CPU可以访问主存</p><h5 id="DMA与中断的主要区别"><a href="#DMA与中断的主要区别" class="headerlink" title="DMA与中断的主要区别"></a>DMA与中断的主要区别</h5><p><img src="/2023/06/28/computer-architecture/57.png"><br>&emsp;&emsp;&emsp;&emsp;<strong>中断请求：CPU处理时间 &emsp; DMA请求：总线使用权</strong></p><p><strong>例题</strong>：某计算机的CPU主频为500MHz，CPI为5（即执行每条指令平均需5个时钟周期）。假定某外设的数据传输率为0.5MB&#x2F;s，采用中断方式与主机进行数据传送，以32位为传输单位，对应的中断服务程序包含18条指令，中断服务的其他开销相当于2条指令的执行时间。请回答下列问题，要求给出计算过程。<br>1）在中断方式下，CPU用于该外设I&#x2F;O的时间占整个CPU时间的百分比是多少？<br>2）当该外设的数据传输率达到5MB&#x2F;s时，改用DMA方式传送数据。假定每次DMA传送块大小为5000B，且DMA预处理和后处理的总开销为500个时钟周期，则CPU用于该外设I&#x2F;O的时间占整个CPU时间的百分比是多少？（假设DMA与CPU之间没有访存冲突）<br><strong>答</strong>：<br>1）<br><img src="/2023/06/28/computer-architecture/58.png"><br>2）<br><img src="/2023/06/28/computer-architecture/59.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记</title>
      <link href="/2023/06/24/computer-network/"/>
      <url>/2023/06/24/computer-network/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>主要内容：每层协议、每层功能、每层设备、网络怎么分层<br>不需要考虑如何实现和实现的细节<br>体系结构：协议；服务；服务访问点<br>协议：语法(格式)；语义(干什么)；同步(时序)</p><h2 id="TCP-IP-ISO体系结构"><a href="#TCP-IP-ISO体系结构" class="headerlink" title="TCP&#x2F;IP  ISO体系结构"></a>TCP&#x2F;IP  ISO体系结构</h2><h3 id="OSI-OST参考模型"><a href="#OSI-OST参考模型" class="headerlink" title="OSI&#x2F;OST参考模型"></a>OSI&#x2F;OST参考模型</h3><p><img src="/2023/06/24/computer-network/1.png"><br>每层功能：</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>所用能和<strong>用户</strong>交互产生网络流量的程序。如QQ，浏览器等<br>典型的应用层服务：<br><strong>文件传输（FTP）<br>电子邮件（SMTP）<br>万维网（HTTP）</strong></p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）<br>功能：<br><strong>数据格式变换（翻译官）<br>数据加密解密<br>数据压缩和恢复</strong></p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>向表示层实体&#x2F;用户进程提供建立连接并在连接上有序地传输数据。这是会话，也是建立同步(SYN)。<br>功能：<br>建立、管理、终止<strong>会话</strong><br>使用校验点可使会话在通信失效时<strong>从校验点&#x2F;同步点继续恢复通信</strong>，实现数据同步。适用于传输大文件。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>负责主机中两个进程的通信，即端到端的通信。传输单位是<strong>TCP报文段</strong>或<strong>UDP用户数据报</strong>。**<font color="#dd0000">只有它有可靠协议</font>**<br>功能：<br>可靠传输，不可靠传输（一般用于小文件）<br>差错控制（用来处理传输过程中出现的错误）<br>流量控制（当两台主机处理数据的速度不匹配时，会对速度过快的主机进行控制）<strong>端到端数据传输、主机与主机之间</strong><br><strong>复用分用</strong><br>复用:多个应用层进程可同时使用下面运输层的服务。<br>分用:运输层把收到的信息分别交付给上面应用层中相应的进程。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。<br>网络层传输单位是<strong>数据报</strong>。把数据报进行切割后，就是分组。<br><strong><font color="#dd0000">只有不可靠协议</font></strong><br>功能：<br><strong>路由选择</strong>（选择最合适的路由来传递数据）<br>流量控制<font color="#0000dd">（整个网络的流量控制）</font><br>差错控制<br><strong>拥塞控制</strong>（若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定撒施，缓解这种拥塞。）</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>主要任务是把网络层传下来的数据报组装<strong>成帧</strong>。<br>数据链路层&#x2F;链路层的传输单位是<strong>帧</strong>。<br><strong><font color="#dd0000">只有不可靠协议</font></strong><br>功能:<br>成帧（定义帧的开始和结束）<br>差错控制<br>流量控制<font color="#0000dd">（相邻结点的流量控制）</font><br><strong>访问（接入）控制</strong>（控制对信道的访问）<br><strong>传输层、网络层、数据链路层都有<font color="#dd0000">差错控制、流量控制</font></strong></p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>主要任务是在物理媒体上实现比特流的透明传输。<br>物理层传输单位是<strong>比特</strong>。<br>透明传输:指不管所传数据是什么样的比特组合,都应当能够在链路上传送。<br><strong><font color="#dd0000">只有不可靠协议</font></strong><br>功能：<br>定义接口特性<br>定义传输模式<br>单工 接受方和发送方已经确定，不能更改<br>半双工 介于两者之间。同一时间段内，只能有一个接受方或发送方，但是身份可以调换。<br>双工 可以同时当做接收方和发送方，类似于打电话<br>定义传输速率<br>比特同步<br>比特编码</p><table><thead><tr><th align="center"></th><th align="center">可靠</th><th align="center">连接</th><th align="center">确认</th></tr></thead><tbody><tr><td align="center">物理</td><td align="center">$×$</td><td align="center">$×$</td><td align="center">$×$</td></tr><tr><td align="center">数据</td><td align="center">$×$</td><td align="center">$×$</td><td align="center">$×$</td></tr><tr><td align="center">网络</td><td align="center">$×$</td><td align="center">$×$</td><td align="center">$×$</td></tr><tr><td align="center">传输(TCP)</td><td align="center">$√$</td><td align="center">$√$</td><td align="center">$√$</td></tr><tr><td align="center">传输(UDP)</td><td align="center">$×$</td><td align="center">$×$</td><td align="center">$×$</td></tr></tbody></table><p>PS:报文段$\rightarrow$报文交换；数据报$\rightarrow$分组交换<br>基于$TCP$的协议：HTTP、SMTP、POP3、FTP<br>基于$UDP$的协议：DNS、TFTP、DNCP<br>基于$IP$的协议：PING、ICMP、IGMP、OSPF</p><h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><h3 id="物理层编码和调制"><a href="#物理层编码和调制" class="headerlink" title="物理层编码和调制"></a>物理层编码和调制</h3><p>调制(数字信号调整为模拟信号)：幅移ASK；频移FSK；相移PSK；正交振幅QAM</p><p>编码(数字数据编码为数字信号)：</p><p><strong>NRZ</strong>：二进制数据的简写<br><img src="/2023/06/24/computer-network/2.png"><br><font color="#dd0000">10Base-T以太网都是曼彻斯特<br></font></p><h3 id="物理层带宽计算"><a href="#物理层带宽计算" class="headerlink" title="物理层带宽计算"></a><font color="#dd0000">物理层带宽计算</font></h3><h4 id="奈氏定理"><a href="#奈氏定理" class="headerlink" title="奈氏定理"></a>奈氏定理</h4><p>V为几进制码元<br>理想数据传输速率：$\mathbf{C&#x3D;Mlog_2V}(b&#x2F;s)$<br>$B&#x3D;2W&#x3D;M$ &emsp; W是理想低通信道带宽<br>$C&#x3D;2Wlog_2V$ &emsp; M是波特率$\leftarrow$调制速度<br>信道带宽是信道能通过最高频率和最低频率之差</p><h4 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h4><p>信道传输速率：$\mathbf{Wlog_2(1+S&#x2F;N)}$<br>$S&#x2F;N$为信噪比 &emsp; 信噪比$&#x3D;10lg\frac{S}{N}$(dB)<br>$S&#x2F;N&#x3D;10$，信噪比为10dB<br>$S&#x2F;N&#x3D;100$，信噪比为20dB</p><h3 id="物理层接口特性"><a href="#物理层接口特性" class="headerlink" title="物理层接口特性"></a>物理层接口特性</h3><p>机械特性：定义物理连接的特性，规定物理连接时所采用的<strong>规格、接口形状、引线数目、引脚数量和排列情况</strong>。<br>电气特性：规定传输二进制位时，线路上信号的<strong>电压范围、阻抗匹配、传输速率和距离限制</strong>等。<strong>通常有具体数值</strong><br>功能特性：指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途。<strong>无具体数值</strong><br>规程特性(过程特性）：定义各条物理线路的工作规程和<strong>时序关系</strong>。</p><h2 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层成帧方法和透明传输"><a href="#数据链路层成帧方法和透明传输" class="headerlink" title="数据链路层成帧方法和透明传输"></a>数据链路层成帧方法和透明传输</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<br>首部和尾部包含许多的控制信息，他们的一个重要作用:帧定界（确定帧的界限）。帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。<br>组帧的四种方法: 1.字符计数法，2.字符(节）填充法，3.零比特填充法，4.违规编码法。<br>为了透明传输：</p><ol><li>同步线路：零比特填充——连续5个1后加0</li><li>异步线路：用字符填充(默认情况)</li></ol><p><strong>字符计数填充</strong>：帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数。<br><img src="/2023/06/24/computer-network/3.png"></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。<br>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p><h3 id="数据链路层流量控制"><a href="#数据链路层流量控制" class="headerlink" title="数据链路层流量控制"></a><font color="#dd0000">数据链路层流量控制</font></h3><p><img src="/2023/06/24/computer-network/4.png"><br><strong>三者不同之处</strong><br><font size="2"></font></p><table><thead><tr><th align="center"></th><th align="center">最大发送窗口</th><th align="center">最小发送窗口</th><th align="center">最大接收窗口</th><th align="center">最小接收窗口</th><th align="center">累计确认</th><th align="center">有序接收</th><th align="center">最大利用率</th><th align="center">最大带宽</th></tr></thead><tbody><tr><td align="center">停止等待</td><td align="center">$1$</td><td align="center">$1$</td><td align="center">$1$</td><td align="center">$1$</td><td align="center">否</td><td align="center">是</td><td align="center">$\frac{t_1}{t_1+RTT+t_2}$</td><td align="center">$\frac{L}{t_1+RTT+t_2}$</td></tr><tr><td align="center">GBN</td><td align="center">$2^n-1$</td><td align="center">$2$</td><td align="center">$1$</td><td align="center">$1$</td><td align="center">是</td><td align="center">是</td><td align="center">$\frac{Wt_1}{t_1+RTT+t_2}$</td><td align="center">$\frac{WL}{t_1+RTT+t_2}$</td></tr><tr><td align="center">SR</td><td align="center">$2^{n-1}$</td><td align="center">$2^{n-1}$</td><td align="center">$2^{n-1}$</td><td align="center">$2$</td><td align="center">否</td><td align="center">否</td><td align="center">$\frac{Wt_1}{t_1+RTT+t_2}$</td><td align="center">$\frac{WL}{t_1+RTT+t_2}$</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>以上字符代表含义：<br>$RTT$：双向传播时延(题目中出现单向，要注意*2)<br>$t_1&#x3D;\frac{帧长}{发送速度(带宽)}$<br>$t_2$为确认帧，计算公式与$t_1$相同<br>$W$：窗口大小<br>$L$：数据帧长(bit))<br><strong>帧序列</strong>：$\lceil\log_2(W+1)\rceil$<br>**比特数$k$**：$W+1\leq2^k$<br>三者特点概括：<br>1.停止等待：有序发送，有序接收<br>2.GBN：累计确认；哪里出错从哪传(出错开始都要重传)<br>3.SR：选择确认，哪里出错传哪里(只传出错)<br>忽略帧开销即放弃$t_2$<br>收+发$\leq2^n$，n为分组序号为几比特编码<br>收$\leq$发<br><font color="#dd0000">利用率高，帧长越小越好</font><br>利用率最大：$W&#x3D;\frac{t_1+RTT+t_2}{t_1}$<br>$t_1+RTT+t_2$为发送到收到确认的时间。</p><h3 id="数据链路层的介质访问控制"><a href="#数据链路层的介质访问控制" class="headerlink" title="数据链路层的介质访问控制"></a>数据链路层的介质访问控制</h3><p><img src="/2023/06/24/computer-network/5.png"><br>CSMA协议：<br>CS:载波侦听&#x2F;监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。<br>MA : 多点接入，表示许多计算机以多点接入的方式连接在一根总线上<br>CSMA仍会发生冲突</p><h4 id="CSMA-CD-用于有线局域网"><a href="#CSMA-CD-用于有线局域网" class="headerlink" title="CSMA&#x2F;CD(用于有线局域网)"></a>CSMA&#x2F;CD(用于有线局域网)</h4><ol><li>先听后发</li><li>边听边发</li><li>冲突停发</li><li>随机重发</li></ol><p>需知必要知识点：<br>争用期：最远两个端点端到端传播时延<em>2<br>最小帧长：$争用期</em>发送速率&#x3D;2*\frac{距离}{传播速率}*发送速率$<br>例：100Base-T &emsp;发送速率100Mb&#x2F;s&emsp;最小帧长64B&emsp;争用期5.12μs</p><h4 id="CSMA-CA-用于无线局域网"><a href="#CSMA-CA-用于无线局域网" class="headerlink" title="CSMA&#x2F;CA(用于无线局域网)"></a>CSMA&#x2F;CA(用于无线局域网)</h4><p>特点：<br>&emsp;1. 用于无线局域网\<br>&emsp;2. 冲突避免协议；但无法完全避免\<br>&emsp;3. 无连接有确认\<br>&emsp;4. 信道预约技术(能量检测；载波检测；RTS与CTS预约)</p><p>最大以太网数据帧：1518B &emsp;数据部分1500B</p><h3 id="网桥和以太网交换机及其工作原理"><a href="#网桥和以太网交换机及其工作原理" class="headerlink" title="网桥和以太网交换机及其工作原理"></a>网桥和以太网交换机及其工作原理</h3><p>交换机只可以隔离冲突域，广播域不可以<br>交换机方便实现虚拟局域网VLAN&emsp;VLAN可以隔离广播域和冲突域<br>1.直通式交换机：只检查目的地址&emsp;以太网帧64B；目的地址6B<br>快、缺乏安全智能<br>2.存储转发式交换机：检查整个帧，也就是64B(最小)<br>可靠性高，延迟大<br>自学习功能：<br><img src="/2023/06/24/computer-network/6.png"><br>PS：只记录发出的那一个，本例发出A和B分别发出一个帧<br>具体流程<br><img src="/2023/06/24/computer-network/8.png"><br>设备相关总结<br><img src="/2023/06/24/computer-network/7.png"></p><h3 id="IEEE-802-11-无线局域网"><a href="#IEEE-802-11-无线局域网" class="headerlink" title="IEEE 802.11 无线局域网"></a>IEEE 802.11 无线局域网</h3><p><strong>例图</strong><br><img src="/2023/06/24/computer-network/42.png"></p><h4 id="MAC帧头格式"><a href="#MAC帧头格式" class="headerlink" title="MAC帧头格式"></a>MAC帧头格式</h4><p><img src="/2023/06/24/computer-network/43.png"><br>地址1：接收端<br>地址2：发送端<br>地址3：目的地址(传统802.3的MAC中的地址)  AP连接路由器</p><h4 id="3个地址具体情况总览"><a href="#3个地址具体情况总览" class="headerlink" title="3个地址具体情况总览"></a>3个地址具体情况总览</h4><p>DA:目的地址  帧的最终接收方<br>BSSID:AP的MAC地址<br>SA:源地址  产生帧的地址<br>RA:接收地址 帧的下一跳接收方地址<br>TA:传送地址 帧的上一跳发送方地址<br><img src="/2023/06/24/computer-network/44.png"> </p><p>例：如例图所示，假设H1$\rightarrow$H2<br>MAC三地址应为：<br>H1发送：H2&emsp;AP&emsp;H1<br>H2接收：AP&emsp;H1&emsp;H2</p><h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>主要功能：1.差错控制；2.询问与回答<br><strong>差错控制</strong>(差错报告报文)<br>类型：1.终点不可达（无法交付）；2.源点抑制（拥塞对数据）；3.超时（TTL&#x3D;0）；4.参数问题（首部字段有问题）；5.改变路由&#x2F;重定向（出现更好的路由）</p><p><strong>不发送ICMP报文的情况</strong>：<br>1.对ICMP差错报告报文不再发送ICMP差错报告报文。<br>2.对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。<br>3.对具有组播地址的数据报都不发送ICMP差错报告报文。<br>4.对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。<br><strong>询问与回答</strong>(询问报文)<br>主要类型：1.<strong>回送请求和回答报文</strong>(测试目的站是否可达以及了解其相关状态)；2.<strong>时间戳请求和回答报文</strong>(用来进行时钟同步和测量时间)；(以下不常用)3.掩码地址请求和回答；4.路由器询问和通告<br>ICMP和IGMP都是网路层协议，二者都是对网路层提供服务，网路层也对它们提供服务</p><h4 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h4><p>根据目的主机的IP，<br>第1种情况：查出对应的物理地址，写入MAC帧<br>第2种情况：查不出，则MAC帧为FF-FF-FF-FF-FF-FF，广播<strong>ARP请求分组</strong>。目的主机收到后发出<strong>ARP响应分组(单播)<strong>，ARP响应分组中有IP和MAC的映射。源主机收到后，将映射写入ARP缓存，重新根据MAC发数据。<br>而若是不在一个局域网内，则要通过一个</strong>路由器</strong>，则<strong>目的地址的MAC</strong>应该为<strong>路由器的物理地址</strong>，其余IP和源地址MAC不变。但从路由器转发出去的源MAC要变为路由器的端口地址<br>简单例子：<br>ARP请求分组(广播)&emsp;$IP_A$&emsp;$IP_B$&emsp;$MAC_A$(源)&emsp;$FF-FF(FF*6)$(目的)<br>ARP响应分组(单播)&emsp;$IP_B$&emsp;$IP_A$&emsp;$MAC_B$&emsp;$MAC_A$</p><h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><p><img src="/2023/06/24/computer-network/32.png"></p><h3 id="IP地址和路由转发"><a href="#IP地址和路由转发" class="headerlink" title="IP地址和路由转发"></a><font color="#dd0000">IP地址和路由转发</font></h3><p>子网划分：1.主机优先$\rightarrow$不等大网络；2.网络优先$\rightarrow$等大网络<br>不等大网络用哈夫曼编码实现，前缀不等长且不相同。<br>例：<img src="/2023/06/24/computer-network/10.png"><br>路由转发：1.最长前缀；2.路由表项<br><strong>常见题型</strong>：<br>IP地址&#x2F;24 &emsp;根据掩码是从24位到32位。如掩码：255.255.255.248。其中248即1111 1000。<strong>“1”的个数即划分子网的个数</strong>，<strong>“0”的个数为每个子网可分配的主机数</strong>。比如该例主机数应为$2^3-2$，之所以要<strong>减2</strong>，因为有两个地址已经被分配出去了，一个是全0网络号，一个是全1广播号<br><strong>无分类变址CIDR</strong>：将多个子网聚合成一个较大子网，叫做构成超网，或路由聚合<br>例：198.168.2.0和198.168.2.130聚合为192.168.2.0&#x2F;24<br><strong>路由协议</strong></p><h4 id="RIP协议（距离向量算法）"><a href="#RIP协议（距离向量算法）" class="headerlink" title="RIP协议（距离向量算法）"></a>RIP协议（距离向量算法）</h4><p>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录(即一组距离）。距离:通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达。<br><strong>应用层</strong>协议，使用<strong>UDP</strong>发送<br>要点：<strong>按照既定的时间间隔向相邻路由器告知它已知的全部路由表</strong><br><font color="#dd0000">“坏消息传的慢”</font><br>总结问题：<br><em><strong>问题：和谁交换？多久交换一次？交换什么？</strong></em><br>答：相邻路由器；每30秒(通常)；路由表</p><h4 id="OSPF协议（链路状态算法）"><a href="#OSPF协议（链路状态算法）" class="headerlink" title="OSPF协议（链路状态算法）"></a>OSPF协议（链路状态算法）</h4><p>开放最短路径优先OSPF协议<br>传递协议<strong>IP</strong>，<strong>网络层</strong>协议，在链路状态发生改变时向所有路由器发送，发送相邻路由器的链路状态。<br><font color="#dd0000">没有“坏消息传的慢”</font><br>总结问题：<br><em><strong>问题：<u>和谁交换？多久交换一次？交换什么？</u></strong></em><br>答：所有路由器发送；链路状态发生改变时；相邻所有路由器的链路状态</p><h4 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h4><p><strong>自治</strong>系统之间的使用的协议就是BGP协议。<br><strong>应用层</strong>协议，使用<strong>TCP</strong>发送<br>总结问题：<br><em><strong>问题：<u>和谁交换？多久交换一次？交换什么？</u></strong></em><br>答：与其他AS自治系统的BGP发言人；发生变化时更新有变化的部分；交换网络可到达信息，即要到达某个网络所要经过的一系列AS</p><h4 id="三者区别总结"><a href="#三者区别总结" class="headerlink" title="三者区别总结"></a>三者区别总结</h4><p><img src="/2023/06/24/computer-network/24.png"></p><h4 id="重要题型：根据路由表转发IP分组的步骤"><a href="#重要题型：根据路由表转发IP分组的步骤" class="headerlink" title="重要题型：根据路由表转发IP分组的步骤"></a>重要题型：根据路由表转发IP分组的步骤</h4><p>1.目的IP地址 AND(相与) 子网掩码 &#x3D; 网络地址<br>2.判断该网络地址是否与表项中的网络地址相等<br>3.找到最长前缀地址<br>PS：点对点链路一定是<font color="#dd0000">&#x2F;30</font></p><p><font color="#dd0000">主机是否在同一网段根据子网掩码与本机IP相与得到网络号，网络号是否一致</font></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>a)<br>在主机向目的主机发送消息时，不在同一个网络，且会发生NAT转换(经过一个路由器且网络地址变换大，如A$\rightarrow$B,B$\rightarrow$C)这里的ABC为网络类别<br><img src="/2023/06/24/computer-network/26.png"><br>即：<br>&emsp;1.主机到路由器<br>&emsp;源地址：主机IP<br>&emsp;目的地址：目的主机IP(可能是外网IP地址)<br>&emsp;2.路由器到目的主机 <strong>(内网到外网)</strong><br>&emsp;源地址：路由器出发端口地址<br>&emsp;目的地址：目的主机IP<br>&emsp;3.路由器到目的主机 <strong>(外网到内网)</strong><br>&emsp;源地址：不变<br>&emsp;目的地址：内网目的IP地址<br>b)<br>默认网关一般是主机通向路由器，路由器那端的IP地址<br>若网关不一致，则无法通过路由器传递消息<br>比如：1.通过路由器访问Internet<br>&emsp;&emsp;&emsp;2.通过路由器访问不同子网(掩码相同的为同一子网)<br>c)</p><p><img src="/2023/06/24/computer-network/11.png"><br>简单总结常见情况：<br>0.0.0.0：①本网络；②本主机；③OSPF的根区域 <strong><font color="#dd0000">不能作为目的IP、能作为源IP</font></strong><br>255.255.255.255：①广播；②广播请求地址 <strong><font color="#dd0000">能作为目的IP、不能作为源IP</font></strong></p><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a><font color="#dd0000">子网划分</font></h3><p>DNS、FTP、HTTP、DHCP为特定主机路由，其子网掩码为255.255.255.255<br>默认路由是连接互联网的蓝牙。在路由表的最后</p><table><thead><tr><th align="center">0.0.0.0</th><th align="center">0.0.0.0</th></tr></thead><tbody><tr><td align="center">目的主机IP</td><td align="center">子网掩码</td></tr><tr><td align="center">若要子网还可以分配主机地址：总数-全0-全1-路由器端口</td><td align="center"></td></tr></tbody></table><h4 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a><font color="#dd0000">路由转发</font></h4><p>注意聚合，尤其是题目中特别提到“路由项尽可能少”<br>按照最长匹配原则转发</p><p>TTL是经过一个路由器就-1</p><p>网络地址变化大的（比如从A$\rightarrow$B,B$\rightarrow$C,C$\rightarrow$D）特别是连接Internet，路由器要进行NAT转换<br>默认端口为80</p><h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a><font color="#dd0000">IP数据报分片</font></h3><p>IP分组<strong>首部20B</strong><br><strong>MTU</strong>为链路层能承载的最大传递单元<br>若IP数据报大于MTU，就要进行<strong>分片</strong><br>例：4000B大小的IP数据报 &emsp; MTU为：1500B<br>则IP数据报信息为：首部20B+有效数据分为1480.1480.1020(必须要求是8的倍数，除了最后一片)<br><img src="/2023/06/24/computer-network/25.png"></p><h3 id="互联设备"><a href="#互联设备" class="headerlink" title="互联设备"></a>互联设备</h3><p><img src="/2023/06/24/computer-network/12.png"><br>在VLAN中，交换机、路由器、集线器都可以一直广播域。<br>一个路由器，一根一个广播域<br>一个交换机，一根线一个冲突域(与路由器相连的不算)</p><h2 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层功能与协议"><a href="#传输层功能与协议" class="headerlink" title="传输层功能与协议"></a>传输层功能与协议</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>简单注意事项：<br><font color="#dd0000">首部有20B</font><br>序号应该就是收到的确认号ack<br>确认号应该是收到的序号+有效载荷</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>简单注意事项：<br><font color="#dd0000">首部有8B</font><br>复用：源端口<br>分用：目的端口<br>差错检验不通过直接丢弃</p><h3 id="传输层拥塞控制-TCP"><a href="#传输层拥塞控制-TCP" class="headerlink" title="传输层拥塞控制(TCP)"></a>传输层拥塞控制(TCP)</h3><h4 id="慢开始和拥塞避免-超时情况"><a href="#慢开始和拥塞避免-超时情况" class="headerlink" title="慢开始和拥塞避免 超时情况"></a>慢开始和拥塞避免 超时情况</h4><ul><li>刚开始进行指数增长($*2$)，拥塞窗口$cwnd&#x3D;1$到达ssthresh慢开始门限(阈值) 之后，进行加法增长($+1$)。</li><li>遇到网络拥塞之后，降到初始值，重复之前的步骤。新的 ssthresh设为拥塞时窗口大小的一半，即$ssthresh&#x3D;当前cwnd&#x2F;2$</li><li>而当$2cwnd&gt;ssthresh$，下一个RTT的cwnd等于ssthresh,而不是2cwnd。如当前cwnd&#x3D;8，ssthresh&#x3D;12，下一个应该是cwnd应该是12而不是你16</li><li>以上为老方案，遇到拥塞会从1开始，与以下的新方案不同<br><img src="/2023/06/24/computer-network/13.png"><br><img src="/2023/06/24/computer-network/33.png"></li></ul><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>快重传：发送方收到3个重复的ACK报文，直接重传不等待超时<br>快恢复：遇到拥塞不从1开始，而是从新的ssthresh开始<br>PS：发送窗口cwnd不能超出接收方设定的接受窗口大小<br><img src="/2023/06/24/computer-network/14.png"></p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/2023/06/24/computer-network/15.png"></p><p>第1和2次握手，不发送数据<br>第3次可以选择携带数据发送，也可以不用，且之后的ACK均为1</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2023/06/24/computer-network/16.png"><br>题目中会出现考点：<br>ACK，SYN，FIN一定有一个为1<br>正确情况：等于0即不会出现</p><ul><li>SYN&#x3D;1，ACK&#x3D;0</li><li>SYN&#x3D;1，ACK&#x3D;1</li><li>SYN&#x3D;0，ACK&#x3D;1</li><li>FIN&#x3D;1，ACK&#x3D;0</li><li>FIN&#x3D;0，ACK&#x3D;1</li><li>FIN&#x3D;1，ACK&#x3D;1</li></ul><p><strong>SYN</strong>：SYN为1，表明这是一个<font color="#0099ff">连接请求&#x2F;连接接受</font>报文<br><strong>FIN</strong>：FIN为1，表明此报文段<font color="#0099ff">发送方</font>数据已发送完，要求释放连接<br><strong>ACK</strong>：除了第一次，之后均为1<br>注意事项：<br>1.发送方收到确认，拥塞窗口+1<br>如收到第8个确认，cwnd&#x3D;8+1&#x3D;9<br>2.发送窗口&#x3D;min{接收窗口，拥塞窗口}<br>3.最短释放连接就是将中间两次挥手合并，一共是1.5RTT</p><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p><img src="/2023/06/24/computer-network/34.png"></p><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户&#x2F;服务器模型"></a>客户&#x2F;服务器模型</h4><p><img src="/2023/06/24/computer-network/35.png"></p><h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><p><img src="/2023/06/24/computer-network/36.png"></p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>域名系统DNS </p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>com有一个点，就是 根<br><img src="/2023/06/24/computer-network/17.png"></p><h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><p>一般采用<strong>UDP</strong><br><img src="/2023/06/24/computer-network/18.png"></p><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>域名解析主要有两种方法： ①递归（考别人）②迭代（靠自己）<br><img src="/2023/06/24/computer-network/19.png"><br>注意事项：<br>以<a href="http://www.abc.com为例,需要3次查询+本地域名1次/">www.abc.com为例，需要3次查询+本地域名1次</a><br>若有缓存，则无需查询<br><font color="#dd0000">注意：查询不等同于访问所需时间。一般最多查询4次，最少0次。<br>但访问某内容再接收这一部分所需时间，还需要先建立TCP连接，再接收信息，且本地域名查询时间一般是忽略的。最长时间5RTT，最短2RTT</font></p><h3 id="www和HTTP"><a href="#www和HTTP" class="headerlink" title="www和HTTP"></a>www和HTTP</h3><h4 id="WWWW万维网"><a href="#WWWW万维网" class="headerlink" title="WWWW万维网"></a>WWWW万维网</h4><p>三个部分：</p><ul><li><p>URL<br><img src="/2023/06/24/computer-network/20.png"></p></li><li><p>HTTP 超文本传输协议</p></li><li><p>HTML 超文本标记语言</p></li></ul><h4 id="HTTP-TCP"><a href="#HTTP-TCP" class="headerlink" title="HTTP(TCP)"></a>HTTP(TCP)</h4><p>特点：<br>无状态、本身无连接<br>可持久连接也可非持久<br>用Cookie加数据库的方式来跟踪用户活动</p><h3 id="FTP协议-文件传输协议-TCP"><a href="#FTP协议-文件传输协议-TCP" class="headerlink" title="FTP协议(文件传输协议)(TCP)"></a>FTP协议(文件传输协议)(TCP)</h3><p>FTP用两个并行的TCP连接，一个控制连接(传控制信息)，一个数据连接(传文件&#x2F;选择权在客户机)<br><img src="/2023/06/24/computer-network/21.png"></p><h3 id="SWTP和POP3协议-TCP"><a href="#SWTP和POP3协议-TCP" class="headerlink" title="SWTP和POP3协议(TCP)"></a>SWTP和POP3协议(TCP)</h3><h4 id="SWTP协议"><a href="#SWTP协议" class="headerlink" title="SWTP协议"></a>SWTP协议</h4><p>SMAP协议：简单邮件传输 端口：25<br>SMAP只支持7位ASCII，不支持视频、声音、超文本、图像(需要通过MIME)，拒绝太长的文件。<br><img src="/2023/06/24/computer-network/22.png"></p><h4 id="POP3-邮局协议"><a href="#POP3-邮局协议" class="headerlink" title="POP3 邮局协议"></a>POP3 邮局协议</h4><p><img src="/2023/06/24/computer-network/23.png"></p><h2 id="数据封装格式"><a href="#数据封装格式" class="headerlink" title="数据封装格式"></a>数据封装格式</h2><h3 id="TCP报文段、IP分组、MAC帧结构对比"><a href="#TCP报文段、IP分组、MAC帧结构对比" class="headerlink" title="TCP报文段、IP分组、MAC帧结构对比"></a>TCP报文段、IP分组、MAC帧结构对比</h3><p><img src="/2023/06/24/computer-network/37.png"><br><img src="/2023/06/24/computer-network/38.png"></p><h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3><p><img src="/2023/06/24/computer-network/39.png"></p><h3 id="IP分组"><a href="#IP分组" class="headerlink" title="IP分组"></a>IP分组</h3><h4 id="IP分组头结构"><a href="#IP分组头结构" class="headerlink" title="IP分组头结构"></a>IP分组头结构</h4><p><img src="/2023/06/24/computer-network/28.png"><br><img src="/2023/06/24/computer-network/31.png"></p><p><img src="/2023/06/24/computer-network/30.png"></p><h4 id="IP数据报的数据部分"><a href="#IP数据报的数据部分" class="headerlink" title="IP数据报的数据部分"></a>IP数据报的数据部分</h4><p><img src="/2023/06/24/computer-network/29.png"></p><h3 id="MAC帧"><a href="#MAC帧" class="headerlink" title="MAC帧"></a>MAC帧</h3><p><img src="/2023/06/24/computer-network/27.png"></p><h2 id="综合——访问www-cskaoyan-com服务器的完整过程"><a href="#综合——访问www-cskaoyan-com服务器的完整过程" class="headerlink" title="综合——访问www.cskaoyan.com服务器的完整过程"></a>综合——访问<a href="http://www.cskaoyan.com服务器的完整过程/">www.cskaoyan.com服务器的完整过程</a></h2><p><img src="/2023/06/24/computer-network/40.png"><br><img src="/2023/06/24/computer-network/41.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构笔记</title>
      <link href="/2023/06/23/data-structure/"/>
      <url>/2023/06/23/data-structure/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表、栈、队列"><a href="#线性表、栈、队列" class="headerlink" title="线性表、栈、队列"></a>线性表、栈、队列</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><h5 id="顺序表的存储结构-数据-当前长度"><a href="#顺序表的存储结构-数据-当前长度" class="headerlink" title="顺序表的存储结构 (数据[ ],当前长度)"></a>顺序表的存储结构 (数据[ ],当前长度)</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 20             &#x2F;&#x2F;存储空间初始分配量typedef int ElemType;          &#x2F;&#x2F;ElemType的类型根据实际情况而定（此行可忽略）typedef struct&#123;    ElemType data[MAXSIZE];    &#x2F;&#x2F;数组存储数据元素，最大值为MAXSIZE    int length;                &#x2F;&#x2F;线性表当前长度&#125;SqList;                       &#x2F;&#x2F;顺序表类型定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;插入操作Status ListInsert(SqList* L, int i, ElemType e)&#123;    if (L.length &gt;&#x3D; MAXSIZE)          &#x2F;&#x2F;顺序表已满        return false;     if (i&lt;1 || i&gt;L.length+1)        return false;                 &#x2F;&#x2F;当i不在范围内    for (int j &#x3D; L.length - 1;j &gt;&#x3D; i - 1;j--)             L.data[j + 1] &#x3D; L.data[j];    &#x2F;&#x2F;将插入位置及之后的元素后移一位*&#x2F;    L.data[i - 1] &#x3D; e;                &#x2F;&#x2F;将新元素插入    L.length++;                       &#x2F;&#x2F;表长加1    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最好的情况：插入到表尾，移动0次，时间复杂度O(1)<br>最坏的情况：插入到表头，移动n次，时间复杂度O(n)<br>平均情况：n&#x2F;2次<br>时间复杂度：O(n)</p><h5 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;删除操作Status ListDelete(SqList* L, int i, ElemType* e)&#123;    if (L.length &#x3D;&#x3D; 0)        return false;                 &#x2F;&#x2F;线性表为空    if (i&lt;1 || i&gt;L.length)        return false;                 &#x2F;&#x2F;删除位置不正确    e &#x3D; L.data[i - 1];    for (int j &#x3D; i ;j &lt; L.length;j++)        L.data[j - 1] &#x3D; L.data[j];    &#x2F;&#x2F;将删除位置后继元素前移    L.length--;                       &#x2F;&#x2F;线性表减1    return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最好的情况：删除顺序表中最后一个元素，移动0次，时间复杂度O(1)<br>最坏的请况：删除顺序表中第一个元素，移动n-1次，时间复杂度O(n)<br>平均情况：移动（n-1）&#x2F;2<br>时间复杂度：O(n)</p><h5 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;顺序表按数据值查找，返回位序Status LocateElem(SqList L, ElemType e)&#123;    int i;    for (i &#x3D; 0;i &lt; L.length;i++)        if (L.data[i] &#x3D;&#x3D; e)            return i + 1;         &#x2F;&#x2F;查找成功    return 0;                     &#x2F;&#x2F;查找失败&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最好的情况：查找1次，时间复杂度O(1)<br>最坏的情况：查找n次，时间复杂度O(n)<br>平均情况：（1+n）&#x2F;2次<br>时间复杂度为：O(n)</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><h5 id="单链表的存储结构-数据-，向后指针-从头结点出发向后"><a href="#单链表的存储结构-数据-，向后指针-从头结点出发向后" class="headerlink" title="单链表的存储结构 (数据[ ]，向后指针)从头结点出发向后"></a>单链表的存储结构 (数据[ ]，向后指针)<font color="#dd0000">从头结点出发向后</font><br></h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct LNode&#123;       &#x2F;&#x2F;定义单链表结点类型    ElemType data;          &#x2F;&#x2F;数据域    struct LNode *next;     &#x2F;&#x2F;指针域&#125;LNode, *LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>问题：<u>头结点和头指针的区别？</u></strong></em><br>答：不管带不带头结点，头指针始终指向链表的<font color="#dd0000">第一个结点</font>，而头结点是<font color="#dd0000">带头结点链表</font>中的第一个结点，结点内通常不存储信息。</p><h5 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h5><p><strong>头插</strong><br>头指针L <code>s-&gt;next=L-&gt;next;L-&gt;next=s</code><br>头插法建立单链表，读入数据的顺序与生成的链表中元素的顺序是<font color="#dd0000">相反</font>的</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkList CreatList1(LinkList &amp;L)&#123;     LNode *s; &#x2F;&#x2F;辅助指针    int x;     L&#x3D;(LinkList)malloc(sizeof(LNode)); &#x2F;&#x2F;创建头结点    L-&gt;next&#x3D;NULL; &#x2F;&#x2F;初始为空链表    scanf(”%d”,&amp;x); &#x2F;&#x2F;输入结点的值    while(x!&#x3D;9999)&#123; &#x2F;&#x2F;输入9999表示结束        s&#x3D;(LNode*)malloc(sizeof(LNode)); &#x2F;&#x2F;创建新结点        s-&gt;data&#x3D;x;        s-&gt;next&#x3D;L-&gt;next;        L-&gt;next&#x3D;s; &#x2F;&#x2F;将新结点插入表中，L为头指针    scanf(”%d”,&amp;x); &#x2F;&#x2F;读入下一个结点值&#125;    return L;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>尾插</strong><br>尾指针 r-&gt;next&#x3D;s; r&#x3D;s<br>尾插法建立单链表，读入数据的顺序与生成的链表中元素的顺序是<font color="#dd0000">相同</font>的</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkList CreatList2(LinkList &amp;L)&#123;     int x;     L&#x3D;(LinkList)malloc(sizeof(LNode));    LNode *s, *r&#x3D;L; &#x2F;&#x2F;r为表尾指针 指向表尾    scanf(”%d”,&amp;x); &#x2F;&#x2F;输入结点的值    while(x!&#x3D;9999)&#123; &#x2F;&#x2F;输入9999表示结束        s&#x3D;(LNode *)malloc(sizeof(LNode));         s-&gt;data&#x3D;x;        r-&gt;next&#x3D;s;         r&#x3D;s; &#x2F;&#x2F;r指向新的表尾结点        scanf(”%d”,&amp;x);    &#125;    r-&gt;next&#x3D;NULL; &#x2F;&#x2F;尾结点指针置空    return L;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">p&#x3D;GetElem(L,i-1);&#x2F;&#x2F;取指向插入位置的前驱结点的指针s-&gt;next&#x3D;p-&gt;next;&#x2F;&#x2F;令新结点*s的指针域指向*p的后继结点p-&gt;next&#x3D;s;&#x2F;&#x2F;.令结点*p的指针域指向新插入的结点*s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">p&#x3D;GetElem(L,i-1);&#x2F;&#x2F;查找输出位置的前驱结点q&#x3D;p-&gt;next;&#x2F;&#x2F;令q指向删除结点p-&gt;next&#x3D;q-&gt;next;&#x2F;&#x2F;将*q结点从链中“断开”free(q);&#x2F;&#x2F;释放结点的存储空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h5><p><strong>按序号查找</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LNode * GetElem(LinkList L,int i)&#123;    int j&#x3D;1; &#x2F;&#x2F;计数，初始为1    LNode *p&#x3D;L-&gt;next; &#x2F;&#x2F;第一个结点指针赋给p    if(i&#x3D;&#x3D;0) return L; &#x2F;&#x2F;若i等于0，则返回头结点    if(i&lt;1) return NULL; &#x2F;&#x2F;若i无效，则返回NULL    while(p&amp;&amp;j&lt;i)&#123; &#x2F;&#x2F;从第1个结点开始找，查找第i个结点        p&#x3D;p-&gt;next;        j++;    &#125;    return p; &#x2F;&#x2F;返回第i个结点的指针，如果i大于表长，直接返回p即可&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>按值查找</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">LNode *LocateElem(LinkList L,ElemType e)&#123;    LNode *p&#x3D;L-&gt;next;    while(p!&#x3D;NULL&amp;&amp;p-&gt;data!&#x3D;e)&#x2F;&#x2F;从第1个结点开始查找data域为e的结点        p&#x3D;p-&gt;next;    return p; &#x2F;&#x2F;找到后返回该结点指针，否则返回NULL&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><h5 id="双链表的存储结构-数据-，向后指针，向前指针"><a href="#双链表的存储结构-数据-，向后指针，向前指针" class="headerlink" title="双链表的存储结构 (数据[ ]，向后指针，向前指针)"></a>双链表的存储结构 (数据[ ]，向后指针，向前指针)</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct DNode&#123; &#x2F;&#x2F;定义单链表结点类型    ElemType data; &#x2F;&#x2F;数据域    struct DNode *prior,*next; &#x2F;&#x2F;前驱和后继指针&#125;DNode, *DLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">s-&gt;next&#x3D;p-&gt;next;p-&gt;next-&gt;prior&#x3D;s;s-&gt;prior&#x3D;p;p-&gt;next&#x3D;s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">p-&gt;next&#x3D;q-&gt;next;q-&gt;next-&gt;prior&#x3D;p;free(q);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><h5 id="顺序栈的存储结构"><a href="#顺序栈的存储结构" class="headerlink" title="顺序栈的存储结构"></a>顺序栈的存储结构</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MaxSize 50 &#x2F;&#x2F;定义栈中元素的最大个数typedef struct&#123;    Elemtype data[MaxSize]; &#x2F;&#x2F;存放栈中元素    int top; &#x2F;&#x2F;栈顶指针&#125; SqStack; &#x2F;&#x2F;顺序栈的简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈：LIFO 先进先出<br>n个元素进栈，一共有$\frac{1}{n+1}$$C^n_ {2n}$出栈方式<br>进栈：<code>push(e);t++;</code> 出栈：<code>t--;pop()</code><br><code>top</code>指向栈顶下一个空位置，允许插入删除<br><code>bottom</code>指向栈底，固定，不允许插入输出<br>空栈的判定条件：<code>top==-1</code><br>满栈的判定条件：<code>top==MaxSize-1</code><br>栈中数据元素个数为：<code>top+1</code></p><h5 id="对顶栈-共享栈"><a href="#对顶栈-共享栈" class="headerlink" title="对顶栈&#x2F;共享栈"></a>对顶栈&#x2F;共享栈</h5><p><img src="/2023/06/23/data-structure/1.png"><br>0号栈栈顶：top0<br>1号栈栈顶：top1<br>进栈：0号进栈<code>top0++</code>;1号进栈<code>top1--</code><br>出栈：与进栈相反<br>空栈的判定条件：<code>top0+1==top1</code><br>满栈的判定条件：<code>top0==-1；top1==MaxSize</code></p><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><h5 id="链栈的存储结构"><a href="#链栈的存储结构" class="headerlink" title="链栈的存储结构"></a>链栈的存储结构</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct SNode&#123;    Elemtype data; &#x2F;&#x2F;存放栈中元素    struct SNode *next ; &#x2F;&#x2F;栈顶指针&#125; SNode，*SLink &#x2F;&#x2F;链栈的结点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="链栈的进栈"><a href="#链栈的进栈" class="headerlink" title="链栈的进栈"></a>链栈的进栈</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool Push(LinkStack *S, ElemType x)&#123;    SLink p&#x3D;(SLink)malloc(sizeof(SNode)); &#x2F;&#x2F;给新元素分配空间    p-&gt;data&#x3D;x; &#x2F;&#x2F;新元素的值    p-&gt;next&#x3D;S-&gt;top; &#x2F;&#x2F;p的后继指向栈顶元素    S-&gt;top&#x3D;p; &#x2F;&#x2F;栈顶指针指向新的元素    S-&gt;count++; &#x2F;&#x2F;栈中元素个数加1    return true; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上例代码为不带头结点<br>带头结点：p-&gt;next&#x3D;S-&gt;top-&gt;next; S-&gt;top-&gt;next&#x3D;p;<br>不带头结点：p-&gt;next&#x3D;S-&gt;top; S-&gt;top&#x3D;p; </p><h5 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool Pop(LinkStack *S, ElemType&amp;x)&#123;    if(S-&gt;top&#x3D;&#x3D;NULL) return false;    x&#x3D;S-&gt;top-&gt;data; &#x2F;&#x2F;栈顶元素值    Slink p&#x3D;S-&gt;top; &#x2F;&#x2F;辅助指针    S-&gt;top&#x3D;S-&gt;top-&gt;next; &#x2F;&#x2F;栈顶指针后移    free(p); &#x2F;&#x2F;释放被删除数据的存储空间    S-&gt;count--; &#x2F;&#x2F;栈中元素个数减一    return true; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上例代码为不带头结点<br>不带头结点：p&#x3D;S-&gt;top; S-&gt;top&#x3D;S-&gt;top-&gt;next; free(p);<br>带头结点：p&#x3D;S-&gt;top-&gt;next; S-&gt;top-&gt;next&#x3D;p-&gt;next; </p><h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><h5 id="1-函数与递归-先调用后执行-用栈来保留先调用的函数，出栈再执行"><a href="#1-函数与递归-先调用后执行-用栈来保留先调用的函数，出栈再执行" class="headerlink" title="1.函数与递归(先调用后执行 用栈来保留先调用的函数，出栈再执行)"></a>1.函数与递归(先调用后执行 用栈来保留先调用的函数，出栈再执行)</h5><h5 id="2-表达式求值-前缀-中缀-后缀"><a href="#2-表达式求值-前缀-中缀-后缀" class="headerlink" title="2.表达式求值(前缀 中缀 后缀)"></a>2.表达式求值(前缀 中缀 后缀)</h5><p>例：<br>中缀表达式：A+B*(C-D)-E&#x2F;F<br>后缀表达式：ABCD-*+EF&#x2F;-<br>对应二叉树：数字在两边，符号在中间<br><img src="/2023/06/23/data-structure/2.png"><br>前序——&gt;前缀<br>中序——&gt;中缀<br>后序——&gt;后缀<br>计算机普遍利用后缀表达式计算，计算规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。<br><strong>中缀转后缀</strong><br>有两个栈，一个为数字栈，一个为符号栈<br>规则：<br>1.操作数直接入数字栈<br>2.遇到<code>(</code>入数字栈，直到遇到<code>)</code>将里面全部弹出<br>3.弹出栈中优先级高或者等于当前运算符中的所有运算符，直到遇到<code>(</code>。<br>在符号栈中，符号的优先级是不断上升的<br>比如以<code>(</code>为分界点,<code>*</code>和<code>/</code>一直在<code>+</code>和<code>-</code>上面，且不会有连续的同优先级出现。<br>如<code>+(-*</code>正确，<code>+(*-</code>错误</p><h5 id="3-进制转换"><a href="#3-进制转换" class="headerlink" title="3.进制转换"></a>3.进制转换</h5><h5 id="4-括号匹配"><a href="#4-括号匹配" class="headerlink" title="4.括号匹配"></a>4.括号匹配</h5><p>括号匹配算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列：FIFO 先进先出<br>双端队列：<br>1.输入受限，两端都可以出，只有一端可以入<br>2.输出受限，两端都可以入，只有一端可以出<br>队列的应用：1.排队；2.打印机；3.层次遍历；4.BFS；5.基数排序</p><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p><code>front</code>指队首；<code>rear</code>指队尾的下一个元素<br>队列空：<code>front==rear</code><br>队列满：<code>(rear+1)%MaxSize==front</code><br>入队：<code>rear=(rear+1)%MaxSize</code><br>出队：<code>front=(front+1)%MaxSize</code><br>长度：<code>(rear+MaxSize-front)%MaxSize</code></p><h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p>一般为带尾指针的单循环链表<br>插入：尾插，尾改头不改<br>删除：头插，头改尾不改；<font color="#dd0000">删除到最后，头尾都要改</font>。<br>入队：rear++；放入<br>&emsp;与单链表插入操作一致</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void EnQueue(LinkQueue &amp;Q，ElemType x)&#123;    s&#x3D;(LinkNode *)malloc(sizeof(LinkNode));    s-&gt;data&#x3D;x;     s-&gt;next&#x3D;NULL;     Q.rear-&gt;next&#x3D;s;    Q.rear&#x3D;s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出队：放出；front++<br>&emsp;头结点的后继结点出队</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">==</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">//空队</span>    p<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>    x<span class="token operator">=</span>p<span class="token operator">-></span>data<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>front<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">==</span>p<span class="token punctuation">)</span> Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span> <span class="token comment">//若原队列中只有一个结点，删除后变空</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的度：树中结点的最大度数<br>结点的度：子结点的个数<br>路径：两个结点之间的结点序列</p><p>1.结点数为所有结点度数+1<br>2.m度树，叶子结点个数$n_{0}&#x3D;n_{2}+2n_{3}+…(m-1)n_{m}+1$<br>$n_{2}$为度为2的结点个数</p><h3 id="二叉树和完全二叉树"><a href="#二叉树和完全二叉树" class="headerlink" title="二叉树和完全二叉树"></a><font color="#dd0000">二叉树和完全二叉树</font></h3><h4 id="二叉树的链式存储结构："><a href="#二叉树的链式存储结构：" class="headerlink" title="二叉树的链式存储结构："></a>二叉树的链式存储结构：</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment">//指向该结点的左、右孩子指针</span><span class="token punctuation">&#125;</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span> <span class="token comment">//二叉树结点结构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特殊性质："><a href="#特殊性质：" class="headerlink" title="特殊性质："></a>特殊性质：</h4><p>1.非空二叉树&emsp;叶子结点数$n_{0}$为度为2的结点数+1，即$\mathbf{n_{0}&#x3D;n_{2}+1}$<br>2.<strong>k</strong>层树至少有$\mathbf{2^{k-1}}$个结点<br>3.高度为<strong>h</strong>至多有个$\mathbf{2^{h-1}}$结点<br>4.具有<strong>n</strong>个节点的二叉树，最小高度$\lfloor\mathbf{log_2{n}+1}\rfloor$向下取整</p><h4 id="完全二叉树的独有性质"><a href="#完全二叉树的独有性质" class="headerlink" title="完全二叉树的独有性质"></a>完全二叉树的独有性质</h4><p>完全二叉树：除了最后一行，其余层全满<br>全满<strong>k</strong>层，一共$\mathbf{2^{k}-1}$个结点<br>1.<strong>n</strong>个结点深度：$\lfloor\mathbf{log_2{n}+1}\rfloor$向下取整或$\lceil\mathbf{log_2{(n+1)}}\rceil$向下取整<br>2.右子树最大I层，左子树最大I+1或I层<br>3.双亲结点 $\lfloor\mathbf{i&#x2F;2}\rfloor$<br>4.度为1的个数只有0或1<br>5.叶子结点出现在k层或者k-1层，k为深度<br>6.当该层编好后出现一结点为叶子结点或只有左子树，则之后都是叶子结点，如下图为某一层的最后结点<br><img src="/2023/06/23/data-structure/3.png"> 384之后都是叶子结点，所以叶子结点数：768-384&#x3D;384</p><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>先序：根左右<br>中序：左根右<br>后序：左右根<br>层次：按照层次遍历<br>中+层$\Rightarrow$层<br>中+后$\Rightarrow$后<br>中+先$\Rightarrow$先<br>先确定根，中序确定左右</p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>方便查找前驱、后继和遍历(前驱后继根据中序)<br>1.有左孩子，指向左孩子；无，则指向前驱<br>2.有右孩子，指向右孩子；无，则指向后继<br><em><strong>问题：<u>如何区分指针是指向左孩子还是前驱，或者指向右孩子还是后继？</u></strong></em><br>答：在二叉链表的结构基础上增加两个标志位<code>ltag</code>和<code>rtag</code><br>$ ltag&#x3D;<br>0，左孩子；<br>1，前驱<br>$<br>$ rtag&#x3D;<br>0，右孩子；<br>1，后继<br>$</p><h4 id="树、森林和二叉树转换"><a href="#树、森林和二叉树转换" class="headerlink" title="树、森林和二叉树转换"></a>树、森林和二叉树转换</h4><p>一般树转化为二叉树规则：<strong>左孩子不变，右孩子变为右兄弟</strong>，如下图所示：<br><img src="/2023/06/23/data-structure/4.png"><br>根右边一定为空，所以<strong>根据根的右子树情况，可判断森林中树的个数</strong><br>森林转化为二叉树规则：先将每棵树转化为二叉树，再将每棵树的根相连<br>$树\Rightarrow二叉树$：$先序\Rightarrow先序；$$后序\Rightarrow中序；$$中序\Rightarrow中序$</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>WPL带权路径最小<br>权重大的在上面，权重小的在下面<br>不够需要补0，&emsp;补几个，利用$n_0&#x3D;(m-1)n_m+1$，$n_m$为整数，所以$n_m&#x3D;\frac{n_0-1}{m-1}$最后得$n_0$<br>左0右1<br>只有0度和2度的结点<br><strong>前缀编码判定方法</strong>：<br>1.任何一个编码不能是一个编码的前缀<br>2.画树，找度为1的点，$n_1&#x3D;1$不能是前缀编码</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>度之和&#x3D;边*2<br>完全图边数：$\frac{n(n-1)}{2}$<br>顶点集<code>V</code> &emsp;边集<code>E</code><br>非连通：最多$\mathbf{C^2_ {n-1}}$条边<br>连通：最少$\mathbf{C^2_ {n-1}+1}$条边<br>强联通(顶点v到w或w到v都有路径)：最少$\mathbf{n}$条边<br>简单路径：顶点不重复 &emsp;简单回路：首尾相同其余不重复</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/2023/06/23/data-structure/5.png"><br>如图所得邻接矩阵：<br><br><img src="/2023/06/23/data-structure/31.png"></p><p>若是有向图，则是指向为1，例：<br><img src="/2023/06/23/data-structure/6.png"><br>如图所得邻接矩阵：<br><br><img src="/2023/06/23/data-structure/32.png"></p><p><font color="#dd0000">邻接矩阵唯一，遍历结果也唯一</font><br>空间复杂度：$O(n^2)$ &emsp; 遍历时间复杂度：$O(n^2)$</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p><strong><font color="#dd0000">适用于稀疏图(|E|远小于|V|^2)</font></strong></p><h5 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h5><p><img src="/2023/06/23/data-structure/7.png"></p><h5 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h5><p><img src="/2023/06/23/data-structure/8.png"><br><font color="#dd0000">邻接表不唯一，遍历结果不唯一。但若是已经给定邻接表，遍历结果唯一。</font><br>遍历时间复杂度：$O(n+e)$</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h4><p><strong>空间复杂度</strong>：<br>BFS需要借助一个<strong>队列</strong>，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要$\mathbf{O(|V|)}$的空间复杂度。<br><strong>时间复杂度</strong>：<br>1)邻接表：每个顶点入队一次，时间复杂度为$\mathbf{O(|V|)}$,对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为$\mathbf{O(|E|)}$。所以总的时间复杂度为$\mathbf{O(|V|+|E|)}$<br>2)邻接矩阵：每个顶点入队一次，时间复杂度为$\mathbf{O(|V|)}$,对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为$\mathbf{O(|V|)}$,所以总的时间复杂度为$\mathbf{O(|V|^2)}$</p><h4 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h4><p><strong>空间复杂度</strong>：<br>由于DFS是一个递归算法，递归是需要一个<strong>工作栈</strong>来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为$\mathbf{O(|V|)}$<br><strong>时间复杂度（与BFS相同）</strong>：<br>1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为$\mathbf{O(|E|)}$,访问顶点时间为$\mathbf{O(|V|)}$,所以总的时间复杂度为$\mathbf{O(|V|+|E|)}$<br>2)邻接矩阵：查找每个顶点的邻接点时间复杂度为$\mathbf{O(|V|)}$,对每个顶点都进行查找，所以总的时间复杂度为$\mathbf{O(|V|^2)}$</p><h3 id="图的应用——最小生成树的构造算法和性质"><a href="#图的应用——最小生成树的构造算法和性质" class="headerlink" title="图的应用——最小生成树的构造算法和性质"></a>图的应用——最小生成树的构造算法和性质</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>n个顶点，n-1条边<br>规则：<br>①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。<br>②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。<br>③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。<br>④反复执行②③直到所有所有顶点都加入到生成树中。<br><font color="#dd0000">PS:只有当图中每条边的权重均不相等时，Prim和Kruskal算法生成的MST一定唯一。而若是Kruskal能完成唯一判断，则基本上就是唯一的。</font><br>需要维护两个数组：<code>lowcost[n]</code>和<code>adjvex[n]</code>（n是图中的顶点数）<br><code>lowcost[n]</code>记录边长<br><code>adjvex[n]</code>记录该条边从那个顶点出发</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Void <span class="token function">MiniSpanTree_Prim</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> min<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//保存邻接顶点下标的数组</span>    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录当前生成树到剩余顶点的最小权值</span>    lowcost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//将0号顶点(以0号顶点作为第一个顶点)加入生成树</span>    adjvex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//由于刚开始生成树只有一个顶点 不存在边 干脆都设为0</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//除下标为0以外的所有顶点</span>        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将与下标为0的顶点有边的权值存入Lowcost数组</span>            djvex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//这些顶点的adjvex数组全部初始化为0</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//算法核心</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//只需要循环N-1次，N为顶点数</span>        min<span class="token operator">=</span><span class="token number">65535</span><span class="token punctuation">;</span> <span class="token comment">//tip：因为要找最小值，不妨先设取一个最大的值来比较</span>        j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//找出lowcost最小的 最小权值给min，下标给k</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//从1号顶点开始找</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">//不在生成树中的顶点而且权值更小的</span>                 min<span class="token operator">=</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//更新更小的值</span>                k<span class="token operator">=</span>j<span class="token punctuation">;</span>  <span class="token comment">//找到了新的点下标给k</span>            <span class="token punctuation">&#125;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//再看下一个顶点</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span><span class="token operator">%</span>d<span class="token operator">-></span><span class="token operator">%</span>d<span class="token punctuation">)</span>”<span class="token punctuation">,</span>adjvex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印权值最小的边</span>        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//将这个顶点加入生成树</span>        <span class="token comment">//生成树加入了新的顶点 从下标为1的顶点开始更新lowcost数组值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//如果新加入树的顶点k使得权值变小</span>            lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//更新更小的权值</span>            adjvex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>        <span class="token comment">//修改这条边邻接的顶点也就是表示这条边是从选出的顶点k指过来的方便打印     </span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度为<strong>O(n^2)</strong><br>而且时间复杂度只和n有关，所以适合<strong>稠密图</strong></p><h4 id="Kruskal-克鲁斯卡尔-算法"><a href="#Kruskal-克鲁斯卡尔-算法" class="headerlink" title="Kruskal(克鲁斯卡尔)算法"></a>Kruskal(克鲁斯卡尔)算法</h4><p>找最小边，不能形成回路</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>  <span class="token comment">//边的两个顶点</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span> <span class="token comment">//边的权值</span><span class="token punctuation">&#125;</span>Edge<span class="token punctuation">;</span>  <span class="token comment">//边结构体</span><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">=</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//循环向上寻找下标为x顶点的根</span>    <span class="token keyword">return</span>  x<span class="token punctuation">;</span>  <span class="token comment">//while循环结束时找到了根的下标</span><span class="token punctuation">&#125;</span>Edge edges<span class="token punctuation">[</span>MaxEdge<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//边数组</span><span class="token keyword">int</span> parent<span class="token punctuation">[</span>MaxVex<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//父亲顶点数组(并查集)</span>Void <span class="token function">MiniSpanTree_Kruskal</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>  i <span class="token punctuation">,</span> n <span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//按权值由小到大对边排列</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//初始化：各个顶点单独形成一个集合</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>arcnum <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//扫描每条边</span>        n<span class="token operator">=</span><span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//n是这条边的第一个顶点的根顶点所在下标</span>        m<span class="token operator">=</span><span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//m是这条边第二个顶点的根顶点所在下标</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">!=</span>m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//根顶点不相同 这条边不会构成环</span>             parent<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span>m<span class="token punctuation">;</span>  <span class="token comment">//并操作</span>            <span class="token comment">//作为生成树的一条边打印出来</span>            <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span><span class="token operator">%</span>d<span class="token operator">-></span><span class="token operator">%</span>d<span class="token punctuation">)</span> ”<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(|E|log|E|)$<br>主要时间耗费在排序上。排序和图中边的数量有关系，所以适合<strong>稀疏图</strong>。</p><h3 id="图的应用——AOV网和AOE网、拓扑排序、关键路径"><a href="#图的应用——AOV网和AOE网、拓扑排序、关键路径" class="headerlink" title="图的应用——AOV网和AOE网、拓扑排序、关键路径"></a>图的应用——AOV网和AOE网、拓扑排序、关键路径</h3><h4 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h4><p>有向网 &emsp;&lt;$V_i$,$V_j$&gt;,$V_i$完成必须先于$V_j$（无环），顶点表示活动，能被拓扑排序的便是AOE网</p><h4 id="拓扑排序（考得更多）"><a href="#拓扑排序（考得更多）" class="headerlink" title="拓扑排序（考得更多）"></a><font color="#dd0000">拓扑排序</font>（考得更多）</h4><p>不唯一<br>每个顶点最多一次；<br>A在B前面，则没有B到A的路径<br>从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。<br>由于拓扑排序需要删除边和顶点，所以使用邻接表存储图比较方便。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">TopologicalSort</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化栈，存储入度为0的顶点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将所有入度为0的顶点进栈</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//计数，记录当前已经输出的顶点数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//栈不空，则存在入度为0的顶点</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//栈顶元素出栈</span>        <span class="token function">pritnf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>d”<span class="token punctuation">,</span>G<span class="token punctuation">.</span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>ArcNode <span class="token operator">*</span>p<span class="token operator">=</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span> p<span class="token punctuation">;</span> p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            v<span class="token operator">=</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span> <span class="token comment">//取这条弧指向的顶点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">--</span>indegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//入度减1为0，则入栈</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">)</span><span class="token keyword">return</span>  false<span class="token punctuation">;</span>    <span class="token comment">//排序失败，有向图中有回路</span>    <span class="token keyword">else</span> <span class="token keyword">return</span>  true<span class="token punctuation">;</span> <span class="token comment">//拓扑排序成功</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：O(n+e)</p><h4 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h4><p>带权的有向无环，用顶点表示事件，<strong>用边表示活动</strong></p><h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><p>1.顶点事件发生，各条边活动才能开始；<br>2.各边活动结束，顶点事件才能发生<br>最大路径长度的路径：关键路径<br>关键路径上的活动：关键活动<br>工程最短时间：关键路径长度</p><p>1.加快关键活动缩短工期<br>2.关键路径不唯一，要缩短所有关键路径的公共部分或者都缩短</p><p>最早事件开始时间：正推法 &emsp;从头到该事件的<strong>最长</strong>路径  <strong>值最大</strong><br>最晚事件开始时间：倒推法 &emsp;从最大路径往前到该事件的<strong>最小</strong>路径  <strong>值最小</strong><br><font color="#dd0000">关键路径的最早发生时间和最晚发生时间是一样的！</font></p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra-迪杰斯特拉-算法-选择题中最难题"><a href="#Dijkstra-迪杰斯特拉-算法-选择题中最难题" class="headerlink" title="Dijkstra(迪杰斯特拉)算法 选择题中最难题"></a>Dijkstra(迪杰斯特拉)算法 选择题中最难题</h4><p><code>dist[]</code>：记录了从源点v0到其他各顶点当前的最短路径长度<br><code>path[]</code>：<code>path[i]</code>表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。<br><img src="/2023/06/23/data-structure/9.png"><br><strong>时间复杂度</strong>：迪杰斯特拉算法的核心部分在于一个双重循环，这个双重循环的内循环又是两个并列的单重for循环组成(找距离最小顶点和更新距离),任意取其中一个循环中的操作为基本操作，都可以得出迪杰斯特拉算法的时间复杂度为$\mathbf{O(n^2)}$ 其中n为图中的顶点数。</p><h4 id="Floyd-弗洛伊德-算法"><a href="#Floyd-弗洛伊德-算法" class="headerlink" title="Floyd(弗洛伊德)算法"></a>Floyd(弗洛伊德)算法</h4><p>求图中任意一对顶点间的最短路径的算法<br>递推产生一个n阶方阵序列$A^{(−1)}$，$A^{(0)}$，…，$A^{(k)}$，…，$A^{(n−1)}$<br>其中$A^{(k)}[i][j]$表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。<br>$A^{(k)}[i][j]&#x3D;Min{A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j]}$<br><strong>时间复杂度</strong>：弗洛伊德算法的核心为一个三重循环，所以时间复杂度为$\mathbf{O(n^3)}$ 其中n是图中的顶点数。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>仅适用于顺序存储，有序顺序表<br>时间复杂度：$\mathbf{O(log_2n)}$<br>1.默认使用$\lfloor\mathbf{\frac{low+high}{2}}\rfloor&#x3D;mid$向下取整<br>2.平均查找长度ASL取决于其树型结构。而树型结构只取决于元素个数<br>$ASL\approx$$log_2(n+1)-1$<br><img src="/2023/06/23/data-structure/10.png"><br>ASL成功&#x3D;（1+2+2+3+3+3+3+4)&#x2F;8&#x3D;21&#x2F;8<br>ASL失败&#x3D;（3+3+3+3+3+3+3+4+4)&#x2F;9&#x3D;29&#x2F;9</p><h3 id="BST二叉排序树的查找、插入和删除"><a href="#BST二叉排序树的查找、插入和删除" class="headerlink" title="BST二叉排序树的查找、插入和删除"></a>BST二叉排序树的查找、插入和删除</h3><p>BST二叉排序树:左小右大<br><img src="/2023/06/23/data-structure/11.png"></p><h4 id="查找-非递归"><a href="#查找-非递归" class="headerlink" title="查找(非递归)"></a>查找(非递归)</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">BiTNode <span class="token operator">*</span> <span class="token function">BST_Search</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>t<span class="token punctuation">,</span>ElemType key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BiTNode <span class="token operator">*</span>p<span class="token operator">=</span>t<span class="token punctuation">;</span>  <span class="token comment">//工作指针 初值指向二叉排序树根结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> key<span class="token operator">!=</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">/</span>p不为空且没有找到key        <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span>              p<span class="token operator">=</span>p<span class="token operator">-></span>lchild<span class="token punctuation">;</span><span class="token comment">//如果key值比p指向结点值小，则查找左子树</span>        <span class="token keyword">else</span>              p<span class="token operator">=</span>p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>  <span class="token comment">//如果key值比p指向结点值大，则查找右子树</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token comment">//查找成功返回指向值为key值的结点的指针 查找失败返回NULL </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最好效率：$\mathbf{O(log_2n)}$<br>最坏效率：$\mathbf{O(n)}$</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>1.删叶子，直接删<br>2.删除的是仅有左子树或者右子树的结点，让其子树取代，“子承父业”<br>3.删除的是左右子树都有的结点。中序遍历，删除结点的直接前驱或者直接后继结点来取代。</p><h3 id="AVL平衡二叉树树的性质和调整"><a href="#AVL平衡二叉树树的性质和调整" class="headerlink" title="AVL平衡二叉树树的性质和调整"></a>AVL平衡二叉树树的性质和调整</h3><p>左右子树的高度差不超过1，为平衡二叉树<br>高度差为<strong>平衡因子</strong>，平衡二叉树的结点平衡因子只有0，-1和1<br>平衡二叉树可以为空树</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入后二叉树不平衡了<br>从插入路径上找到与插入结点最近的<strong>平衡因子绝对值大于1</strong>的结点，将其作为根的<strong>子树</strong>（组成三个点，按照以下情况调整）</p><h5 id="LL调整"><a href="#LL调整" class="headerlink" title="LL调整"></a>LL调整</h5><p><img src="/2023/06/23/data-structure/12.png"></p><h5 id="RR调整"><a href="#RR调整" class="headerlink" title="RR调整"></a>RR调整</h5><p><img src="/2023/06/23/data-structure/13.png"></p><h5 id="LR调整"><a href="#LR调整" class="headerlink" title="LR调整"></a>LR调整</h5><p><img src="/2023/06/23/data-structure/14.png"></p><h5 id="RL调整"><a href="#RL调整" class="headerlink" title="RL调整"></a>RL调整</h5><p><img src="/2023/06/23/data-structure/15.png"></p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>插入看自己，删除看兄弟<br>1.用<strong>二叉排序树删除</strong>的方法删（叶子直接删；只有一颗子树，用子树代替；两颗子树都有，中序遍历用前驱或者后继代替）<br>2.从删除的位置向上找到第一个<strong>不平衡点</strong>，从该点向下高度最高的点，一条线有三个。(以x，y，z为例，z为第一个不平衡点，y是z的最高孩子结点，x是y的最高孩子结点)<br>3.之后同上的插入方法，根据x，y，z的情况旋转<br>深度为h的最少结点数为$N_n$<br>$N_0&#x3D;0$，$N_1&#x3D;1$，$N_2&#x3D;2$，$N_n&#x3D;N_{(n-1)}+N_{(n-2)}$+1</p><h3 id="B树和B-树的性质"><a href="#B树和B-树的性质" class="headerlink" title="B树和B+树的性质"></a><font color="#dd0000">B树和B+树的性质</font></h3><h4 id="m阶B树特点"><a href="#m阶B树特点" class="headerlink" title="m阶B树特点"></a>m阶B树特点</h4><p>1）树中每个结点至多有<strong>m</strong>棵子树。（即至多含有<strong>m-1个关键字</strong>) (“两棵子树指针夹着一个关键字”)<br>2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)<br>3）除根结点外的所有非叶结点至少有⌈m&#x2F;2⌉(向上取整)棵子树。（即至少含有⌈m&#x2F;2⌉-1个关键字）<br>如图所示是一个5阶B树：<br><img src="/2023/06/23/data-structure/16.png"></p><h5 id="B树结点子树个数"><a href="#B树结点子树个数" class="headerlink" title="B树结点子树个数"></a>B树结点子树个数</h5><p><strong>根结点</strong>:子树个数$\mathbf{[2,m]}$ &emsp; 关键字数$\mathbf{[1,m-1]}$<br><strong>其他结点</strong>:子树个数$\mathbf{[⌈m&#x2F;2⌉,m]}$ &emsp; 关键字数$\mathbf{[⌈m&#x2F;2⌉-1,m-1]}$<br><strong>该类题求解方法：</strong><br>1.关键字最少$\Leftrightarrow$子树少$\Leftrightarrow$结点少；<br>2.关键字个数：<br>&emsp;最少结点：每个结点的关键字最多，m-1<br>&emsp;最多结点：每个结点的关键字最少，⌈m&#x2F;2⌉-1</p><h4 id="m阶B-树特点"><a href="#m阶B-树特点" class="headerlink" title="m阶B+树特点"></a>m阶B+树特点</h4><p>结点的子树个数与关键字个数相同<br>支持顺序查找和随机查找，B树只支持随机<br><img src="/2023/06/23/data-structure/17.png"><br>m阶的B+树与m阶的B树的<strong>主要差异</strong>在于：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即<font color="#dd0000">每个关键字对应一棵子树</font>；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m&#x2F;2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m&#x2F;2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。<br>3）在B+树中，<font color="#dd0000">叶结点包含信息，所有非叶结点仅起到索引作用</font>，非叶结点中的每个索引项只含有对应子树的<font color="#dd0000">最大关键字</font>和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，<font color="#dd0000">叶结点包含了全部关键字</font>，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。<br>主要应用：<br>编译器中的词法分析：二叉树<br>数据库索引：B+<br>路由表查找：折半</p><h4 id="B树插入与删除"><a href="#B树插入与删除" class="headerlink" title="B树插入与删除"></a>B树插入与删除</h4><h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>可能插入后B树的高度+1，因为根结点也进行分裂<br>步骤：<br>1.找到插入的叶子结点<br>2.若该结点插入后，关键字仍小于等于m-1，则直接插入。反之，则将需要<strong>分裂</strong>。分裂的方法：取这个关键字数组中的中间关键字(⌈m&#x2F;2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。需要从该结点的父结点持续向上进行，若不符合要求，就依次分裂直到根结点。<br><img src="/2023/06/23/data-structure/18.png"></p><h5 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h5><h5 id="1）删除的关键字不在终端结点上（最底层非叶子结点）"><a href="#1）删除的关键字不在终端结点上（最底层非叶子结点）" class="headerlink" title="1）删除的关键字不在终端结点上（最底层非叶子结点）"></a>1）删除的关键字不在终端结点上（最底层非叶子结点）</h5><p>用直接前驱(最右下)和直接后继(最左下)来代替，然后便转换为了“在终端结点”的问题<br><img src="/2023/06/23/data-structure/19.png"></p><h5 id="2）删除的关键字在终端结点上（最底层非叶子结点）"><a href="#2）删除的关键字在终端结点上（最底层非叶子结点）" class="headerlink" title="2）删除的关键字在终端结点上（最底层非叶子结点）"></a>2）删除的关键字在终端结点上（最底层非叶子结点）</h5><p>1.结点内关键字数量<strong>大于</strong>⌈m&#x2F;2⌉-1(不能等于)，删除后仍大于等于⌈m&#x2F;2⌉-1这时删除这个关键字不会破坏B树的定义要求。所以直接删除。<br>2.结点内关键字数量<strong>等于</strong>⌈m&#x2F;2⌉-1，并且其左右兄弟结点中存在关键字数量<strong>大于</strong>⌈m&#x2F;2⌉-1 的结点，则去兄弟阶段中借关键字。<br><img src="/2023/06/23/data-structure/20.png"><br>3.结点内关键字数量<strong>等于</strong>⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中都是关键字数量<strong>等于</strong>⌈m&#x2F;2⌉-1 的结点，则需要进行结点合并。<br><img src="/2023/06/23/data-structure/21.png"></p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>主要是<strong>除留余数法</strong>m，H(key)&#x3D;key % p</p><h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><p>1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。<strong>易“堆积”</strong>，降低查找效率<br>2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为$d\pm1^2$，$d\pm2^2$……$d\pm{k^2}$<br>$m$是列表长度，则$k\leq{m&#x2F;2}$,$m$必须是一个$4k+3$的质数<br>平方探测法是一种较好的处理冲突的方法，可以<strong>避免</strong>出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</p><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以<strong>把所有的同义词存储在一个线性链表中</strong>，这个线性链表由其散列地址唯一标识。拉链法适用于<strong>经常进行插入和删除的情况</strong>。<br><img src="/2023/06/23/data-structure/22.png"><br>ASL成功$&#x3D;\frac{1\times6+2\times4+3\times1+4\times1}{12}$ &emsp;分母12为总数据个数<br>ASL失败$&#x3D;\frac{0+4+0+2+0+0+2+1+0+0+2+1+0}{13}$ &emsp;分母13为散列表长度</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>装填因子：散列表的装填因子一般记为α，定义为一个表的装满程度。<br>计算方法为α&#x3D;表中记录数𝑛&#x2F;散列表长度𝑚<br>散列表的平均查找长度依赖于散列表的填装因子α，而不直接依赖于n或m。<br>α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小。<br><font color="#dd0000">散列函数、冲突处理方法、装填因子以上三者都是影响平均查找长度的因素</font></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。<br>可以用链表，则移动次数减少，但比较次数增多<br>特点：<strong>前半部分是有序的</strong> 第n趟排序，则至少有n+1个有序</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void InsertSort(ElemType A[],int n)&#123;    int i,j;    for(i&#x3D;2;i&lt;&#x3D;n;i++)        if(A[i].key&lt;A[i-1].key)&#123;            A[0]&#x3D;A[i];&#x2F;&#x2F;复制为哨兵，A[0]不存放元素            for(j&#x3D;i-1;A[0].key&lt;A[j].key;--j)                A[j+1]&#x3D;A[j];&#x2F;&#x2F;所有比待插入元素值大的都往后移一位，腾出空位            A[j+1]&#x3D;A[0];&#x2F;&#x2F;复制到插入位置     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间复杂度</strong>：在下标为0处存储哨兵，是常数个辅助空间大小，所以空间复杂度为$O(1)$<br><strong>时间复杂度</strong>：最好$O(n)$，最坏$O(n^2)$，实际<font color="#dd0000">$\mathbf{O(n^2)}$</font>，**<font color="#dd0000">稳定</font>**</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>只能顺序表<br>通过折半查找到插入的位置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//i记录的是待插入的元素下标，也就是说i-1之前的元素都是有序的</span>        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//保存待插入的值</span>        low<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>high<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//折半查找</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> high<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token keyword">else</span> low<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//找到了待插入的位置 接下来从后往前依次后移元素腾出位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span>A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        A<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//因为此时high指向的是待插入位置的前一位</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>减少了比较次数————$O(nlog_2n)$<br>但时间复杂度仍是<font color="#dd0000">$\mathbf{O(n^2)}$</font>，**<font color="#dd0000">稳定</font>**</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>仅适用于顺序表<br>希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。<br>①先以增量5来分割序列，也就是下标为0,5,10,15…的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。<br>②缩小增量(d1&#x3D;n&#x2F;2，di+1&#x3D; ⌊di&#x2F;2⌋，比如10个数据序列，第一次增量d1&#x3D;10&#x2F;2&#x3D;5,第二次增量d2&#x3D; ⌊d1&#x2F;2⌋&#x3D; ⌊5&#x2F;2⌋&#x3D;2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。<br>③接下来的第三轮，第四轮…都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。<br><img src="/2023/06/23/data-structure/23.png"><br>步长为d，则分组就有d个分组<br><strong>希尔排序的优势：</strong><br>希尔排序的每一轮都会使整个序列变得越来越有序，最后一轮当增量为1的时候，整个序列几乎都是有序的，所以进行直接插入排序会提高排序的效率。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span> <span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>dk<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>dk<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>dk<span class="token operator">=</span>dk<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//初始增量为总长度的一半,之后依次除2且向下取整,且最后一次要为1</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>dk<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span>dk<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//A[i].key是待插入的关键字，i-dk之前的都是有序的，如果待插入的比有序序列最后一个小则需要进行排序(进入if语句块)，如果大则不需要(跳出if语句块)</span>                A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//待插入关键字暂存在A[0]</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>dk<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> j<span class="token operator">-=</span>dk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//待插入关键字之前以dk为增量的关键字只要比待插入关键字大的都往后移动dk位</span>                    A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token comment">//找到了待插入的位置，就将待插入关键字插入这个位置</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间复杂度</strong>：希尔排序的空间复杂度为$O(1)$<br><strong>时间复杂度</strong>：希尔排序的时间复杂度约为<font color="#dd0000">$\mathbf{O(n^{1.3})}$</font>    在最坏情况下希尔排序的时间复杂度为$O(n^2)$<br>**<font color="#dd0000">不稳定</font>**：由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        flag<span class="token operator">=</span>false<span class="token punctuation">;</span><span class="token comment">//tips:当整个序列都有序的时候，标志位是不发生修改的，从而表示已经排好了</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//一趟冒泡过程</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果前面的元素比后面的大，则需要做交换</span>                ElemType temp<span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>                A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>                A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">=</span>temp<span class="token punctuation">;</span>                flag<span class="token operator">=</span>true<span class="token punctuation">;</span> <span class="token comment">//发生了数据交换 修改标志位</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span>false<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment">//本趟遍历后没有发生交换，说明表已经有序</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间复杂度</strong>：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)<br><strong>时间复杂度</strong>：最好$\mathbf{O(n)}$，最坏$\mathbf{O(n^2)}$，实际<font color="#dd0000">$\mathbf{O(n^2)}$</font>，**<font color="#dd0000">稳定</font>**</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>顺序表<br>每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//划分函数</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//low是当前待排序的序列起始下标，high是末尾下标</span>    ElemType pivot<span class="token operator">=</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//第一个元素作为枢轴</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">>=</span>pivot<span class="token punctuation">)</span> <span class="token operator">--</span>high<span class="token punctuation">;</span><span class="token comment">//先从末尾往前找到第一个比枢轴小的元素</span>        A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//用high的元素替换low的元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> <span class="token operator">++</span>low<span class="token punctuation">;</span> <span class="token comment">//再从开头往后找到第一个比枢轴大的元素</span>        A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//用low的元素替换high的元素</span>    <span class="token punctuation">&#125;</span>    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>pivot<span class="token punctuation">;</span><span class="token comment">//枢轴元素存放到最终位置</span>    <span class="token keyword">return</span>  low<span class="token punctuation">;</span><span class="token comment">//返回存放枢轴的最终位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//快排函数</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//low和high值要合法</span>        <span class="token keyword">int</span> pivotpos<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>pivotpos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分治递归左半部分</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>pivotpos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分治递归右半部分</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度</strong>：最好$O(nlog_2n)$ ,最坏$O(n^2)$，实际<font color="#dd0000">$\mathbf{O(nlog_2n)}$</font>，**<font color="#dd0000">不稳定</font>**<br>性能最优<br><strong>特点</strong>：每趟排序排完后，pivot元素一定在最终位置上。所以n趟排序，至少有n个元素在最终位置上<br><img src="/2023/06/23/data-structure/24.png"><br><strong>特殊应用</strong>：<br>找第k大的数<br>1.排序<br>2.不排序。用快排思想找pivot，若pivot在第k个位置就算是找到了。时间复杂度O(n)</p><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>第i趟，对n-i次关键字进行比较，找到最大&#x2F;最小与第i个元素进行替换<br><strong>跟元素的初始状态无关</strong><br><strong>时间复杂度</strong>：<font color="#dd0000">$\mathbf{O(n^2)}$</font></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color="#dd0000">堆排序</font></h3><p>堆：完全二叉树<br><img src="/2023/06/23/data-structure/25.png"><br>大根堆(用于升序)：根大于子树<br>小根堆：根小于子树<br>以大根堆为例：从下往上，将左右子树中大于根中最大的代替根<br>从第i个元素开始，i&#x3D;n&#x2F;2向下取整<br>大根堆代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//由数组下标高处往低处,从第一个可能需要调整的非叶</span>    <span class="token comment">//结点开始检查，直到根结点(注意根结点下标不是0是从1开始存储)</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//A是存储堆的数组,k是需要检查的结点下标,len是堆中结点个数</span>    A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//A[0]暂存这个需要检查的结点值</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//从这个结点的左孩子开始往下比较，若发生交换对交换过的结点继续和其孩子比较</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//若右孩子大一些就只要考虑和右孩子比较</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//若该结点的值大于它较大孩子结点值则不需要交换</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//若这个结点的值小于它较大孩子结点值则将孩子结点值赋值给该结点</span>            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            k<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//i赋值给k也就是从i开始继续往下检查 直到所有结点检查结束</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//检查到最后k的值就是最后一轮交换过的结点位置下标将该结点换过去</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间复杂度</strong>：堆排序只需要在交换结点的时候需要额外存储空间来辅佐，所以空间复杂度为$O(1)$<br>时间复杂度：<br>堆排序的总时间可以分为<strong>①建堆部分</strong>+<strong>②n-1次向下调整堆</strong><br><strong>①建堆部分</strong>:时间复杂度为$O(n)$<br><strong>②调堆部分</strong>:一次调堆从上至下最坏情况走得路径是从根结点到叶子结点，完全二叉树的高度为$⌈log_2(n+1)⌉$，所以时间复杂度为$O(log_2n)$那么n-1个顶点时间复杂度为$O(nlog_2n)$<br>堆排序的时间复杂度为$O(n)$+$(nlog_2n)$&#x3D;<font color="#dd0000">$\mathbf{O(nlog_2n)}$</font>，**<font color="#dd0000">不稳定</font>**<br>堆建立好后，输出堆顶，用末尾元素代替，然后按照前面的方法进行调整</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始建堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>len<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//n-1趟的交换和建堆过程</span>        <span class="token function">Swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出堆顶元素(和堆底元素交换)</span>        <span class="token function">AdjustDown</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把剩余的i-1个元素整理成堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用于选前n个最大值(用小根堆)<br>堆删除首个元素重新建堆会把尾数换到首位</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>用于外存排序，尤其是数据体积很大，内存放不下<br>二路归并排序<br>n个数先分为⌈n&#x2F;2⌉(向上取整)个组，每组2或1个<br>下方为二路归并排序事例<br><img src="/2023/06/23/data-structure/26.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ElemType <span class="token operator">*</span>B<span class="token operator">=</span><span class="token punctuation">(</span>ElemType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//辅助数组</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//表A的两段A[low…mid]和A[mid+1…high]各自有序，将它们合并成一个有序表</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>low<span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将A中所有元素复制到B中</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token comment">//k是归并之后数组的下标计数器</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//比较B的左右两段中的元素</span>            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//将较小值复制到A中</span>        <span class="token keyword">else</span>            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//若第一个表未检测完,则将剩下部分复制过来</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//若第二个表未检测完,则将剩下部分复制过来</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//从中间划分两个子序列</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对左侧子序列进行递归排序</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对右侧子序列进行递归排序</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//归并</span>    <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空间复杂度</strong>：因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为$O(n)$<br><strong>时间复杂度</strong>：每趟排序的时间复杂度都是$O(n)$所以整个归并排序的时间复杂度为<font color="#dd0000">$\mathbf{O(nlog_2n)}$</font>，**<font color="#dd0000">稳定</font>**</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>链式   不比较、不移动<br><strong>基数排序</strong>(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于<strong>关键字各位的大小进行排序</strong>的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为<strong>最高位优先（MSD）</strong>排序和<strong>最低位优先（LSD）</strong>排序。<br>假如以如下10个数据为例：<br><img src="/2023/06/23/data-structure/27.png"><br><strong>第一趟比“个位”</strong>：<br><img src="/2023/06/23/data-structure/28.png"><br><strong>第二趟比“十位”</strong>：<br><img src="/2023/06/23/data-structure/29.png"><br><strong>第三趟比“百位”</strong>：<br><img src="/2023/06/23/data-structure/30.png"><br>关键字数量为$\mathbf{n}$,关键字的位数为$\mathbf{d}$,比如748 d&#x3D;3，$\mathbf{r}$为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即$\mathbf{r&#x3D;10}$<br><strong>空间复杂度</strong>：需要开辟关键字基的个数个队列，所以空间复杂度为$O(r)$<br><strong>时间复杂度</strong>：需要进行关键字位数d次”分配”和”收集”，一次”分配”需要将n个关键字放进各个队列中，一次”收集”需要将r个桶都收集一遍。所以一次”分配”和一次”收集”时间复杂度为$O(n+r)$。d次就需要<font color="#dd0000">$\mathbf{O(d(n+r))}$</font>的时间复杂度。</p><h3 id="排序的比较分析"><a href="#排序的比较分析" class="headerlink" title="排序的比较分析"></a><font color="#dd0000">排序的比较分析</font></h3><font size="2"><table><thead><tr><th align="center">算法种类</th><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th><th align="center">空间复杂度</th><th align="center">是否稳定</th></tr></thead><tbody><tr><td align="center">直插</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">$√$</td></tr><tr><td align="center">冒泡</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">$√$</td></tr><tr><td align="center">选择</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">$×$</td></tr><tr><td align="center">希尔</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n^3)$</td><td align="center">$O(n^{1.3})$</td><td align="center">$O(1)$</td><td align="center">$×$</td></tr><tr><td align="center">快排</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(log_2n)$</td><td align="center">$×$</td></tr><tr><td align="center">堆排</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(1)$</td><td align="center">$×$</td></tr><tr><td align="center">二路归并</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n)$</td><td align="center">$√$</td></tr><tr><td align="center">基数</td><td align="center">$O(d(n+r))$</td><td align="center">$O(d(n+r))$</td><td align="center">$O(d(n+r))$</td><td align="center">$O(r)$</td><td align="center">$√$</td></tr><tr><td align="center"></td></tr></tbody></table></font><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><p><strong>不稳定</strong>：快希选堆<br><strong>时间复杂度</strong>：$O(nlog_2n)$ 快堆归<br><strong>空间复杂度</strong>：$O(log_2n)$ 快；$O(n)$ 归；$O(r)$ 基数<br>注意：$O(n^{1.3})是希尔$$d&#x3D;n&#x2F;2$的步长<br>特殊分类：<br><strong>只能用顺序表</strong>：归并、堆、快排(希尔、折半插入)<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;其余的链式和顺序都可以<br>**时间复杂度与元素初始状态<font color="#dd0000">无关</font>**：基数、选择、归并<br>**比较次数与元素初始状态<font color="#dd0000">无关</font>**：基数、选择<br>**排序趟数与元素初始状态<font color="#dd0000">有关</font>**：快排、冒泡<br>**排序趟数与元素初始状态<font color="#dd0000">无关</font>**：直插、折半、希尔、选择、堆、归并、基数<br><strong>至少确定一个位置</strong>：交换：冒泡、快排；选择：简单选择、堆</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vue可能遇到的问题（更新中）</title>
      <link href="/2023/03/13/vue-problem/"/>
      <url>/2023/03/13/vue-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="1-npm-run-dev失败Error-error-0308010C-digital-envelope-routines-unsupported"><a href="#1-npm-run-dev失败Error-error-0308010C-digital-envelope-routines-unsupported" class="headerlink" title="1.npm run dev失败Error: error:0308010C:digital envelope routines::unsupported"></a>1.npm run dev失败Error: error:0308010C:digital envelope routines::unsupported</h2><p><img src="/2023/03/13/vue-problem/1.png"></p><p>问题原因：node版本过高，因为 node.js V17版本中最近发布的OpenSSL3.0, 而OpenSSL3.0对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响.</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="1-通过命令设置NODE-OPTIONS参数"><a href="#1-通过命令设置NODE-OPTIONS参数" class="headerlink" title="1.通过命令设置NODE_OPTIONS参数"></a>1.通过命令设置NODE_OPTIONS参数</h4><p>这个办法的缺点是每次构建前都需要执行一次命令<br>windows与linux或mac系统设置命令不一样，并且需要在项目目录下执行该命令，直接cmd命令默认路径下执行会无效。</p><p>windows系统：</p><pre class="line-numbers language-none"><code class="language-none">set NODE_OPTIONS&#x3D;--openssl-legacy-provider<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>linux或mac系统：</p><pre class="line-numbers language-none"><code class="language-none">export NODE_OPTIONS&#x3D;--openssl-legacy-provider<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-修改package-json"><a href="#2-修改package-json" class="headerlink" title="2.修改package.json"></a>2.修改package.json</h4><p>在相关构建命令之前加入set NODE_OPTIONS&#x3D;–openssl-legacy-provider，这个办法可以一劳永逸，以后直接通过npm执行scripts里面的命令即可。不管是项目迭代，还是团队开发，这种都比较有效。<br><img src="/2023/03/13/vue-problem/2.png"></p><h4 id="3-降低node版本"><a href="#3-降低node版本" class="headerlink" title="3.降低node版本"></a>3.降低node版本</h4><p>回到16版本以下。这个办法也可以解决问题，不过需要考虑到整个系统架构与技术选型问题，以及不同版本的兼容问题。不管是卸载node重装还是使用nvm工具降低版本，均有风险。特别是nvm工具降版本有时会出现意想不到的错误。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
            <tag> vue </tag>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown实用教程</title>
      <link href="/2023/03/12/markdown-use/"/>
      <url>/2023/03/12/markdown-use/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Markdown"><a href="#一、Markdown" class="headerlink" title="一、Markdown"></a>一、Markdown</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>Markdown</strong> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>当前许多网站都广泛使用 <strong>Markdown</strong> 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等</p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>这里采用的是vs code的编辑，下载几个插件。教程：<a href="https://zhuanlan.zhihu.com/p/56943330">https://zhuanlan.zhihu.com/p/56943330</a></p><hr><h2 id="二、徽章"><a href="#二、徽章" class="headerlink" title="二、徽章"></a>二、徽章</h2><p><strong>什么是徽章？</strong><br>徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。</p><p>常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。</p><p>在<strong>Markdown</strong>中使用</p><pre class="line-numbers language-none"><code class="language-none">格式:[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片语法：[![github](https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;github-xugaoyi-brightgreen.svg)](https:&#x2F;&#x2F;github.com&#x2F;jourser)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本文档主要介绍markdown，不对徽章做过多介绍。</p><hr><h2 id="三、标题"><a href="#三、标题" class="headerlink" title="三、标题"></a>三、标题</h2><pre class="line-numbers language-none"><code class="language-none"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题注：# 后面保持空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="四、文本"><a href="#四、文本" class="headerlink" title="四、文本"></a>四、文本</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre class="line-numbers language-none"><code class="language-none">*斜体文本* 或 _斜体文本_**粗体文本**或  __粗体文本__***粗斜体文本***或 ___粗斜体文本___<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><p><em>斜体文本</em><br>或 <em>斜体文本</em><br><strong>粗体文本</strong><br>或  <strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br>或 <em><strong>粗斜体文本</strong></em></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><pre class="line-numbers language-none"><code class="language-none">~~BAIDU.COM~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：<br><del>BAIDU.COM</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：</p><pre class="line-numbers language-none"><code class="language-none">&lt;u&gt;带下划线的文本&lt;&#x2F;u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：<br><u>带下划线的文本</u></p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre class="line-numbers language-none"><code class="language-none">********- - -----------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><hr><h2 id="五、列表"><a href="#五、列表" class="headerlink" title="五、列表"></a>五、列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用星号*、加号+或是减号-作为列表标记：</p><pre class="line-numbers language-none"><code class="language-none">* 第一项* 第二项+ 第一项+ 第二项- 第一项- 第二项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><ul><li>第一项</li><li>第二项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字并加上. 号来表示</p><pre class="line-numbers language-none"><code class="language-none">1. 第一项2. 第二项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下：</p><ol><li>第一项</li><li>第二项</li></ol><h3 id="折叠列表"><a href="#折叠列表" class="headerlink" title="折叠列表"></a>折叠列表</h3><pre class="line-numbers language-none"><code class="language-none">&lt;details&gt;&lt;summary&gt;点我打开关闭折叠&lt;&#x2F;summary&gt; 折叠内容 &lt;ul&gt;     &lt;li&gt;1&lt;&#x2F;li&gt;     &lt;li&gt;2&lt;&#x2F;li&gt;     &lt;li&gt;3&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;details&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：&lt;details&gt; 标签内写markdown代码无效，可写html代码，如ul&gt;li、table等</p><p>结果如下：</p><details><summary>点我打开关闭折叠</summary> <ul>     <li>1</li>     <li>2</li>     <li>3</li> </ul></details><h3 id="带复选框列表"><a href="#带复选框列表" class="headerlink" title="带复选框列表"></a>带复选框列表</h3><pre class="line-numbers language-none"><code class="language-none">* [x] 第一项* [ ] 第二项* [ ] 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注：在部分线上预览未支持<br>结果如下：</p><ul><li><input checked disabled type="checkbox"> 第一项</li><li><input disabled type="checkbox"> 第二项</li><li><input disabled type="checkbox"> 第三项</li></ul><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><pre class="line-numbers language-none"><code class="language-none">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素       - 第三层嵌套<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素<ul><li>第三层嵌套</li></ul></li></ul></li></ol><hr><h2 id="六、代码"><a href="#六、代码" class="headerlink" title="六、代码"></a>六、代码</h2><p>如果是段落上的一个代码片段可以用反引号把它包起来（&#96;），示例：</p><pre class="line-numbers language-none"><code class="language-none">&#96;alert()&#96; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：<br><code>alert()</code> </p><p>用三个反引号 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮</p><p>本代码区块为示例说明：</p><pre class="line-numbers language-none"><code class="language-none">​&#96;&#96;&#96;javascriptfunction test() &#123;alert(&#39;test&#39;)&#125;​&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：<br>​<code>javascript function test() &#123;     alert(&#39;test&#39;) &#125; ​</code></p><hr><h2 id="七、区块引用"><a href="#七、区块引用" class="headerlink" title="七、区块引用"></a>七、区块引用</h2><h3 id="区块简单引用"><a href="#区块简单引用" class="headerlink" title="区块简单引用"></a>区块简单引用</h3><p>区块引用是在段落开头使用 <code>&gt;</code>符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><pre class="line-numbers language-none"><code class="language-none">&gt; 区块引用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><blockquote><p>区块引用</p></blockquote><h3 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h3><pre class="line-numbers language-none"><code class="language-none">&gt; 第一层&gt; &gt; 第二层&gt; &gt; &gt; 第三层<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p></blockquote></blockquote></blockquote><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><pre class="line-numbers language-none"><code class="language-none">&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; * 111&gt; * 222<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>111</li><li>222</li></ul></blockquote><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><pre class="line-numbers language-none"><code class="language-none">* 第一项    &gt; 区块* 第二项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><ul><li>第一项<blockquote><p>区块</p></blockquote></li><li>第二项</li></ul><hr><h2 id="八、链接"><a href="#八、链接" class="headerlink" title="八、链接"></a>八、链接</h2><p>格式：</p><pre class="line-numbers language-none"><code class="language-none">[链接名称](链接地址)[链接名称](链接地址,可选的alt)或&lt;链接地址&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">[百度](http:&#x2F;&#x2F;www.baidu.com,&#39;百度&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：<br><a href="http://www.baidu.com,'百度'/">百度</a><br>直接显示链接地址</p><pre class="line-numbers language-none"><code class="language-none">&lt;http:&#x2F;&#x2F;www.baidu.com&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：<br><a href="http://www.baidu.com/">http://www.baidu.com</a></p><hr><h2 id="九、表格"><a href="#九、表格" class="headerlink" title="九、表格"></a>九、表格</h2><p>制作表格使用 <code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行。</p><pre class="line-numbers language-none"><code class="language-none">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>对齐方式：</strong></p><ul><li>-: 设置内容和标题栏居右对齐</li><li>:- 设置内容和标题栏居左对齐</li><li>:-: 设置内容和标题栏居中对齐<pre class="line-numbers language-none"><code class="language-none">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>结果如下：<table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul><hr><h2 id="十、Emoji表情包"><a href="#十、Emoji表情包" class="headerlink" title="十、Emoji表情包"></a>十、Emoji表情包</h2><p>Emoji表情英文名的前后加冒号</p><pre class="line-numbers language-none"><code class="language-none">:smirk:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：<br>:smirk:<br>更多表情名称请查看：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">表情包清单</a></p><h2 id="十一、数学公式"><a href="#十一、数学公式" class="headerlink" title="十一、数学公式"></a>十一、数学公式</h2><p>例：向上取整与向下取整公式</p><pre class="line-numbers language-none"><code class="language-none">向下取整：$\lfloor x \rfloor$向上取整：$\lceil x \rceil$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下：<br>向下取整：$\lfloor x \rfloor$<br>向上取整：$\lceil x \rceil$</p><p>更多数学公式请查看：<a href="https://blog.csdn.net/weixin_42782150/article/details/104878759">史上最全Markdown公式、符号总结</a></p><h2 id="十二、Makrdown使用中小问题总结-实时更新中"><a href="#十二、Makrdown使用中小问题总结-实时更新中" class="headerlink" title="十二、Makrdown使用中小问题总结(实时更新中)"></a>十二、Makrdown使用中小问题总结(实时更新中)</h2><h3 id="1-如何在Markdown文档中插入空格"><a href="#1-如何在Markdown文档中插入空格" class="headerlink" title="1. 如何在Markdown文档中插入空格?"></a>1. 如何在Markdown文档中插入空格?</h3><p>在Markdown中，无论打连续多少空格，最终显示结果只会有一个空格，如此如何将两段话中间插入更多的空格将其分隔开就成了问题。</p><pre class="line-numbers language-none"><code class="language-none">插入一个空格 (non-breaking space)　　　　一个&amp;nbsp;一个    或    一个&amp;#160;一个     或      一个&amp;#xA0;一个插入两个空格 (en space)　　　　两个&amp;ensp;两个     或    两个&amp;#8194;两个   或      两个&amp;#x2002;两个插入四个空格 (em space)　　　　四个&amp;emsp;四个    或    四个&amp;#8195;四个   或      四个&amp;#x2003;四个插入细空格 (thin space)　　　　细&amp;thinsp;细   或     细&amp;#8201;细  或      细&amp;#x2009;细<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：<br>插入一个空格 (non-breaking space)<br>　　　　一个&nbsp;一个</p><p>插入两个空格 (en space)<br>　　　　两个&ensp;两个</p><p>插入四个空格 (em space)<br>　　　　四个&emsp;四个</p><p>插入细空格 (thin space)<br>　　　　细&thinsp;细</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Markdown </tag>
            
            <tag> 问题解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用教程</title>
      <link href="/2023/03/12/git-use/"/>
      <url>/2023/03/12/git-use/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常用命令："><a href="#一、常用命令：" class="headerlink" title="一、常用命令："></a>一、常用命令：</h2><ul><li>mkdir XX：创建一个空目录 XX指目录名</li><li>pwd：显示当前目录的路径</li><li>cat xx：查看xx文件内容</li><li><font color="#dd0000"> git init：把当前的目录变成可以管理的git仓库，生成隐藏的.git文件夹</font></li><li>git add xx：把xx文件添加到暂存区</li><li>git commit -m “xx”：提交文件 -m后面的是注释，必须写！</li><li>git status：查看仓库状态</li><li>git log：查看历史记录</li><li>git reset –hard HEAD^：往上回退一个版本</li><li>git reflog：查看历史记录的版本号id</li><li>git checkout – xx：把xx文件在工作区的修改全部撤销</li><li>git rm xx：删除xx文件</li><li><font color="#dd0000">git remote add origin <a href="https://github.com/xxxxx/a.git">https://github.com/xxxxx/a.git</a> 关联一个远程库</font></li><li>git push -u（第一次尽量加上-u，以后不用）origin master：把当前master分支推送到远程库</li><li>git clone <a href="https://github.com/xxxxx">https://github.com/xxxxx</a> 从远程库中克隆</li><li>git checkout -b dev：创建dev分支 并切换到dev分支上</li><li>git branch：查看当前所有的分支</li><li>git checkout master：切换回master分支</li><li>git merge dev：在当前分支合并dev分支</li><li>git branch -d dev：删除dev分支</li><li><font color="#dd0000">git branch xxx：创建分支xxx</font></li><li>git remote：查看远程库信息</li><li>git remote -v查看远程库的详细信息</li><li><font color="#dd0000">git pull origin master 将远程库的更新拉取到本地并自动合并</font></li><li>git push origin master：git会把master分支推送到远程库对应的分支上</li></ul><hr><h2 id="二、GitHub远程仓库的使用"><a href="#二、GitHub远程仓库的使用" class="headerlink" title="二、GitHub远程仓库的使用"></a>二、GitHub远程仓库的使用</h2><h3 id="场景一（关联）：本地有仓库，要和远程仓库做关联"><a href="#场景一（关联）：本地有仓库，要和远程仓库做关联" class="headerlink" title="场景一（关联）：本地有仓库，要和远程仓库做关联"></a>场景一（关联）：本地有仓库，要和远程仓库做关联</h3><p>右键git bash here，输入命令</p><pre class="line-numbers language-none"><code class="language-none">git initgit add .git commit -m “first commit”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在GitHub上创建一个远程仓库</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.git (HTTPS) #仓库地址根据实际选择<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>备注：如果此步关联错了，解决办法如下。</p><ul><li>暴力解决：删除.git文件夹，重新建立本地仓库。</li><li>优雅解决：git remote remove origin，再在重新关联仓库</li></ul><h3 id="场景二（推送）：本地有仓库有内容，要推送给远程库"><a href="#场景二（推送）：本地有仓库有内容，要推送给远程库" class="headerlink" title="场景二（推送）：本地有仓库有内容，要推送给远程库"></a>场景二（推送）：本地有仓库有内容，要推送给远程库</h3><pre class="line-numbers language-none"><code class="language-none">git push -u origin master （首次加-u）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据提示输入用户名密码<br>我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地master分支和远程的master分支关联起来，在以后的推送时可以简化命令<code>git push origin master</code>。<br>备注：正常情况下，成功推送一次后，电脑会记住和账号与密码，下次推送时不会再提示输入。若在电脑不能够自动记住github的账户和密码，需执行以下命令解决：<code>git config --global credential.helper store</code>。</p><h3 id="场景三（拉取）：本地有仓库有内容，获取远程库新内容"><a href="#场景三（拉取）：本地有仓库有内容，获取远程库新内容" class="headerlink" title="场景三（拉取）：本地有仓库有内容，获取远程库新内容"></a>场景三（拉取）：本地有仓库有内容，获取远程库新内容</h3><ul><li><strong>第一种拉取方式：</strong> <code>git pull origin master</code>，<br>将远程仓库的master分支上代码版本复制&#x2F;合并到本地master分支上</li><li><strong>第二种拉取方式：</strong><code>git fetch origin master:tmp</code><br>新建一个tmp分支，将远程仓库的master分支上代码版本复制到tmp分支上，不会自动合并。</li></ul><h3 id="场景四（克隆）：本地无仓库，要获取一个完整的远程库"><a href="#场景四（克隆）：本地无仓库，要获取一个完整的远程库" class="headerlink" title="场景四（克隆）：本地无仓库，要获取一个完整的远程库"></a>场景四（克隆）：本地无仓库，要获取一个完整的远程库</h3><p>备注：只在第一次获取远程库时才需要克隆</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;xxx.git (HTTPS)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源网站</title>
      <link href="/2023/03/11/resource-website/"/>
      <url>/2023/03/11/resource-website/</url>
      
        <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN</a> |<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">MDN-JS标准内置对象</a>  Web技术权威文档</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信开放文档</a>  微信小程序开发文档</li><li><a href="https://cloud.tencent.com/developer/devdocs">腾讯云开发者手册</a></li><li><a href="https://www.runoob.com/">菜鸟教程</a>  涵盖多种语言的初级教程</li><li><a href="https://aisuda.bce.baidu.com/amis/zh-CN/docs/index">amis文档</a> 低代码前端框架,使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率</li><li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/">vue-element-admin</a>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现。</li></ul><hr><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><ul><li><a href="https://github.com/">GitHub</a>  程序员同性交友社区</li><li><a href="https://juejin.cn/">掘金</a>  一个帮助开发者成长的社区</li><li><a href="https://segmentfault.com/">思否</a>  解决技术问题的社区</li><li><a href="https://www.jianshu.com/">简书</a>  有很多频道的创作社区</li><li><a href="https://maliquankai.com/designnav/">马力全开资源库</a>  很全很强大，独立开发者&#x2F;设计干货&#x2F;优质利器&#x2F;工具资源…</li><li><a href="https://leetcode.cn/">力扣</a> 刷题1</li><li><a href="https://www.luogu.com.cn/">洛谷</a> 刷题2</li></ul><hr><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><h3 id="AI相关"><a href="#AI相关" class="headerlink" title="AI相关"></a>AI相关</h3><ul><li><a href="https://www.bing.com/search?form=MY0291&OCID=MY0291&q=Bing+AI&showconv=1">Copilot</a> 微软AI助手</li><li><a href="https://chat.openai.com/">ChatGPT</a> OpenAI的ChatGPT</li><li><a href="https://yiyan.baidu.com/">文心一言</a> 百度的AI工具</li></ul><h3 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h3><ul><li><a href="https://unbug.github.io/codelf/">CODELF</a> Codelf 是一款帮助开发者命名变量的神器</li></ul><h3 id="办公相关"><a href="#办公相关" class="headerlink" title="办公相关"></a>办公相关</h3><ul><li><a href="https://www.pptsupermarket.com/">PPT模板</a>  PPT模板免费下载</li><li><a href="https://smallpdf.com/cn#s=dashboard">PDF工具1</a>  线上免费PDF工具</li><li><a href="https://www.ilovepdf.com/zh-cn">PDF工具2</a></li></ul><h3 id="图片工具"><a href="#图片工具" class="headerlink" title="图片工具"></a>图片工具</h3><ul><li><a href="https://www.remove.bg/zh/upload">抠图</a> 上传一张图片以消除背景</li><li><a href="https://squoosh.app/">压缩1</a> 可进行图片压缩前后对比</li><li><a href="https://imagestool.com/webp2jpg-online/">压缩2</a> 可支持批量压缩</li></ul><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li><a href="https://hardwaretester.com/gamepad">手柄测试</a> 测试连接电脑手柄性能，如死区</li><li><a href="https://www.steamgriddb.com/">steam游戏图片</a> 本地游戏用steam打开配置所需自定义图片</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://bbs.tampermonkey.net.cn/forum.php">油猴中文网</a>  油猴脚本交流分析论坛</li><li><a href="https://www.lookae.com/">Lookae</a> 大众脸影视后期特效</li><li><a href="https://msdn.itellyou.cn/">MSDN</a> windows各版本资源站</li><li><a href="https://aisuda.github.io/amis-editor-demo/#/hello-world">amis</a> 低代码前端框架</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
            <tag> 脚本 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo可能遇到的问题（更新中）</title>
      <link href="/2023/03/10/problems-for-hexo/"/>
      <url>/2023/03/10/problems-for-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-博客网页上图片不显示"><a href="#1-博客网页上图片不显示" class="headerlink" title="1.博客网页上图片不显示"></a>1.博客网页上图片不显示</h2><ul><li>用Markdown编辑器编.md文件，可以显示文件，但当上传后生成博客时，却无法显示。</li></ul><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><h4 id="1-检测路径"><a href="#1-检测路径" class="headerlink" title="1.检测路径"></a>1.检测路径</h4><ul><li>首先检查在.md文件中的图片路径，尽量选择相对路径例如（.&#x2F;hexo-blog-create&#x2F;img1.png）这样的格式。</li></ul><h4 id="2-修改站点配置文件"><a href="#2-修改站点配置文件" class="headerlink" title="2.修改站点配置文件"></a>2.修改站点配置文件</h4><ul><li>打开blog根目录下的<strong>站点</strong>配置文件，找到<strong>post_asset_folder</strong>将其值改为<strong>true</strong><br>如下图所示：<br><img src="/2023/03/10/problems-for-hexo/1.png"></li></ul><h4 id="3-安装插件"><a href="#3-安装插件" class="headerlink" title="3.安装插件"></a>3.安装插件</h4><ul><li>在blog目录下，用cmd打开dos窗口（或者用git bash），下载一个用于上传图片的插件。<br>输入命令：<code>npm install https://github.com/CodeFalling/hexo-asset-image</code><br><font color="#dd0000">注意：此处与网上的其他教程不同，网上教程普遍是使用命令<code>npm install hexo-asset-image --save</code>，该插件可以上传图片，但在hexo读取时，路径会出错，所以建议使用本文提供的路径，尤其是windows用户。</font><br></li></ul><h4 id="4-创建文章"><a href="#4-创建文章" class="headerlink" title="4.创建文章"></a>4.创建文章</h4><ul><li>此时用命令<code>hexo n &quot;hello world&quot;</code>创建title为hello world文章，会发现会在同级目录下产生一个与文章名相同的hello world文件夹。可以将图片放入其中。<br><font color="#dd0000">建议创建英文标题的文章，这样生成的图片文件夹也是中文的。在上传图片的过程中，中文会被转为URL编码。若是坚持使用中文，则建议在.md文件中，将图片路径中的所有中文和特殊字符转为URL编码。过于复杂，所以还是建议全英文处理。</font><br></li></ul><h4 id="5-上传检验"><a href="#5-上传检验" class="headerlink" title="5.上传检验"></a>5.上传检验</h4><ul><li>最后再提交上传即可。</li></ul><pre class="line-numbers language-none"><code class="language-none">hexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="2-博客文章无法显示数学公式"><a href="#2-博客文章无法显示数学公式" class="headerlink" title="2.博客文章无法显示数学公式"></a>2.博客文章无法显示数学公式</h2><ul><li>用Markdown编辑器编.md文件，文章内可以显示数学公式，但当上传后生成博客时，却无法正常显示。</li></ul><h3 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h3><ul><li>方法根据具体情况而定，网上大部分教程大部分都是基于安装 hexo-math 插件实现的。</li><li>但是具体实施又有着各种大相径庭的操作。</li><li>比如：把渲染引擎从 hexo-renderer-marked 更换到 hexo-renderer-kramed；要求不使用 hexo-math，而是使用 hexo-renderer-mathjax；最后添加或是修改 <code>_config.yml</code> 中的配置，而所需的配置内容的格式层级却又相差甚远。</li><li>而且最重要的一点是没有提及具体的版本。</li><li>我的Hexo截止至2023年9月7日，是<code>6.3.0</code>版本，是比较新的版本。网上的教程那么比较老，那么就是与主题插件不符。</li><li>对的，有些Hexo主题可能需要额外的配置才能正确显示数学公式。因此主题选择同样很重要。</li><li>基本的主题，往往都是有mathjax设置的。</li><li>本人采用的主题是<strong>hexo-theme-matery</strong>。</li><li>在主题的<code>_config.yml</code>文件中，将mathjax开启，如</li></ul><pre class="line-numbers language-none"><code class="language-none"># MathJax Supportmathjax:  enable: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-文章基本信息修改"><a href="#3-文章基本信息修改" class="headerlink" title="3.文章基本信息修改"></a>3.文章基本信息修改</h2><ul><li>修改文章封面，修改文章轮播图，文章启用数学公式等基本功能。采用<strong>hexo-theme-matery</strong>主题，如何熟练使用。</li></ul><h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><pre class="line-numbers language-none"><code class="language-none">---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;data&#125;&#125;author: 作者名字img: &#x2F;medias&#x2F;featureimages&#x2F;xxx.jpg &quot;文章特征图,路径在source中&quot;top: true &quot;推荐文章&quot;cover: true &quot;表示该文章是否需要加入到首页轮播封面中&quot;coverImg: &#x2F;images&#x2F;1.jpg &quot;轮播图中的封面,访问的是&quot;source&quot;下的&quot;images&quot;&quot;password: 8d969eef6ecad3c29toc: false &quot;是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项&quot;mathjax: false &quot;是否开启数学公式支持,本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行&quot;summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文章-Front-matter-选项详解"><a href="#文章-Front-matter-选项详解" class="headerlink" title="文章 Front-matter 选项详解"></a>文章 Front-matter 选项详解</h3><table><thead><tr><th align="center">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="left">Markdown 的文件标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="center">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="center">author</td><td align="left">根 <code>_config.yml</code> 中的 author</td><td align="left">文章作者</td></tr><tr><td align="center">img</td><td align="left">featureImages 中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="center">top</td><td align="left">true</td><td align="left">推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td></tr><tr><td align="center">cover</td><td align="left">false</td><td align="left">v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="center">coverImg</td><td align="left">无</td><td align="left">v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="center">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项</td></tr><tr><td align="center">toc</td><td align="left">true</td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td align="center">mathjax</td><td align="left">false</td><td align="left">是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td align="center">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="center">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="center">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><h2 id="4-hexo在多台电脑提交和更新"><a href="#4-hexo在多台电脑提交和更新" class="headerlink" title="4. hexo在多台电脑提交和更新"></a>4. hexo在多台电脑提交和更新</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>通过<code>git</code>分支来实现hexo的同步。</li><li>如果通过前文的方式创建博客，那么会与网上的教程不同。本文在GitHub仓库中创建两个分支<code>master</code>和<code>main</code>，这两个分支共同组成了静态页面文件。</li><li>每当执行<code>hexo d</code>的时候，hexo都会帮我们把生成好的静态页面文件推到<code>master</code>和<code>main</code>分支上，这是和网上教程不同的地方。网上大部分教程，只有一个<code>master</code>分支。</li><li>不过，尽管如此，我们的解决办法依旧是相同的。就是创建一个新的分支，用来存放hexo的源文件。通过对hexo源文件的采用<code>git push</code>和<code>git pull</code>，实现多台电脑的同步。</li></ul><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="在原主机上操作"><a href="#在原主机上操作" class="headerlink" title="在原主机上操作"></a>在原主机上操作</h4><h5 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1.创建分支"></a>1.创建分支</h5><ul><li>创建分支的方法很多，本文只是其中一种，适合git初学者</li></ul><ol><li>在Github的username.github.io仓库上新建一个xxx分支<div align="center"><img src="/2023/03/10/problems-for-hexo/3.png" width="70%/"></div></li></ol><div align="center"><img src="/2023/03/10/problems-for-hexo/4.png" width="100%/"></div><ol start="2"><li>将默认分支设为xxx，update保存。</li></ol><ul><li>由于执行<code>hexo d</code> 对应的分支和默认分支是没有关系的，因为这是由配置文件决定的，配置文件写的哪个分支就是哪个分支。为了分别日后的提交和更新，需要将默认分支设为xxx。</li></ul><div align="center"><img src="/2023/03/10/problems-for-hexo/5.png" width="100%/"></div><h5 id="2-克隆新分支"><a href="#2-克隆新分支" class="headerlink" title="2. 克隆新分支"></a>2. 克隆新分支</h5><ol><li><p>Git Bash执行<code>git clone git@github.com:username/username.github.io.git</code></p></li><li><p>进入username.github.io文件夹，执行<code>git branch</code>命令查看当前所在分支，应为新建的分支xxx</p><div align="center"><img src="/2023/03/10/problems-for-hexo/6.png" width="70%/"></div></li><li><p>该步骤可做可不做，但建议做，删除username.github.io文件夹内除了<code>.git</code>文件外的所有文件</p></li><li><p>先将本地博客的部署文件（Hexo目录下的全部文件，除<code>node_modules</code>,<code>public</code>,<code>.deploy_git</code>等文件可不用）全部拷贝进username.github.io文件目录中去</p></li></ol><div align="center"><img src="/2023/03/10/problems-for-hexo/7.png" width="100%/"></div><ol start="5"><li>Git Bash执行依次执行<pre class="line-numbers language-none"><code class="language-none">git add .git commit -m &#39;hexo&#39; （引号内容可随意更改，只是类似注释的作用）git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p>下面是每个命令的具体作用：</p><ul><li><code>git add .</code>：这个命令将当前目录下的所有更改（包括新文件和修改过的文件）添加到Git的暂存区（staging area）。这是提交前的一个步骤，意味着你已经准备好将这些更改记录到版本历史中。</li><li><code>git commit -m &#39;hexo&#39;</code>：这个命令将暂存区的内容提交到本地的Git仓库中。-m 参数后面跟着的是提交信息，<strong>必须要有</strong>，这里是 ‘hexo’，但你可以将其更改为任何描述性的消息，以说明这次提交的内容或目的。提交信息是重要的，因为它帮助开发者理解每次提交的意图。</li><li><code>git push</code>：这个命令将本地仓库的提交推送到远程仓库。如果你在一个团队中工作，并且你的代码需要与其他人共享，这一步是必要的。这会将你的本地更改上传到远程服务器，使得其他人可以拉取（pull）你的更改。</li></ul></li><li><p>注意，将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。</p></li><li><p>最后，可在仓库中看到提交的文件。</p></li></ul><div align="center"><img src="/2023/03/10/problems-for-hexo/8.png" width="100%/"></div><h4 id="在新主机上操作"><a href="#在新主机上操作" class="headerlink" title="在新主机上操作"></a>在新主机上操作</h4><h5 id="1-将新电脑的生成的ssh-key添加到GitHub账户上"><a href="#1-将新电脑的生成的ssh-key添加到GitHub账户上" class="headerlink" title="1.将新电脑的生成的ssh key添加到GitHub账户上"></a>1.将新电脑的生成的ssh key添加到GitHub账户上</h5><ul><li>这一操作可参考前文<a href="https://jourser.github.io/2023/03/02/hexo-blog-create/">《Hexo个人博客搭建》</a></li></ul><h5 id="2-克隆分支"><a href="#2-克隆分支" class="headerlink" title="2.克隆分支"></a>2.克隆分支</h5><ul><li>在新电脑上克隆username.github.io仓库的<code>source</code>分支(就是存放源码的分支)到本地，此时本地git仓库处于<code>hexo</code>分支,可以执行<code>git branch -v</code>查看</li></ul><h5 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3.准备工作"></a>3.准备工作</h5><ul><li>包括安装node.js，Git 和Hexo</li><li>该步骤同样参考前文<a href="https://jourser.github.io/2023/03/02/hexo-blog-create/">《Hexo个人博客搭建》</a></li><li>在执行Hexo命令前，记得先在该目录执行<code>npm install</code>命令安装依赖，会在该目录下生成<code>node_modules</code>文件夹</li><li>总结可直接执行以下指令：<pre class="line-numbers language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;registry.npmmirror.com npm install hexo-cli -g npm installnpm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>各指令的含义：<ul><li><code>npm config set registry https://registry.npmmirror.com</code>：改变npm镜像为淘宝镜像，淘宝镜像随时可能更改，建议百度选择最新镜像</li><li><code>npm install hexo-cli -g</code>：安装hexo</li><li><code>npm install</code>：安装依赖</li><li><code>npm install hexo-deployer-git --save</code>：安装Git部署插件</li></ul></li></ul><ol start="4"><li>至此，新电脑的hexo迁移已经完成了。以下是创建新博客同步的步骤。<ol><li><code>git pull</code>合并更新，尤其是换新电脑更新的时候。若只在同一台电脑上操作，则不需要这一步。</li><li>创建新文章</li><li>将新文件上传至github仓库的<code>hexo</code>分支，也就是源文件分支</li><li>部署网站<pre class="line-numbers language-none"><code class="language-none">git add .git commit –m &#39;日期&#39;git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hexo clean hexo g hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li></ol><h2 id="5-hexo-g-出现-错误信息-SyntaxError-Invalid-or-unexpected-token"><a href="#5-hexo-g-出现-错误信息-SyntaxError-Invalid-or-unexpected-token" class="headerlink" title="5. hexo g 出现 错误信息 SyntaxError: Invalid or unexpected token"></a>5. hexo g 出现 错误信息 SyntaxError: Invalid or unexpected token</h2><ul><li>该错误是我使用hexo在多台电脑提交和更新，也就是上一步发现的。<br><img src="/2023/03/10/problems-for-hexo/9.png"></li><li>原因：该错误产生的原因可能是hexo的版本不一致，导致生成的静态文件不兼容与主题不兼容导致的。</li><li>这个错误信息 <code>SyntaxError: Invalid or unexpected token</code> 通常表示 JavaScript 解析器在尝试执行代码时遇到了一个它无法理解的符号或标记。在这种情况下，错误发生在处理 EJS 模板文件 <code>D:\Jourser.github.io\themes\hexo-theme-matery\layout\archive.ejs</code> 时。</li></ul><h3 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h3><ul><li>该问题可采取直接删除<code>archive.ejs</code>文件的内的注释解决。</li><li>打开<code>archive.ejs</code>文件，删除以下内容：<br><img src="/2023/03/10/problems-for-hexo/10.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
            <tag> hexo </tag>
            
            <tag> 博客搭建 </tag>
            
            <tag> 主题hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客搭建</title>
      <link href="/2023/03/02/hexo-blog-create/"/>
      <url>/2023/03/02/hexo-blog-create/</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-node-js安装"><a href="#1-node-js安装" class="headerlink" title="1.node.js安装"></a>1.node.js安装</h3><p>安装地址：<a href="https://nodejs.org/en/">此处</a><br>安装教程：<a href="https://cloud.tencent.com/developer/article/2103562">此处</a></p><h3 id="2-Git-安装"><a href="#2-Git-安装" class="headerlink" title="2.Git 安装"></a>2.Git 安装</h3><p>安装地址：<a href="https://git-scm.com/">此处</a><br>安装教程：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">此处</a><br>（ps以上均为windows版本，请根据自身的操作系统情况选择对应的版本）</p><h3 id="3-验证安装完成结果"><a href="#3-验证安装完成结果" class="headerlink" title="3.验证安装完成结果"></a>3.验证安装完成结果</h3><p>键盘按住Windows徽标键+R键，打开“运行”窗口：<br><img src="/2023/03/02/hexo-blog-create/img1.png"><br>输入“cmd”，回车打开dos窗口<br><img src="/2023/03/02/hexo-blog-create/img2.png"><br>依次输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">node -vnpm -vgit --version  #注意version前面有两个“-”符，不能遗漏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果显示：<br><img src="/2023/03/02/hexo-blog-create/img3.png"><br>成功显示了版本号，即为成功。</p><h3 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4.安装Hexo"></a>4.安装Hexo</h3><p>同样在dos窗口<br>输入命令：<br><code>npm install hexo-cli -g</code><br>若是下载速度很慢，一直停在第一步。则需要改变npm镜像，我使用的是淘宝镜像<br>在dos窗口输入命令：<br><code>npm config set registry https://registry.npm.taobao.org</code><br>然后再输入：<br><code>npm install hexo-cli -g</code><br>验证是否安装完成，输入命令：<br><code>hexo -v</code><br>成功结果如下：<br><img src="/2023/03/02/hexo-blog-create/img4.png"></p><hr><h2 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h2><h3 id="1-点击New"><a href="#1-点击New" class="headerlink" title="1.点击New"></a>1.点击New</h3><p>首先有GitHub账号，进入GitHub官网登录 <a href="https://github.com/">GitHub</a><br>进入网址后，点击页面中的如下图标：<br><img src="/2023/03/02/hexo-blog-create/img5.png"></p><h3 id="2-输入Repository-name"><a href="#2-输入Repository-name" class="headerlink" title="2.输入Repository name"></a>2.输入Repository name</h3><p>在Repository name项输入：<code>你的GitHub账号名.github.io</code><br><font color="#dd0000">切记一定是你的GitHub账号名</font><br> </p><h3 id="3-设置公开"><a href="#3-设置公开" class="headerlink" title="3.设置公开"></a>3.设置公开</h3><p>公开仓库<br><img src="/2023/03/02/hexo-blog-create/img6.png"></p><h3 id="4-添加README-file"><a href="#4-添加README-file" class="headerlink" title="4.添加README file"></a>4.添加README file</h3><p><img src="/2023/03/02/hexo-blog-create/img7.png"><br>最后创建即可。</p><hr><h2 id="三、生成SSH-Keys"><a href="#三、生成SSH-Keys" class="headerlink" title="三、生成SSH Keys"></a>三、生成SSH Keys</h2><h3 id="1-右键点击Git-Bash-Here"><a href="#1-右键点击Git-Bash-Here" class="headerlink" title="1.右键点击Git Bash Here"></a>1.右键点击Git Bash Here</h3><p>打开任意一个文件夹，右键然后选择Git Bash Here<br><img src="/2023/03/02/hexo-blog-create/img8.png"></p><h3 id="2-检测SSH安装"><a href="#2-检测SSH安装" class="headerlink" title="2.检测SSH安装"></a>2.检测SSH安装</h3><p>在窗口中输入命令：<code>ssh</code><br>检测ssh是否安装（默认都是安装完成的）<br><img src="/2023/03/02/hexo-blog-create/img9.png"><br><font color="#dd0000">注意在该窗口不能使用Ctrl+v的快捷方式粘贴，应该用shift+ins快捷键，或者是右键选择Paste</font><br> </p><h3 id="3-设置配置信息（非必须）"><a href="#3-设置配置信息（非必须）" class="headerlink" title="3.设置配置信息（非必须）"></a>3.设置配置信息（非必须）</h3><p>设置user.name和user.email配置信息(此步非必须)：</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-生成密钥文件"><a href="#4-生成密钥文件" class="headerlink" title="4.生成密钥文件"></a>4.生成密钥文件</h3><p>生成ssh密钥文件：</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制<br>路径基本上都会在 C:\Users\用户名\.ssh</p><h3 id="5-新建-SSH-Key"><a href="#5-新建-SSH-Key" class="headerlink" title="5.新建 SSH Key"></a>5.新建 SSH Key</h3><p>打开<a href="https://github.com/settings/keys">GitHub SSH and GPG keys </a>页面，新建new SSH Key<br><img src="/2023/03/02/hexo-blog-create/img10.png"><br>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。</p><h3 id="6-检测"><a href="#6-检测" class="headerlink" title="6.检测"></a>6.检测</h3><p>重新回到Git Bash中检测公钥是否安装成功，输入：<code>ssh git@github.com</code><br><img src="/2023/03/02/hexo-blog-create/img11.png"><br>结果如上即为成功。</p><h2 id="四、Hexo本地使用"><a href="#四、Hexo本地使用" class="headerlink" title="四、Hexo本地使用"></a>四、Hexo本地使用</h2><h3 id="1-初始化博客"><a href="#1-初始化博客" class="headerlink" title="1.初始化博客"></a>1.初始化博客</h3><p>建议创建一个新文件夹，然后在该文件夹下进入dos窗口。<br>具体方法如下图所示：<br><img src="/2023/03/02/hexo-blog-create/img12.png"><br>进入dos窗口后，输入：<code>hexo init blog</code></p><h3 id="2-检测功能"><a href="#2-检测功能" class="headerlink" title="2.检测功能"></a>2.检测功能</h3><p>进入blog文件夹，用上述方法进入dos窗口<br>按顺序在dos中输入：</p><pre class="line-numbers language-none"><code class="language-none">hexo new test  #新建文章,文章名为testhexo g #生成hexo s #部署<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-本地打开"><a href="#3-本地打开" class="headerlink" title="3.本地打开"></a>3.本地打开</h3><p>根据上一步得到部署后的地址，端口一般默认为4000<br>在浏览器输入地址：localhost:4000<br>显示博客界面如下：<br><img src="/2023/03/02/hexo-blog-create/img13.png"><br>注：该img实例没有新建test文章，若是按照本文的顺序安装，会有标题为test的文章。</p><h3 id="4-常用Hexo命令"><a href="#4-常用Hexo命令" class="headerlink" title="4.常用Hexo命令"></a>4.常用Hexo命令</h3><pre class="line-numbers language-none"><code class="language-none">npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo n &quot;我的博客&quot; &#x3D;&#x3D; hexo new &quot;我的博客&quot; &quot;我的博客&quot; #  新建文章名为&quot;我的博客&quot;hexo g &#x3D;&#x3D; hexo generate #生成网页hexo s &#x3D;&#x3D; hexo server #启动服务预览hexo d &#x3D;&#x3D; hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口5000hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、推送网址至GitHub"><a href="#五、推送网址至GitHub" class="headerlink" title="五、推送网址至GitHub"></a>五、推送网址至GitHub</h2><h3 id="1-打开站点配置文件并修改"><a href="#1-打开站点配置文件并修改" class="headerlink" title="1.打开站点配置文件并修改"></a>1.打开站点配置文件并修改</h3><p>在blog根目录下，有_config.yml文件，为<strong>站点</strong>配置文件<br>如图所示：<img src="/2023/03/02/hexo-blog-create/img14.png"><br>打开该文件，拉到最后将其修改为：<br>deploy:<br>type: git<br>repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git<br>branch: main</p><p><font color="#dd0000">注意：此处可能与网上的其他教程不同，branch的值为main。这是由于在2020年10月1日起，GitHub默认主分支从master更名为main，以上的提交方式会默认创建一个master分支，为保持一致性，可将本地git init的时候默认分支修改为main。<br>在dos窗口，输入:</font><br></p><pre class="line-numbers language-none"><code class="language-none">git --version  #查看版本git config --global init.defaultBranch main #git版本在2.28.0上，重新设置默认分支为main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考如下：<br><img src="/2023/03/02/hexo-blog-create/img15.png"></p><h3 id="2-安装Git部署插件"><a href="#2-安装Git部署插件" class="headerlink" title="2.安装Git部署插件"></a>2.安装Git部署插件</h3><p>需要让Hexo知晓我们将blog部署到GitHub仓库，在dos窗口输入：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-部署网站"><a href="#3-部署网站" class="headerlink" title="3.部署网站"></a>3.部署网站</h3><p>在dos窗口继续依次输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">hexo clean hexo g hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-打开测试"><a href="#4-打开测试" class="headerlink" title="4.打开测试"></a>4.打开测试</h3><p>不出意外，网站推送成功，地址为: https:&#x2F;&#x2F;你的GitHub账号名.github.io 即为个人网站的仓库路径。用浏览器打开，即可得到和本地打开一样的个人博客。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
